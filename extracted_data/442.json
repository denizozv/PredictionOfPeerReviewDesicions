{
  "id": "442",
  "title": "Deep Variational Information Bottleneck",
  "abstract": "We present a variational approximation to the information bottleneck of Tishby et al. (1999). This variational approach allows us to parameterize the information bottleneck model using a neural network and leverage the reparameterization trick for efficient training. We call this method “Deep Variational Information Bottleneck”, or Deep VIB. We show that models trained with the VIB objective outperform those that are trained with other forms of regularization, in terms of generalization performance and robustness to adversarial attack.",
  "accepted": true,
  "zeroShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": false,
        "confidence": 0.92,
        "primary_reason": "Novel variational framework for information bottleneck with strong theoretical grounding, comprehensive experiments on MNIST demonstrating improved generalization and adversarial robustness, and clear methodological contribution suitable for top-tier ML venues"
      },
      "token": {
        "prompt_tokens": 8017,
        "completion_tokens": 73,
        "total_tokens": 8090
      },
      "time": "2026-02-05T22:47:04.389341+00:00"
    }
  ],
  "article": [
    {
      "heading": "1 INTRODUCTION",
      "text": "We adopt an information theoretic view of deep networks. We regard the internal representation of some intermediate layer as a stochastic encoding Z of the input source X , defined by a parametric encoder p(z|x;).1 Our goal is to learn an encoding that is maximally informative about our target Y , measured by the mutual information between our encoding and the target I(Z, Y ;), where I(Z, Y ;) = dx dy p(z, y|) log p(z, y|) p(z|)p(y|) . 2 (1) Given the data processing inequality, and the invariance of the mutual information to reparameterizations, if this was our only objective we could always ensure a maximally informative representation by taking the identity encoding of our data (Z = X), but this is not a useful representation of our data. Instead we would like to find the best representation we can obtain subject to a constraint on its complexity. A natural and useful constraint to apply is on the mutual information between our encoding and the original data, I(X,Z) Ic, where Ic is the information constraint. This suggests the objective: max I(Z, Y ;) s.t. I(X,Z;) Ic . (2) Equivalently, with the introduction of a Lagrange multiplier , we can maximize the objective function RIB() = I(Z, Y ;) I(Z,X;). (3) Here our goal is to learn an encoding Z that is maximally expressive about Y while being maximally compressive about X , where 0 controls the tradeoff.3 This approach is known as the information bottleneck (IB), and was first proposed in Tishby et al. (1999). Intuitively, the first term in RIB encourages Z to be predictive of Y ; the second term encourages Z to forget X . Essentially it forces Z to act like a minimal sufficient statistic of X for predicting Y . The IB principle is appealing, since it defines what we mean by a good representation, in terms of the fundamental tradeoff between having a concise representation and one with good predictive power (Tishby & Zaslavsky, 2015a). The main drawback of the IB principle is that computing mutual information is, in general, computationally challenging. There are two notable exceptions: the first 1 In this work, X,Y, Z are random variables, x, y, z and x,y, z are instances of random variables, and F (;) and f(;) are functionals or functions parameterized by . 2 Note that in the present discussion, Y is the ground truth label which is independent of our parameters so p(y|) = p(y). 3 Note that, in our notation, large results in a highly compressed representation. In some works, the IB principle is formulated as the minimization of I(Z,X) I(Z, Y ), in which case large corresponds to high mutual information between Z and Y , and hence low compression. is when X , Y and Z are all discrete, as in Tishby et al. (1999); this can be used to cluster discrete data, such as words. The second case is when X , Y and Z are all jointly Gaussian (Chechik et al., 2005). However, these assumptions both severely constrain the class of learnable models. In this paper, we propose to use variational inference to construct a lower bound on the IB objective in Equation 3. We call the resulting method VIB (variational information bottleneck). By using the reparameterization trick (Kingma & Welling, 2014), we can use Monte Carlo sampling to get an unbiased estimate of the gradient, and hence we can optimize the objective using stochastic gradient descent. This allows us to use deep neural networks to parameterize our distributions, and thus to handle high-dimensional, continuous data, such as images, avoiding the previous restrictions to the discrete or Gaussian cases. We also show, by a series of experiments, that stochastic neural networks, fit using our VIB method, are robust to overfitting, since VIB finds a representation Z which ignores as many details of the inputX as possible. In addition, they are more robust to adversarial inputs than deterministic models which are fit using (penalized) maximum likelihood estimation. Intuitively this is because each input image gets mapped to a distribution rather than a unique Z, so it is more difficult to pass small, idiosyncratic perturbations through the latent bottleneck.",
      "exclude": true
    },
    {
      "heading": "2 RELATED WORK",
      "text": "The idea of using information theoretic objectives for deep neural networks was pointed out in Tishby & Zaslavsky (2015b). However, they did not include any experimental results, since their approach for optimizing the IB objective relied on the iterative Blahut Arimoto algorithm, which is infeasible to apply to deep neural networks. Variational inference is a natural way to approximate the problem. Variational bounds on mutual information have previously been explored in Agakov (2004), though not in conjunction with the information bottleneck objective. Mohamed & Rezende (2015) also explore variational bounds on mutual information, and apply them to deep neural networks, but in the context of reinforcement learning. We recently discovered Chalk et al. (2016), who independently developed the same variational lower bound on the IB objective as us. However, they apply it to sparse coding problems, and use the kernel trick to achieve nonlinear mappings, whereas we apply it to deep neural networks, which are computationally more efficient. In addition, we are able to handle large datasets by using stochastic gradient descent, whereas they use batch variational EM. In the supervised learning literature, our work is related to the recently proposed confidence penalty (entropy regularization) method of (Pereyra et al., 2016). In this work, they fit a deterministic network by optimizing an objective that combines the usual cross entropy loss with an extra term which penalizes models for having low entropy predictive distributions. In more detail, their cost function has the form JCP = 1 N N n=1 [H(p(y|yn), p(y|xn)) H(p(y|xn))] (4) where H(p, q) = y p(y) log q(y) is the cross entropy, H(p) = H(p, p) is the entropy, p(y|yn) = yn(y) is a one-hot encoding of the label yn, and N is the number of training examples. (Note that setting = 0 corresponds to the usual maximum likelihood estimate.) In (Pereyra et al., 2016) they show that CP performs better than the simpler technique of label smoothing, in which we replace the zeros in the one-hot encoding of the labels by > 0, and then renormalize so that the distribution still sums to one. We will compare our VIB method to both the confidence penalty method and label smoothing in Section 4.1. In the unsupervised learning literature, our work is closely related to the work in Kingma & Welling (2014) on variational autoencoders. In fact, their method is a special case of an unsupervised version of the VIB, but with the parameter fixed at 1.0, as we explain in Appendix B. The VAE objective, but with different values of , was also explored in Higgins et al. (2016), but from a different perspective. The method of Wang et al. (2016b) proposes a latent variable generative model of both x and y; their variational lower bound is closely related to ours, with the following differences. First, we do not have a likelihood term for x, since we are in the discriminative setting. Second, they fix = 1, since they do not consider compression. Finally, the variational fair autoencoder of Louizos et al. (2016) shares with our paper the idea of ignoring parts of the input. However, in their approach, the user must specify which aspects of the input (the so-called sensitive parts) to ignore, whereas in our method, we can discover irrelevant parts of the input automatically.",
      "exclude": true
    },
    {
      "heading": "3 METHOD",
      "text": "Following standard practice in the IB literature, we assume that the joint distribution p(X,Y, Z) factors as follows: p(X,Y, Z) = p(Z|X,Y )p(Y |X)p(X) = p(Z|X)p(Y |X)p(X) (5) i.e., we assume p(Z|X,Y ) = p(Z|X), corresponding to the Markov chain Y X Z. This restriction means that our representation Z cannot depend directly on the labels Y . (This opens the door to unsupervised representation learning, which we will discuss in Appendix B.) Besides the structure in the joint data distribution p(X,Y ), the only content at this point is our model for the stochastic encoder p(Z|X), all other distributions are fully determined by these and the Markov chain constraint. Recall that the IB objective has the form I(Z, Y ) I(Z,X). We will examine each of these expressions in turn. Let us start with I(Z, Y ). Writing it out in full, this becomes I(Z, Y ) = dy dz p(y, z) log p(y, z) p(y)p(z) = dy dz p(y, z) log p(y|z) p(y) . (6) where p(y|z) is fully defined by our encoder and Markov Chain as follows: p(y|z) = dx p(x, y|z) = dx p(y|x)p(x|z) = dx p(y|x)p(z|x)p(x) p(z) . (7) Since this is intractable in our case, let q(y|z) be a variational approximation to p(y|z). This is our decoder, which we will take to be another neural network with its own set of parameters. Using the fact that the Kullback Leibler divergence is always positive, we have KL[p(Y |Z), q(Y |Z)] 0 = dy p(y|z) log p(y|z) dy p(y|z) log q(y|z) , (8) and hence I(Z, Y ) dy dz p(y, z) log q(y|z) p(y) (9) = dy dz p(y, z) log q(y|z) dy p(y) log p(y) (10) = dy dz p(y, z) log q(y|z) +H(Y ) . (11) Notice that the entropy of our labels H(Y ) is independent of our optimization procedure and so can be ignored. Focusing on the first term in Equation 11, we can rewrite p(y, z) as p(y, z) = dx p(x, y, z) = dx p(x)p(y|x)p(z|x) (leveraging our Markov assumption), which gives us a new lower bound on the first term of our objective: I(Z, Y ) dx dy dz p(x)p(y|x)p(z|x) log q(y|z) . (12) This only requires samples from both our joint data distribution as well as samples from our stochastic encoder, while it requires we have access to a tractable variational approximation in q(y|z). We now consider the term I(Z,X): I(Z,X) = dz dx p(x, z) log p(z|x) p(z) = dz dx p(x, z) log p(z|x) dz p(z) log p(z) . (13) In general, while it is fully defined, computing the marginal distribution of Z, p(z) = dx p(z|x)p(x), might be difficult. So let r(z) be a variational approximation to this marginal. Since KL[p(Z), r(Z)] 0 = dz p(z) log p(z) dz p(z) log r(z), we have the following upper bound: I(Z,X) dx dz p(x)p(z|x) log p(z|x) r(z) . (14) Combining both of these bounds we have that I(Z, Y ) I(Z,X) dx dy dz p(x)p(y|x)p(z|x) log q(y|z) dx dz p(x)p(z|x) log p(z|x) r(z) = L . (15) We now discuss how to compute the lower bound L in practice. We can approximate p(x, y) = p(x)p(y|x) using the empirical data distribution p(x, y) = 1N N n=1 xn(x)yn(y), and hence we can write L 1 N N n=1 [ dz p(z|xn) log q(yn|z) p(z|xn) log p(z|xn) r(z) ] . (16) Suppose we use an encoder of the form p(z|x) = N (z|fe (x), fe (x)), where fe is an MLP which outputs both the K-dimensional mean of z as well as the K K covariance matrix . Then we can use the reparameterization trick (Kingma & Welling, 2014) to write p(z|x)dz = p( )d , where z = f(x, ) is a deterministic function of x and the Gaussian random variable . This formulation has the important advantage that the noise term is independent of the parameters of the model, so it is easy to take gradients. Assuming our choice of p(z|x) and r(z) allows computation of an analytic Kullback-Leibler divergence, we can put everything together to get the following objective function, which we try to minimize: JIB = 1 N N n=1 E p( ) [ log q(yn|f(xn, ))] + KL [p(Z|xn), r(Z)] . (17) As in Kingma & Welling (2014), this formulation allows us to directly backpropagate through a single sample of our stochastic code and ensure that our gradient is an unbiased estimate of the true expected gradient.4",
      "exclude": false
    },
    {
      "heading": "4 EXPERIMENTAL RESULTS",
      "text": "In this section, we present various experimental results, comparing the behavior of standard deterministic networks to stochastic neural networks trained by optimizing the VIB objective.",
      "exclude": false
    },
    {
      "heading": "4.1 BEHAVIOR ON MNIST",
      "text": "We start with experiments on unmodified MNIST (i.e. no data augmentation). In order to pick a model with some headroom to improve, we decided to use the same architecture as in the (Pereyra et al., 2016) paper, namely an MLP with fully connected layers of the form 784 - 1024 - 1024 - 10, and ReLu activations. (Since we are not exploiting spatial information, this correpsonds to the permutation invariant version of MNIST.) The performance of this baseline is 1.38% error. (Pereyra et al., 2016) were able to improve this to 1.17% using their regularization technique. We were able to improve this to 1.13% using our technique, as we explain below. In our method, the stochastic encoder has the form p(z|x) = N (z|fe (x), fe (x)), where fe is an MLP of the form 784 1024 1024 2K, where K is the size of the bottleneck. The first K outputs from fe encode , the remaining K outputs encode (after a softplus transform). 4 Even if our choice of encoding distribution and variational prior do not admit an analytic KL, we could similarly reparameterize through a sample of the divergence (Kingma & Welling, 2014; Blundell et al., 2015). The decoder is a simple logistic regression model of the form q(y|z) = S(y|fd(z)), where S(a) = [exp(ac)/ C c=1 exp(ac)] is the softmax function, and fd(z) = Wz + b maps the K dimensional latent code to the logits of the C = 10 classes. (In later sections, we consider more complex decoders, but here we wanted to show the benefits of VIB in a simple setting.) Finally, we treat r(z) as a fixed K-dimensional spherical Gaussian, r(z) = N (z|0, I). We compare our method to the baseline MLP. We calso consider the following deterministic limit of our model, when = 0. In this case, we obtain the following objective function: JIB0 = 1 N N n=1 EzN (fe (xn),fe (xn)) [logS(yn|fd(z)] (18) When 0, we observe the VIB optimization process tends to make fe (x) 0, so the network becomes nearly deterministic. In our experiments we also train an explicitly deterministic model that has the same form as the stochastic model, except that we just use z = fe (x) as the hidden encoding, and drop the Gaussian layer.",
      "exclude": false
    },
    {
      "heading": "4.1.1 HIGHER DIMENSIONAL EMBEDDING",
      "text": "To demonstrate that our VIB method can achieve competitive classification results, we compared against a deterministic MLP trained with various forms of regularization. We use a K = 256 dimensional bottleneck and a diagonal Gaussian for p(z|x). The networks were trained using TensorFlow for 200 epochs using the Adam optimizer (Kingma & Ba, 2015) with a learning rate of 0.0001. Full hyperparameter details can be found in Appendix A. The results are shown in Table 1. We see that we can slightly outperform other forms of regularization that have been proposed in the literature while using the same network for each. Of course, the performance varies depending on . These results are not state of the art, nor is our main focus of our work to suggest that VIB is the best regularization method by itself, which would require much more experimentation. However, using the same architecture for each experiment and comparing to VIB as the only source of regularization suggests VIB works as a decent regularizer in and of itself. Figure 1(a) plots the train and test error vs , averaged over 5 trials (with error bars) for the case where we use a single Monte Carlo sample of z when predicting, and also for the case where we average over 12 posterior samples (i.e., we use p(y|x) = 1S S s=1 q(y|zs) for zs p(z|x), where S = 12). In our own investigations, a dozen samples seemed to be sufficient to capture any additional benefit the stochastic evaluations had to offer in this experiment5. We see several interesting properties in Figure 1(a). First, we notice that the error rate shoots up once rises above the critical value of 102. This corresponds to a setting where the mutual information between X and Z is less than log2(10) bits, so the model can no longer represent the fact that there are 10 different classes. Second, we notice that, for small values of , the test error 5 A dozen samples wasnt chosen for any particular reason, except the old addage that a dozen samples are sufficient, as mirrored in David MacKays book (MacKay, 2003). They proved sufficient in this case. is higher than the training error, which indicates that we are overfitting. This is because the network learns to be more deterministic, forcing 0, thus reducing the benefits of regularization. Third, we notice that for intermediate values of , Monte Carlo averaging helps. Interestingly, the region with the best performance roughly corresponds to where the added benefit from stochastic averaging goes away, suggesting an avenue by which one could try to optimize using purely statistics on the training set without a validation set. We have not extensively studied this possibility yet. In Figure 1(c), we plot the IB curve, i.e., we plot I(Z, Y ) vs I(Z,X) as we vary . As we allow more information from the input through to the bottleneck (by lowering ), we increase the mutual information between our embedding and the label on the training set, but not necessarily on the test set, as is evident from the plot. In Figure 1(d) we plot the second term in our objective, the upper bound on the mutual information between the images X and our stochastic encoding Z, which in our case is simply the relative entropy between our encoding and the fixed isotropic unit Gaussian prior. Notice that the y-axis is a logarithmic one. This demonstrates that our best results (when is between 103 and 102) occur where the mutual information between the stochastic encoding and the images is on the order of 10 to 100 bits.",
      "exclude": false
    },
    {
      "heading": "4.1.2 TWO DIMENSIONAL EMBEDDING",
      "text": "To better understand the behavior of our method, we refit our model to MNIST using a K = 2 dimensional bottleneck, but using a full covariance Gaussian. (The neural net predicts the mean and the Cholesky decomposition of the covariance matrix.) Figure 1(b) shows that, not surprisingly, the classification performance is worse (note the different scaled axes), but the overall trends are the same as in the K = 256 dimensional case. The IB curve (not shown) also has a similar shape to before, except now the gap between training and testing is even larger. Figure 2 provides a visualization of what the network is doing. We plot the posteriors p(z|x) as a 2d Gaussian ellipse (representing the 95% confidence region) for 1000 images from the test set. Colors correspond to the true class labels. In the background of each plot is the entropy of the variational classifier q(y|z) evaluated at that point. We see several interesting properties. First, as increases (so we pass less information through), the embedding covariances increase in relation to the distance between samples, and the classes start to overlap. Second, once passes a critical value, the encoding collapses, and essentially all the class information is lost. Third, there is a fair amount of uncertainty in the class preditions (q(y|z)) in the areas between the class embeddings. Fourth, for intermediate values of (say 101 in Figure 2(b)), predictive performance is still good, even though there is a lot of uncertainty about where any individual image will map to in comparison to other images in the same class. This means it would be difficult for an outside agent to infer which particular instance the model is representing, a property which we will explore more in the following sections.",
      "exclude": false
    },
    {
      "heading": "4.2 BEHAVIOR ON ADVERSARIAL EXAMPLES",
      "text": "Szegedy et al. (2013) was the first work to show that deep neural networks (and other kinds of classifiers) can be easily fooled into making mistakes by changing their inputs by imperceptibly small amounts. In this section, we will show how training with the VIB objective makes models significantly more robust to such adversarial examples.",
      "exclude": false
    },
    {
      "heading": "4.2.1 TYPES OF ADVERSARIES",
      "text": "Since the initial work by Szegedy et al. (2013) and Goodfellow et al. (2014), many different adversaries have been proposed. Most attacks fall into three broad categories: optimization-based attacks (Szegedy et al., 2013; Carlini & Wagner, 2016; Moosavi-Dezfooli et al., 2016; Papernot et al., 2015; Robinson & Graham, 2015; Sabour et al., 2016), which directly run an optimizer such as L-BFGS or ADAM (Kingma & Ba, 2015) on image pixels to find a minimal perturbation that changes the models classification; single-step gradient-based attacks (Goodfellow et al., 2014; Kurakin et al., 2016; Huang et al., 2015), which choose a gradient direction of the image pixels at some loss and then take a single step in that direction; and iterative gradient-based attacks (Kurakin et al., 2016), which take multiple small steps along the gradient direction of the image pixels at some loss, recomputing the gradient direction after each step.6 Many adversaries can be formalized as either untargeted or targeted variants. An untargeted adversary can be defined as A(X,M) X , where A(.) is the adversarial function, X is the input image, X is the adversarial example, and M is the target model. A is considered successful if M(X) 6= M(X ). Recently, Moosavi-Dezfooli et al. (2016) showed how to create a universal adversarial perturbation that can be added to any image X in order to make M(X + ) 6= M(X) for a particular target model. A targeted adversary can be defined as A(X,M, l) X , where l is an additional target label, and A is only considered successful if M(X ) = l.7 Targeted attacks usually require larger magnitude perturbations, since the adversary cannot just nudge the input across the nearest decision boundary, but instead must force it into a desired decision region. In this work, we focus on the Fast Gradient Sign (FGS) method proposed in Goodfellow et al. (2014) and the L2 optimization method proposed in Carlini & Wagner (2016). FGS is a standard baseline attack that takes a single step in the gradient direction to generate the adversarial example. As originally described, FGS generates untargeted adversarial examples. On MNIST, Goodfellow et al. (2014) reported that FGS could generate adversarial examples that fooled a maxout network approximately 90% of the time with = 0.25, where is the magnitude of the perturbation at each pixel. The L2 optimization method has been shown to generate adversarial examples with smaller perturbations than any other method published to date, which were capable of fooling the target network 100% of the time. We consider both targeted attacks and untargeted attacks for the L2 optimization method.8",
      "exclude": false
    },
    {
      "heading": "4.2.2 ADVERSARIAL ROBUSTNESS",
      "text": "There are multiple definitions of adversarial robustness in the literature. The most basic, which we shall use, is accuracy on adversarially perturbed versions of the test set, called adversarial examples. It is also important to have a measure of the magnitude of the adversarial perturbation. Since adversaries are defined relative to human perception, the ideal measure would explicitly correspond to how easily a human observer would notice the perturbation. In lieu of such a measure, it is common to compute the size of the perturbation using L0, L1, L2, and L norms (Szegedy et al., 2013; Goodfellow et al., 2014; Carlini & Wagner, 2016; Sabour et al., 2016). In particular, the L0 norm measures the number of perturbed pixels, the L2 norm measures the Euclidean distance between X and X , and the L norm measures the largest single change to any pixel.",
      "exclude": false
    },
    {
      "heading": "4.2.3 EXPERIMENTAL SETUP",
      "text": "We used the same model architectures as in Section 4.1, using a K = 256 bottleneck. The architectures included a deterministic (base) model trained by MLE; a deterministic model trained with dropout (the dropout rate was chosen on the validation set); and a stochastic model trained with VIB for various values of . For the VIB models, we use 12 posterior samples of Z to compute the class label distribution p(y|x). This helps ensure that the adversaries can get a consistent gradient when constructing the perturbation, and that they can get a consistent evaluation when checking if the perturbation was successful 6 There are also other adversaries that dont fall as cleanly into those categories, such as fooling images from Nguyen et al. (2014), which remove the human perceptual constraint, generating regular geometric patterns or noise patterns that networks confidently classify as natural images; and the idea of generating adversaries by stochastic search for images near the decision boundary of multiple networks from Baluja et al. (2015). 7 Sabour et al. (2016) proposes a variant of the targeted attack, A(XS ,M,XT , k) X S , where XS is the source image, XT is a target image, and k is a target layer in the model M . A produces X S by minimizing the difference in activations of M at layer k between XT and X S . The end result of this attack for a classification network is still that M(X S) yields a target label implicitly specified by XT in a successful attack. 8 Carlini & Wagner (2016) shared their code with us, which allowed us to perform the attack with exactly the same parameters they used for their paper, including the maximum number of iterations and maximum C value (see their paper for details). (i.e., it reduces the chance that the adversary gets lucky in its perturbation due to an untypical sample). We also ran the VIB models in mean mode, where the s are forced to be 0. This had no noticeable impact on the results, so all reported results are for stochastic evaluation with 12 samples.",
      "exclude": false
    },
    {
      "heading": "4.2.4 MNIST RESULTS AND DISCUSSION",
      "text": "We selected the first 10 zeros in the MNIST test set, and use the L2 optimization adversary of Carlini & Wagner (2016) to try to perturb those zeros into ones.9 Some sample results are shown in Figure 3. We see that the deterministic models are easily fooled by making small perturbations, but for the VIB models with reasonably large , the adversary often fails to find an attack (indicated by the green borders) within the permitted number of iterations. Furthermore, when an attack is succesful, it needs to be much larger for the VIB models. To quantify this, Figure 4 plots the magnitude of the perturbation (relative to that of the deterministic and dropout models) needed for a successful attack as a function of . As increases, the L0 norm of the perturbation decreases, but both L2 and L norms increase, indicating that the adversary is being forced to put larger modifications into fewer pixels while searching for an adversarial perturbation. Figure 5 plots the accuracy on FGS adversarial examples of the first 1000 images from the MNIST test set as a function of . Each point in the plot corresponds to 3 separate executions of three different models trained with the same value of . All models tested achieve over 98.4% accuracy on the unperturbed MNIST test set, so there is no appreciable measurement distortion due to underlying model accuracy. Figure 6 plots the accuracy on L2 optimization adversarial examples of the first 1000 images from the MNIST test set as a function of . The same sets of three models per were tested three times, as with the FGS adversarial examples. We generated both untargeted and targeted adversarial examples for Figure 6. For targeting, we generate a random target label different from the source label in order to avoid biasing the results with unevenly explored source/target pairs. We see that for a reasonably broad range of values, the VIB models have significantly better accuracy on the adversarial examples than the deterministic models, which have an accuracy of 0% (the L2 optimization attack is very effective on traditional model architectures). Figure 6 also reveals a surprising level of adversarial robustness even when 0. This can be explained by the theoretical framework of Fawzi et al. (2016). Their work proves that quadratic classifiers (e.g., xTAx, symmetric A) have a greater capacity for adversarial robustness than linear classifiers. As we show in Appendix C, our Gaussian/softmax encoder/decoder is approximately quadratic for all <.",
      "exclude": true
    },
    {
      "heading": "4.2.5 IMAGENET RESULTS AND DISCUSSION",
      "text": "VIB improved classification accuracy and adversarial robustness for toy datasets like MNIST. We now investigate if VIB offers similar advantages for ImageNet, a more challenging natural image classification. Recall that ImageNet has approximately 1M images spanning 1K classes. We preprocess images such that they are 299x299 pixels. Architecture We make use of publicly available, pretrained checkpoints10 of Inception Resnet V2 (Szegedy et al., 2016) on ImageNet (Deng et al., 2009). The checkpoint obtains 80.4% classification accuracy on the ImageNet validation set. Using the checkpoint, we transformed the original training set by applying the pretrained network to each image and extracting the representation at the penultimate layer. This new image representation has 1536 dimensions. The higher layers of the network continue to classify this representation with 80.4% accuracy; conditioned on this extraction the classification 9 We chose this pair of labels since intuitively zeros and ones are the digits that are least similar in terms of human perception, so if the adversary can change a zero into a one without much human-noticeable perturbation, it is unlikely that the model has learned a representation similar to what humans learn. 10Available at the Tensorflow Models repository in the Slim directory: https://github.com/ tensorflow/models/tree/master/slim model is simply logistic regression. To further speed training, we whitened the 1536 dimensional representation. Under this transformation, the experiment regime is identical to the permutation invariant MNIST task. We therefore used a similar model architecture. Inputs are passed through two fully connected layers, each with 1024 units. Next, data is fed to a stochastic encoding layer; this layer is characterized by a spherical Gaussian with 1024 learned means and standard deviations. The output of the stochastic layer is fed to the variational classifieritself a logistic regression, for simplicity. All other hyperparameters and training choices are identical to those used in MNIST, more details in Appendix A. Classification We see the same favorable VIB classification performance in ImageNet as in MNIST. By varying , the estimated mutual information between encoding and image (I(Z,X)) varies as well. At large values of accuracy suffers, but at intermediate values we obtain improved performance over both a deterministic baseline and a = 0 regime. In all cases our accuracy is somewhat lower than the original 80.4% accuracy. This may be a consequence of inadequate training time or suboptimal hyperparameters. Overall the best accuracy we achieved was using = 0.01. Under this setting we saw an accuracy of 80.12%nearly the same as the state-of-the-art unmodified network but with substantially smaller information footprint, only I(X,Z) 45 bits. This is a surprisingly small amount of information; = 0 implies over 10,000 bits yet only reaches an accuracy of 78.87%. The deterministic baseline, which was the same network, but without the VIB loss and a 1024 fully connected linear layer instead of the stochastic embedding similarly only achieved 78.75% accuracy. We stress that regressions from the achievable 80.4% are likely due to suboptimal hyperparameters settings or inadequate training. Considering a continuum of and a deterministic baseline, the best classification accuracy was achieved with a = 0.01 (0, 1). In other words, VIB offered accuracy benefit yet using a mere 45 bits of information from each image. Adversarial Robustness We next show that the VIB-trained network improves resistance to adversarial attack. We focus on the Carlini targeted L2 attack (see Section 4.2.1). We show results for the VIB-trained network and a deterministic baseline (both on top of precomputed features), as well as for the original pretrained Inception ResNet V2 network itself. The VIB network is more robust to the targeted L2 optimization attack in both magnitude of perturbation and frequency of successful attack. Figure 7 shows some example images which were all misclassified as soccer balls by the deterministic models; by contrast, with the VIB model, only 17 out of 30 of the attacks succeeded in being mislabeled as the target label.11 We find that the VIB model can resist about 43.3% of the attacks, but the deterministic models always fail (i.e., always misclassify into the targeted label). Figure 8 shows the absolute pixel differences between the perturbed and unperturbed images for the examples in Figure 7. We see that the VIB network requires much larger perturbations in order to fool the classifier, as quantified in Table 2.",
      "exclude": true
    },
    {
      "heading": "5 FUTURE DIRECTIONS",
      "text": "There are many possible directions for future work, including: putting the VIB objective at multiple or every layer of a network; testing on real images; using richer parametric marginal approximations, rather than assuming r(z) = N (0, I); exploring the connections to differential privacy (see e.g., Wang et al. (2016a); Cuff & Yu (2016)); and investigating open universe classification problems (see e.g., Bendale & Boult (2015)). In addition, we would like to explore applications to sequence prediction, where X denotes the past of the sequence and Y the future, while Z is the current representation of the network. This form of the information bottleneck is known as predictive information (Bialek et al., 2001; Palmer et al., 2015).",
      "exclude": false
    },
    {
      "heading": "A HYPERPARAMETERS AND ARCHITECTURE DETAILS FOR EXPERIMENTS",
      "text": "All of the networks for this paper were trained using TensorFlow (Abadi et al., 2016). All weights were initialized using the default TensorFlow Xavier initialization scheme (Glorot & Bengio, 2010) using the averaging fan scaling factor on uniform noise. All biases were initialized to zero. The Adam optimizer (Kingma & Ba, 2015) was used with initial learning rate of 104, (1 = 0.5, 2 = 0.999) and exponential decay, decaying the learning rate by a factor of 0.97 every 2 epochs. The networks were all trained for 200 epochs total. For the MNIST experiments, a batch size of 100 was used, and the full 60,000 training and validation set was used for training, and the 10,000 test images for test results. The input images were scaled to have values between -1 and 1 before fed to the network. All runs maintained an exponential weighted average of the parameters during the training run; these averaged parameters were used at test time. This is in the style of Polyak averaging Polyak & Juditsky (1992), with a decay constant of 0.999. Our estimate of mutual informations were measured in bits. For the VIB experiments in all sections, no other form of regularization was used. For the 256 dimensional gaussian embeddings of Section 4.1.1, a linear layer of size 512 was used to create the 256 mean values and standard deviations for the embedding. The standard deviations were made to be positive by a softplus transformation with a bias of -5.0 to have them initially be small. = log (1 + exp(x 5.0)) (19) For the 1024 dimensional Imagenet embeddings of Section 4.2.5, a sigma bias of 0.57 was used to keep the initial standard deviations near 1 originally, and a batch size of 200 was used. For the 2 dimensional gaussian embeddings of Section 4.1.2, a linear layer was used with 2+4 = 6 outputs, the first two of which were used for the means, and the other 4 were reshaped to a 2 2 matrix, the center was transformed according to a softplus with a bias of -5.0, and the off diagonal components were multiplied by 102, while the upper triangular element was dropped to form the Cholesky decomposition of the covariance matrix.",
      "exclude": false
    },
    {
      "heading": "B CONNECTION TO VARIATIONAL AUTOENCODERS",
      "text": "We can also consider unsupervised versions of the information bottleneck objective. Consider the objective: max I(Z,X) I(Z, i), (20) similar to the information theoretic objective for clustering introduced in Slonim et al. (2005). Here the aim is to take our dataX and maximize the mutual information contained in some encoding Z, while restricting how much information we allow our representation to contain about the identity of each data element in our sample (i). We will form a bound much like we did in the main text. For the first term, we form a variational decoder q(x|z) and take a bound: I(Z,X) = dx dz p(x, z) log p(x|z) p(x) (21) = H(x) + dz p(x) dx p(x|z) log p(x|z) (22) dz p(x) dx p(x|z) log q(x|z) (23) = dx p(x) dz p(x|z) log q(x|z). (24) Here we have dropped the entropy in our data H(X) because it is out of our control and we have used the nonnegativity of the Kullbach-Leibler divergence to replace our intractable p(x|z) with a variational decoder q(x|z). Turning our attention to the second term, note that: p(z|i) = dx p(z|x)p(x|i) = dx p(z|x)(x xi) = p(z|xi), (25) and that we will take p(i) = 1N . So that we can bound our second term from above I(Z, i) = i dz p(z|i)p(i) log p(z|i) p(z) (26) = 1 N i dz p(z|xi) log p(z|xi) p(z) (27) 1 N i dz p(z|xi) log p(z|xi) r(z) , (28) Where we have replaced the intractable marginal p(z) with a variational marginal r(z). Putting these two bounds together we have that our unsupervised information bottleneck objective takes the form I(Z,X) I(Z, i) dx p(x) dz p(z|x) log q(x|z) 1 N i KL[p(Z|xi), r(Z)]. (29) And this takes the form of a variational autoencoder (Kingma & Welling, 2014), except with the second KL divergence term having an arbitrary weight . It is interesting that while this objective takes the same mathematical form as that of a Variational Autoencoder, the interpretation of the objective is very different. In the VAE, the model starts life as a generative model with a defined prior p(z) and stochastic decoder p(x|z) as part of the model, and the encoder q(z|x) is created to serve as a variational approximation to the true posterior p(z|x) = p(x|z)p(z)/p(x). In the VIB approach, the model is originally just the stochastic encoder p(z|x), and the decoder q(x|z) is the variational approximation to the true p(x|z) = p(z|x)p(x)/p(z) and r(z) is the variational approximation to the marginal p(z) = dx p(x)p(z|x). This difference in interpretation makes natural suggestions for novel directions for improvement. This precise setup, albeit with a different motivation was recently explored in Higgins et al. (2016), where they demonstrated that by changing the weight of the variational autoencoders regularization term, there were able to achieve latent representations that were more capable when it came ot zeroshot learning and understanding objectness. In that work, they motivated their choice to change the relative weightings of the terms in the objective by appealing to notions in neuroscience. Here we demonstrate that appealing to the information bottleneck objective gives a principled motivation and could open the door to better understanding the optimal choice of and more tools for accessing the importance and tradeoff of both terms. Beyond the connection to existing variational autoencoder techniques, we note that the unsupervised information bottleneck objective suggests new directions to explore, including targetting the exact marginal p(z) in the regularization term, as well as the opportunity to explore tighter bounds on the first I(Z,X) term that may not require explicit variational reconstruction.",
      "exclude": false
    },
    {
      "heading": "C QUADRATIC BOUNDS FOR STOCHASTIC LOGISTIC REGRESSION DECODER",
      "text": "Consider the special case when the bottleneck Z is a multivariate Normal, i.e., z|x N(x,x) where x is a K K positive definite matrix. The parameters x,x can be constructed from a deep neural network, e.g., x = 1:K(x) chol(x) = diag(log(1 + exp(K+1:2K))) + subtril(2K+1:K(K+3)/2), where (x) RK(K+3)/2 is the network output of input x. Suppose that the prediction is a categorical distribution computed as S(Wz) where W is a C K weight matrix and logS(x) = x lse(x) is the log-soft-max function with lse(x) = log K k=1 exp(xk) being the log-sum-exp function. This setup (which is identical to our experiments) induces a classifier which is bounded by a quadratic function, which is interesting because the theoretical framework Fawzi et al. (2016) proves that quadratic classifiers have greater capacity for adversarial robustness than linear functions. We now derive an approximate bound using second order Taylor series expansion (TSE). The bound can be made proper via Browne & McNicholas (2015). However, using the TSE is sufficient to sketch the derivation. Jensens inequality implies that the negative log-likelihood soft-max is upper bounded by: log E [S(WZ)|x,x] E [logS(WZ)|x,x] = Wx + E [lse(WZ)|x,x] = Wx + E [lse(Z)|Wx,Wx] . The second order Taylor series expansion (TSE) of lse is given by, lse(x+ ) lse(x) + T S(x) + 12T [ diag(S(x)) S(x)S(x)T ] . Taking the expectation of the TSE at the mean yields, EN(0,WxW T )[ lse(Wx + )] lse(Wx) + EN(0,WxW T )[T ]S(Wx)+ + 12 EN(0,WxW T )[ T [ diag(S(Wx)) S(Wx)S(Wx)T ] ] = lse(Wx) + 1 2 tr(WxW T [ diag(S(Wx)) S(Wx)S(Wx)T ] ) = lse(Wx) + 1 2 tr(WxW T diag(S(Wx))) 12S(Wx)T WxW T S(Wx) = lse(Wx) + 1 2 S(Wx) T WxW T S(Wx) 12S(Wx)T WxW T S(Wx) The second-moment was calculated by noting, E[XT BX] = E tr(XXT B) = tr(E[XXT ]B) = tr(B). Putting this altogether, we conclude, E [S(WZ)|x,x] ' S(Wx) exp ( 12 S(Wx) T WxW T S(Wx) + 12S(Wx)T WxW T S(Wx) ) . As indicated, rather than approximate the lse via TSE, we can make a sharp, quadratic upper bound via Browne & McNicholas (2015). However this merely changes the S(Wx) scaling in the exponential; the result is still log-quadratic.",
      "exclude": false
    }
  ],
  "fewShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": false,
        "confidence": 0.92,
        "primary_reason": "Novel variational framework for information bottleneck with principled neural network parameterization, strong theoretical contribution, comprehensive experiments demonstrating generalization and adversarial robustness benefits, clear connections to VAEs and unsupervised learning."
      },
      "token": {
        "prompt_tokens": 8179,
        "completion_tokens": 85,
        "total_tokens": 8264
      },
      "time": "2026-02-08T22:16:16.240540+00:00"
    }
  ],
  "test": false
}