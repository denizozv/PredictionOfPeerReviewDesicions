{
  "id": "369",
  "title": "Trained Ternary Quantization",
  "abstract": "Deep neural networks are widely used in machine learning applications. However, the deployment of large neural networks models can be difficult to deploy on mobile devices with limited power budgets. To solve this problem, we propose Trained Ternary Quantization (TTQ), a method that can reduce the precision of weights in neural networks to ternary values. This method has very little accuracy degradation and can even improve the accuracy of some models (32, 44, 56-layer ResNet) on CIFAR-10 and AlexNet on ImageNet. And our AlexNet model is trained from scratch, which means it’s as easy as to train normal full precision model. We highlight our trained quantization method that can learn both ternary values and ternary assignment. During inference, only ternary values (2-bit weights) and scaling factors are needed, therefore our models are nearly 16× smaller than full- precision models. Our ternary models can also be viewed as sparse binary weight networks, which can potentially be accelerated with custom circuit. Experiments on CIFAR-10 show that the ternary models obtained by trained quantization method outperform full-precision models of ResNet-32,44,56 by 0.04%, 0.16%, 0.36%, respectively. On ImageNet, our model outperforms full-precision AlexNet model by 0.3% of Top-1 accuracy and outperforms previous ternary models by 3%.",
  "accepted": true,
  "zeroShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": false,
        "confidence": 0.92,
        "primary_reason": "Novel quantization method with strong empirical results on CIFAR-10 and ImageNet, demonstrating practical improvements over prior ternary/binary approaches. Well-motivated, technically sound methodology learning both ternary values and assignments. Appropriate for ICLR/NeurIPS venue."
      },
      "token": {
        "prompt_tokens": 4849,
        "completion_tokens": 91,
        "total_tokens": 4940
      },
      "time": "2026-02-05T22:39:03.332671+00:00"
    },
    {
      "model": "gpt-5.2",
      "decision": {
        "rejection": true,
        "confidence": 0.78,
        "primary_reason": "Limited novelty and methodological/experimental rigor by today’s top-tier standards (incremental quantization idea, heuristic thresholds/STE-style gradients, and relatively narrow/dated empirical validation without strong ablations or modern baselines)."
      },
      "token": {
        "prompt_tokens": 4334,
        "completion_tokens": 62,
        "total_tokens": 4396
      },
      "time": "2026-02-09T21:11:57.161500+00:00"
    }
  ],
  "article": [
    {
      "heading": "1 INTRODUCTION",
      "text": "Deep neural networks are becoming the preferred approach for many machine learning applications. However, as networks get deeper, deploying a network with a large number of parameters on a small device becomes increasingly difficult. Much work has been done to reduce the size of networks. Halfprecision networks (Amodei et al., 2015) cut sizes of neural networks in half. XNOR-Net (Rastegari et al., 2016), DoReFa-Net (Zhou et al., 2016) and network binarization (Courbariaux et al.; 2015; Lin et al., 2015) use aggressively quantized weights, activations and gradients to further reduce computation during training. While weight binarization benefits from 32 smaller model size, the extreme compression rate comes with a loss of accuracy. Hubara et al. (2016) and Li & Liu (2016) propose ternary weight networks to trade off between model size and accuracy. In this paper, we propose Trained Ternary Quantization which uses two full-precision scaling coefficients W pl , W n l for each layer l, and quantize the weights to Wnl , 0, +W p l instead of traditional -1, 0, +1 or -E, 0, +E where E is the mean of the absolute weight value, which is not learned. Our positive and negative weights have different absolute values W pl and W n l that are trainable parameters. We also maintain latent full-precision weights at training time, and discard them at test time. We back propagate the gradient to both W pl , W n l and to the latent full-precision weights. This makes it possible to adjust the ternary assignment (i.e. which of the three values a weight is assigned). Our quantization method, achieves higher accuracy on the CIFAR-10 and ImageNet datasets. For AlexNet on ImageNet dataset, our method outperforms previously state-of-art ternary network(Li & Work done while at Stanford CVA lab. Liu, 2016) by 3.0% of Top-1 accuracy and the full-precision model by 1.6%. By converting most of the parameters to 2-bit values, we also compress the network by about 16x. Moreover, the advantage of few multiplications still remains, because W pl and W n l are fixed for each layer during inference. On custom hardware, multiplications can be pre-computed on activations, so only two multiplications per activation are required.",
      "exclude": true
    },
    {
      "heading": "2 MOTIVATIONS",
      "text": "The potential of deep neural networks, once deployed to mobile devices, has the advantage of lower latency, no reliance on the network, and better user privacy. However, energy efficiency becomes the bottleneck for deploying deep neural networks on mobile devices because mobile devices are battery constrained. Current deep neural network models consist of hundreds of millions of parameters. Reducing the size of a DNN model makes the deployment on edge devices easier. First, a smaller model means less overhead when exporting models to clients. Take autonomous driving for example; Tesla periodically copies new models from their servers to customers cars. Smaller models require less communication in such over-the-air updates, making frequent updates more feasible. Another example is on Apple Store; apps above 100 MB will not download until you connect to Wi-Fi. Its infeasible to put a large DNN model in an app. The second issue is energy consumption. Deep learning is energy consuming, which is problematic for battery-constrained mobile devices. As a result, iOS 10 requires iPhone to be plugged with charger while performing photo analysis. Fetching DNN models from memory takes more than two orders of magnitude more energy than arithmetic operations. Smaller neural networks require less memory bandwidth to fetch the model, saving the energy and extending battery life. The third issue is area cost. When deploying DNNs on Application-Specific Integrated Circuits (ASICs), a sufficiently small model can be stored directly on-chip, and smaller models enable a smaller ASIC die. Several previous works aimed to improve energy and spatial efficiency of deep networks. One common strategy proven useful is to quantize 32-bit weights to one or two bits, which greatly reduces model size and saves memory reference. However, experimental results show that compressed weights usually come with degraded performance, which is a great loss for some performancesensitive applications. The contradiction between compression and performance motivates us to work on trained ternary quantization, minimizing performance degradation of deep neural networks while saving as much energy and space as possible.",
      "exclude": false
    },
    {
      "heading": "3 RELATED WORK",
      "text": "",
      "exclude": true
    },
    {
      "heading": "3.1 BINARY NEURAL NETWORK (BNN)",
      "text": "Lin et al. (2015) proposed binary and ternary connections to compress neural networks and speed up computation during inference. They used similar probabilistic methods to convert 32-bit weights into binary values or ternary values, defined as: wb Bernoulli( w + 1 2 ) 2 1 wt Bernoulli(|w|) sign(w) (1) Here wb and wt denote binary and ternary weights after quantization. w denotes the latent full precision weight. During back-propagation, as the above quantization equations are not differentiable, derivatives of expectations of the Bernoulli distribution are computed instead, yielding the identity function: L w = L wb = L wt (2) Here L is the loss to optimize. For BNN with binary connections, only quantized binary values are needed for inference. Therefore a 32 smaller model can be deployed into applications.",
      "exclude": false
    },
    {
      "heading": "3.2 DOREFA-NET",
      "text": "Zhou et al. (2016) proposed DoReFa-Net which quantizes weights, activations and gradients of neural networks using different widths of bits. Therefore with specifically designed low-bit multiplication algorithm or hardware, both training and inference stages can be accelerated. They also introduced a much simpler method to quantize 32-bit weights to binary values, defined as: wb = E(|w|) sign(w) (3) Here E(|w|) calculates the mean of absolute values of full precision weights w as layer-wise scaling factors. During back-propagation, Equation 2 still applies.",
      "exclude": false
    },
    {
      "heading": "3.3 TERNARY WEIGHT NETWORKS",
      "text": "Li & Liu (2016) proposed TWN (Ternary weight networks), which reduce accuracy loss of binary networks by introducing zero as a third quantized value. They use two symmetric thresholds l and a scaling factor Wl for each layer l to quantize weighs into Wl, 0,+Wl: wtl = Wl : wl > l 0 : |wl| l Wl : wl (|wl(i)|) (5) And again Equation 2 is used to calculate gradients. While an additional bit is required for ternary weights, TWN achieves a validation accuracy that is very close to full precision networks according to their paper.",
      "exclude": false
    },
    {
      "heading": "3.4 DEEP COMPRESSION",
      "text": "Han et al. (2015) proposed deep compression to prune away trivial connections and reduce precision of weights. Unlike above models using zero or symmetric thresholds to quantize high precision weights, Deep Compression used clusters to categorize weights into groups. In Deep Compression, low precision weights are fine-tuned from a pre-trained full precision network, and the assignment of each weight is established at the beginning and stay unchanged, while representative value of each cluster is updated throughout fine-tuning.",
      "exclude": false
    },
    {
      "heading": "4 METHOD",
      "text": "Our method is illustrated in Figure 1. First, we normalize the full-precision weights to the range [-1, +1] by dividing each weight by the maximum weight. Next, we quantize the intermediate full-resolution weights to -1, 0, +1 by thresholding. The threshold factor t is a hyper-parameter that is the same across all the layers in order to reduce the search space. Finally, we perform trained quantization by back propagating two gradients, as shown in the dashed lines in Figure 1. We back-propagate gradient1 to the full-resolution weights and gradient2 to the scaling coefficients. The former enables learning the ternary assignments, and the latter enables learning the ternary values. At inference time, we throw away the full-resolution weights and only use ternary weights.",
      "exclude": false
    },
    {
      "heading": "4.1 LEARNING BOTH TERNARY VALUES AND TERNARY ASSIGNMENTS",
      "text": "During gradient descent we learn both the quantized ternary weights (the codebook), and choose which of these values is assigned to each weight (choosing the codebook index). To learn the ternary value (codebook), we introduce two quantization factors W pl and W n l for positive and negative weights in each layer l. During feed-forward, quantized ternary weights wtl are calculated as: wtl = W pl : wl > l 0 : |wl| l Wnl : wl l and Inl = i|(i)wl l 1 L wtl : |wl| l Wnl L wtl : wl < l (8) Note we use scalar number 1 as factor of gradients of zero weights. The overall quantization process is illustrated as Figure 1. The evolution of the ternary weights from different layers during training is shown in Figure 2. We observe that as training proceeds, different layers behave differently: for the first quantized conv layer, the absolute values of W pl and W n l get smaller and sparsity gets lower, while for the last conv layer and fully connected layer, the absolute values of W pl and W n l get larger and sparsity gets higher. We learn the ternary assignments (index to the codebook) by updating the latent full-resolution weights during training. This may cause the assignments to change between iterations. Note that the thresholds are not constants as the maximal absolute values change over time. Once an updated weight crosses the threshold, the ternary assignment is changed. The benefits of using trained quantization factors are: i) The asymmetry of W pl 6= Wnl enables neural networks to have more model capacity. ii) Quantized weights play the role of \"learning rate multipliers\" during back propagation.",
      "exclude": false
    },
    {
      "heading": "4.2 QUANTIZATION HEURISTIC",
      "text": "In previous work on ternary weight networks, Li & Liu (2016) proposed Ternary Weight Networks (TWN) using l as thresholds to reduce 32-bit weights to ternary values, where l is defined as Equation 5. They optimized value of l by minimizing expectation of L2 distance between full precision weights and ternary weights. Instead of using a strictly optimized threshold, we adopt different heuristics: 1) use the maximum absolute value of the weights as a reference to the layers threshold and maintain a constant factor t for all layers: l = tmax(|w|) (9) and 2) maintain a constant sparsity r for all layers throughout training. By adjusting the hyperparameter r we are able to obtain ternary weight networks with various sparsities. We use the first method and set t to 0.05 in experiments on CIFAR-10 and ImageNet dataset and use the second one to explore a wider range of sparsities in section 5.1.1. We perform our experiments on CIFAR-10 (Krizhevsky & Hinton, 2009) and ImageNet (Russakovsky et al., 2015). Our network is implemented on both TensorFlow (Abadi & et. al o, 2015) and Caffe (Jia et al., 2014) frameworks.",
      "exclude": false
    },
    {
      "heading": "4.3 CIFAR-10",
      "text": "",
      "exclude": false
    },
    {
      "heading": "5 EXPERIMENTS",
      "text": "CIFAR-10 is an image classification benchmark containing images of size 3232RGB pixels in a training set of 50000 and a test set of 10000. ResNet (He et al., 2015) structure is used for our experiments. We use parameters pre-trained from a full precision ResNet to initialize our model. Learning rate is set to 0.1 at beginning and scaled by 0.1 at epoch 80, 120 and 300. A L2-normalized weight decay 177 0.08179999887943270.100699998438358 0.089199997484684 178 0.08139999955892560.128600001335144 0.0901999995112419 179 0.08060000091791150.110799998044968 0.086499996483326 Full precision Binary weight (DoReFa-Net) Ternary weight (Ours) 5 of 0.0002 is used as regularizer. Most of our models converge after 160 epochs. We take a moving average on errors of all epochs to filter off fluctuations when reporting error rate. We compare our model with the full-precision model and a binary-weight model. We train a a full precision ResNet (He et al., 2016) on CIFAR-10 as the baseline (blue line in Figure 3). We fine-tune the trained baseline network as a 1-32-32 DoReFa-Net where weights are 1 bit and both activations and gradients are 32 bits giving a significant loss of accuracy (green line) . Finally, we fine-tuning the baseline with trained ternary weights (red line). Our model has substantial accuracy improvement over the binary weight model, and our loss of accuracy over the full precision model is small. We also compare our model to Tenary Weight Network (TWN) on ResNet-20. Result shows our model improves the accuracy by 0.25% on CIFAR-10. We expand our experiments to ternarize ResNet with 32, 44 and 56 layers. All ternary models are fine-tuned from full precision models. Our results show that we improve the accuracy of ResNet-32, ResNet-44 and ResNet-56 by 0.04%, 0.16% and 0.36% . The deeper the model, the larger the improvement. We conjecture that this is due to ternary weights providing the right model capacity and preventing overfitting for deeper networks.",
      "exclude": false
    },
    {
      "heading": "5.1 IMAGENET",
      "text": "We further train and evaluate our model on ILSVRC12(Russakovsky et al. (2015)). ILSVRC12 is a 1000-category dataset with over 1.2 million images in training set and 50 thousand images in validation set. Images from ILSVRC12 also have various resolutions. We used a variant of AlexNet(Krizhevsky et al. (2012)) structure by removing dropout layers and add batch normalization(Ioffe & Szegedy, 2015) for all models in our experiments. The same variant is also used in experiments described in the paper of DoReFa-Net. Our ternary model of AlexNet uses full precision weights for the first convolution layer and the last fully-connected layer. Other layer parameters are all quantized to ternary values. We train our model on ImageNet from scratch using an Adam optimizer (Kingma & Ba (2014)). Minibatch size is set to 128. Learning rate starts at 104 and is scaled by 0.2 at epoch 56 and 64. A L2-normalized weight decay of 5 106 is used as a regularizer. Images are first resized to 256 256 then randomly cropped to 224 224 before input. We report both top 1 and top 5 error rate on validation set. We compare our model to a full precision baseline, 1-32-32 DoReFa-Net and TWN. After around 64 epochs, validation error of our model dropped significantly compared to other low-bit networks as well as the full precision baseline. Finally our model reaches top 1 error rate of 42.5%, while DoReFa-Net gets 46.1% and TWN gets 45.5%. Furthermore, our model still outperforms full precision AlexNet (the batch normalization version, 44.1% according to paper of DoReFa-Net) by 1.6%, and is even better than the best AlexNet results reported (42.8%1). The complete results are listed in Table 2. 1https://github.com/BVLC/caffe/wiki/Models-accuracy-on-ImageNet-2012-val 1 We draw the process of training in Figure 4, the baseline results of AlexNet are marked with dashed lines. Our ternary model effectively reduces the gap between training and validation performance, which appears to be quite great for DoReFa-Net and TWN. This indicates that adopting trainable W pl and Wnl helps prevent models from overfitting to the training set. We also report the results of our methods on ResNet-18B in Table 3. The full-precision error rates are obtained from Facebooks implementation. Here we cite Binarized Weight Network(BWN)Rastegari et al. (2016) results with all layers quantized and TWN finetuned based on a full precision network, while we train our TTQ model from scratch. Compared with BWN and TWN, our method obtains a substantial improvement.",
      "exclude": false
    },
    {
      "heading": "6 DISCUSSION",
      "text": "In this section we analyze performance of our model with regard to weight compression and inference speeding up. These two goals are achieved through reducing bit precision and introducing sparsity. We also visualize convolution kernels in quantized convolution layers to find that basic patterns of edge/corner detectors are also well learned from scratch even precision is low.",
      "exclude": true
    },
    {
      "heading": "6.1 SPATIAL AND ENERGY EFFICIENCY",
      "text": "We save storage for models by 16 by using ternary weights. Although switching from a binaryweight network to a ternary-weight network increases bits per weight, it brings sparsity to the weights, which gives potential to skip the computation on zero weights and achieve higher energy efficiency.",
      "exclude": false
    },
    {
      "heading": "6.1.1 TRADE-OFF BETWEEN SPARSITY AND ACCURACY",
      "text": "Figure 5 shows the relationship between sparsity and accuracy. As the sparsity of weights grows from 0 (a pure binary-weight network) to 0.5 (a ternary network with 50% zeros), both the training and validation error decrease. Increasing sparsity beyond 50% reduces the model capacity too far, increasing error. Minimum error occurs with sparsity between 30% and 50%. We introduce only one hyper-parameter to reduce search space. This hyper-parameter can be either sparsity, or the threshold t w.r.t the max value in Equation 6. We find that using threshold produces better results. This is because fixing the threshold allows the sparsity of each layer to vary (Figure reffig:weights). Published as a conference paper at ICLR 2017 Table 1 Table 2 w/o pruning 10% 20% 30% 40% 50% 60% 70% 80% 90% 100% Validation Error 0.105744999647141 0.09665999934077260.09309500008821490.0913449995219708 0.09231499992311 0.091499999538064 0.09421999976038930.099015000090003 0.113474999368191 0.150045001879334 Train Error 0.03142703464254740.008692236384376880.007409938820637760.007549929246306420.007867254689335820.009407590329647060.0125876291189343 0.0196611762978137 0.03617928531020880.0824047848582268",
      "exclude": false
    },
    {
      "heading": "6.1.2 SPARSITY AND EFFICIENCY OF ALEXNET",
      "text": "We further analyze parameters from our AlexNet model. We calculate layer-wise density (complement of sparsity) as shown in Table 4. Despite we use different W pl and W n l for each layer, ternary weights can be pre-computed when fetched from memory, thus multiplications during convolution and inner product process are still saved. Compared to Deep Compression, we accelerate inference speed using ternary values and more importantly, we reduce energy consumption of inference by saving memory references and multiplications, while achieving higher accuracy. We notice that without all quantized layers sharing the same t for Equation 9, our model achieves considerable sparsity in convolution layers where the majority of computations takes place. Therefore we are able to squeeze forward time to less than 30% of full precision networks. As for spatial compression, by substituting 32-bit weights with 2-bit ternary weights, our model is approximately 16 smaller than original 32-bit AlexNet.",
      "exclude": false
    },
    {
      "heading": "6.2 KERNEL VISUALIZATION",
      "text": "We visualize quantized convolution kernels in Figure 6. The left matrix is kernels from the second convolution layer (5 5) and the right one is from the third (3 3). We pick first 10 input channels and first 10 output channels to display for each layer. Grey, black and white color represent zero, negative and positive weights respectively. We observe similar filter patterns as full precision AlexNet. Edge and corner detectors of various directions can be found among listed kernels. While these patterns are important for convolution neural networks, the precision of each weight is not. Ternary value filters are capable enough extracting key features after a full precision first convolution layer while saving unnecessary storage. Furthermore, we find that there are a number of empty filters (all zeros) or filters with single non-zero value in convolution layers. More aggressive pruning can be applied to prune away these redundant kernels to further compress and speed up our model. Conv2 Conv3",
      "exclude": false
    },
    {
      "heading": "7 CONCLUSION",
      "text": "We introduce a novel neural network quantization method that compresses network weights to ternary values. We introduce two trained scaling coefficients W lp and W l n for each layer and train these coefficients using back-propagation. During training, the gradients are back-propagated both to the latent full-resolution weights and to the scaling coefficients. We use layer-wise thresholds that are proportional to the maximum absolute values to quantize the weights. When deploying the ternary network, only the ternary weights and scaling coefficients are needed, which reducing parameter size by at least 16. Experiments show that our model reaches or even surpasses the accuracy of full precision models on both CIFAR-10 and ImageNet dataset. On ImageNet we exceed the accuracy of prior ternary networks (TWN) by 3%. 9",
      "exclude": true
    }
  ],
  "fewShot": [
    {
      "model": "gpt-5.2",
      "decision": {
        "rejection": false,
        "confidence": 0.74,
        "primary_reason": "Strong, practically impactful quantization method that learns ternary assignments and per-layer scaling factors end-to-end, with convincing ImageNet/CIFAR results and clear comparisons to prior binary/ternary baselines; novelty is moderate but the empirical gains and deployability make it above the bar."
      },
      "token": {
        "prompt_tokens": 6968,
        "completion_tokens": 84,
        "total_tokens": 7052
      },
      "time": "2026-02-09T20:12:16.776067+00:00"
    },
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": false,
        "confidence": 0.78,
        "primary_reason": "Proposes Trained Ternary Quantization (TTQ) with learnable ternary values and assignments, demonstrating strong empirical results (16× compression, accuracy improvements on CIFAR-10/ImageNet over full-precision and prior ternary methods), clear methodology with asymmetric quantization factors, and practical efficiency gains; solid contribution to neural network compression despite incremental nature relative to prior quantization work."
      },
      "token": {
        "prompt_tokens": 7745,
        "completion_tokens": 127,
        "total_tokens": 7872
      },
      "time": "2026-02-11T18:30:15.668021+00:00"
    }
  ],
  "test": false
}