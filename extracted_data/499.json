{
  "id": "499",
  "title": "HyperNetworks",
  "abstract": "This work explores hypernetworks: an approach of using one network, also known as a hypernetwork, to generate the weights for another network.  We apply hypernetworks to generate adaptive weights for recurrent networks. In this case, hypernetworks can be viewed as a relaxed form of weight-sharing across layers. In our implementation, hypernetworks are are trained jointly with the main network in an end-to-end fashion.  Our main result is that hypernetworks can generate non-shared weights for LSTM and achieve state-of-the-art results on a variety of sequence modelling tasks including character-level language modelling, handwriting generation and neural machine translation, challenging the weight-sharing paradigm for recurrent networks.",
  "accepted": true,
  "zeroShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": false,
        "confidence": 0.92,
        "primary_reason": "Novel architecture with strong empirical results across multiple sequence modeling tasks (language modeling, handwriting generation, NMT). Well-motivated approach that challenges weight-sharing paradigm in RNNs. Comprehensive experiments with proper baselines and ablations. Methodologically sound with clear presentation of memory-efficient implementation."
      },
      "token": {
        "prompt_tokens": 5326,
        "completion_tokens": 93,
        "total_tokens": 5419
      },
      "time": "2026-02-05T22:54:03.180221+00:00"
    }
  ],
  "article": [
    {
      "heading": "1 INTRODUCTION",
      "text": "In this work, we consider an approach of using a small network (called a hypernetwork\") to generate the weights for a larger network (called a main network). The behavior of the main network is the same as with any usual neural network: it learns to map some raw inputs to their desired targets; whereas the hypernetwork takes a set of inputs that contain information about the structure of the weights and generates the weights for that layer. The focus of this work is to use hypernetworks to generate weights for recurrent networks (RNN). In this case, the weights Wt for the main RNN at step t is a function of the input to the hidden state of the main RNN at the previous step ht1 and the input at the current time step xt. This weight-generation scheme allows approximate weight-sharing across layers of the main RNN. We perform experiments to investigate the behaviors of hypernetworks in a range of contexts and find that hypernetworks mix well with other techniques such as batch normalization and layer normalization. Our main result is that hypernetworks can generate non-shared weights for LSTM that work better than the standard version of LSTM (Hochreiter & Schmidhuber, 1997). On language modelling tasks with character Penn Treebank, Hutter Prize Wikipedia datasets, hypernetworks for LSTM achieve near state-of-the-art results. On a handwriting generation task with IAM handwriting dataset, hypernetworks for LSTM achieves good quantitative and qualitative results. On machine translation, hypernetworks for LSTM also obtain state-of-the-art performance on the WMT14 enfr benchmark.",
      "exclude": true
    },
    {
      "heading": "2 RELATED WORK",
      "text": "Our approach is inspired by methods in evolutionary computing, where it is difficult to directly operate in large search spaces consisting of millions of weight parameters. A more efficient method is to evolve a smaller network to generate the structure of weights for a larger network, so that the search is constrained within the much smaller weight space. An instance of this approach is the work on the HyperNEAT framework (Stanley et al., 2009). In the HyperNEAT framework, Compositional Pattern-Producing Networks (CPPNs) are evolved to define the weight structure of the much larger main network. Closely related to our approach is a simplified variation of HyperNEAT, where the structure is fixed and the weights are evolved through Discrete Cosine Transform (DCT), called Compressed Weight Search (Koutnik et al., 2010). Even more closely related to our Work done as a member of the Google Brain Residency program (g.co/brainresidency). approach are Differentiable Pattern Producing Networks (DPPNs), where the structure is evolved but the weights are learned (Fernando et al., 2016), and ACDC-Networks (Moczulski et al., 2015), where linear layers are compressed with DCT and the parameters are learned. Most reported results using these methods, however, are in small scales, perhaps because they are both slow to train and require heuristics to be efficient. The main difference between our approach and HyperNEAT is that hypernetworks in our approach are trained end-to-end with gradient descent together with the main network, and therefore are more efficient. Another closely related idea to hypernetworks is the concept of fast weights Schmidhuber (1992; 1993) in which one network can produce context-dependent weight changes for a second network. Small scale experiments were conducted to demonstrate fast weights for feed forward networks at the time, but perhaps due to the lack of modern computational tools, the recurrent network version was mentioned mainly as a thought experiment (Schmidhuber, 1993). A subsequent work demonstrated practical applications of fast weights (Gomez & Schmidhuber, 2005), where a generator network is learnt through evolution to solve an artificial control problem. The focus of this work is to apply our method to recurrent networks. In this context, our method has a connection to second-order or multiplicative networks (Goudreau et al., 1994; Sutskever et al., 2011; Wu et al., 2016), where the hidden state of the last step and the input vector of the current time step interact in a multiplicative fashion. The key difference between our approach and second-order networks is that our approach is more memory efficient because we only learn the scaling factors in the interaction matrix. Furthermore, in second-order or multiplicative networks, the weights of the RNN are not fixed, but a linear function of the previous hidden state. In our work, we explore the use of a smaller RNN, rather than a linear function, to produce the weights of the main RNN. The concept of a network interacting with another network is central to the work of (Jaderberg et al., 2016; Andrychowicz et al., 2016), and especially (Denil et al., 2013; Yang et al., 2015; Bertinetto et al., 2016; De Brabandere et al., 2016), where certain parameters in a convolutional network are predicted by another network. These studies however did not explore the use of this approach to recurrent networks, which is a main contribution of our work.",
      "exclude": true
    },
    {
      "heading": "3 METHODS",
      "text": "Though it is possible to use hypernetworks to generate weights for feedforward or convolutional networks, in this paper, our focus is on using hypernetworks with recurrent networks. As can be seen below, when they are applied to recurrent networks, hypernetworks can be seen as a form of relaxed weight-sharing in the time dimension.",
      "exclude": false
    },
    {
      "heading": "3.1 HYPERRNN",
      "text": "Our hypernetworks can be used to generate weights for the RNN and LSTM. When a hypernetwork is used to generate the weights for an RNN, we refer to it as the HyperRNN. At every time step t, a HyperRNN takes as input the concatenated vector of input xt and the hidden states of the main RNN ht1, it then generates as output the vector ht. This output vector is then used to generate the weights for the main RNN at the same timestep. Both the HyperRNN and the main RNN are trained jointly with backpropagation and gradient descent. In the following, we will give a more formal description of the model. The standard formulation of a Basic RNN is given by: ht = (Whht1 +Wxxt + b) (1) where ht is the hidden state, is a non-linear operation such as tanh or relu, and the weight matrices and bias Wh RNhNh ,Wx RNhNx , b RNh is fixed each timestep for an input sequence X = (x1, x2, . . . , xT ). In HyperRNN, we allow Wh and Wx to float over time by using a smaller hypernetwork to generate these parameters of the main RNN at each step (see Figure 1). More concretely, the parameters Wh,Wx, b of the main RNN are different at different time steps, so that ht can now be computed as: ht = ( Wh(zh)ht1 +Wx(zx)xt + b(zb) ) , where Wh(zh) = Whz, zh Wx(zx) = Wxz, zx b(zb) =Wbzzb + b0 (2) Where Whz RNhNhNz ,Wxz RNhNxNz ,Wbz RNhNz , b0 RNh and zh, zx, zz RNz . We use a recurrent hypernetwork to compute zh, zx and zb as a function of xt and ht1: xt = ( ht1 xt ) ht = (Whht1 +Wxxt + b) zh =Whhht1 + bhh zx =Whxht1 + bhx zb =Whbht1 (3) Where Wh R NhNh ,Wx RNh(Nh+Nz), b RNh , and Whh,Whx,Whb R NzNh and bhh, bhx R Nz . This HyperRNN cell has Nh hidden units. Typically Nh is much smaller than Nh. As the embeddings zh, zx and zb are of dimensions Nz , which is typically smaller than the hidden state size Nh of the HyperRNN cell, a linear network is used to project the output of the HyperRNN cell into the embeddings in Equation 3. After the embeddings are computed, they will be used to generate the full weight matrix of the main RNN. The above is a general formulation of HyperRNN. However, Equation 2 is not practical because the memory usage becomes too large for real problems. We modify the HyperRNN described in Equation 2 so that it can be more memory efficient. We will use an intermediate hidden vector d(z) RNh to parametrize each weight matrix, where d(z) will be a linear function of z. To dynamically modify a weight matrix W , we will allow each row of this weight matrix to be scaled linearly by an element in vector d. We refer d as a weight scaling vector. Below is the modification to W (z): W (z) =W ( d(z) ) = d0(z)W0d1(z)W1... dNh(z)WNh (4) While we sacrifice the ability to construct an entire weight matrix from a linear combination of Nz matrices of the same size, we are able to linearly scale the rows of a single matrix withNz degrees of freedom. We find this change to have a good trade-off, as this formulation of converting W (z) into W (d(z)) decreases the amount of memory required by the HyperRNN. Rather than requiring Nz times the memory of a Basic RNN, we will only be using memory in the order Nz times the number of hidden units, which is an acceptable amount of extra memory usage that is often available in many applications. In addition, the row-level operation in Equation 4 can be shown to be equivalent to an element-wise multiplication operator and hence computationally much more efficient in practice. Below is the more memory efficient version of the setup of Equation 2: ht = ( dh(zh) Whht1 + dx(zx) Wxxt + b(zb) ) , where dh(zh) =Whzzh dx(zx) =Wxzzx b(zb) =Wbzzb + b0 (5) In our experiments, we focus on the use of hypernetworks with the Long Short-Term Memory (LSTM) architecture (Hochreiter & Schmidhuber, 1997) because LSTM often works better than the Basic RNN. In such case, an LSTM will have more weight matrices and biases, and thus our main change is to have many more ds, each d is being associated with each weight matrix or bias.",
      "exclude": false
    },
    {
      "heading": "3.2 RELATED APPROACHES",
      "text": "The formulation of the HyperRNN in Equation 5 has similarities to Recurrent Batch Normalization (Cooijmans et al., 2016) and Layer Normalization (Ba et al., 2016). The central idea for the normalization techniques is to calculate the first two statistical moments of the inputs to the activation function, and to linearly scale the inputs to have zero mean and unit variance. After the normalization, an additional set of fixed parameters are learned to unscale the inputs if required. Since the HyperRNN cell can indirectly modify the rows of each weight matrix and also the bias of the main RNN, it is implicitly also performing a linear scaling to the inputs of the activation function. The difference here is that the linear scaling parameters will be learned by the HyperRNN cell, and not based on statistical-moments. We note that the existing normalization approaches can work together with the HyperRNN approach, where the HyperRNN cell will be tasked with discovering a better dynamical scaling policy to complement normalization. We also explore this combination in our experiments. The element-wise operation also has similarities to the Multiplicative RNN and its extensions (mRNN, mLSTM) (Sutskever et al., 2011; Krause et al., 2016) and Multiplicative Integration RNN (MI-RNN) (Wu et al., 2016). In the case of the mRNN, the hidden-to-hidden weight matrix is replaced with a factorized matrix, to allow the weights to be input dependent. The factorization is described below in Equation 6 (Krause et al., 2016). ht = (Whm(Wmxxt) (Wmhht1) +Wxxt + b) (6) For the MI-RNN approach, a second order term is added to the Basic RNN formulation, along with scaling vectors for each term, as described in Equation 7. The addition of the scaling vectors allow parameters to be shared more efficiently. ht = ( Wxxt Whht1 + 1 Whht1 + 2 Wxxt + b) (7) In the HyperRNN approach, the weights are also input dependent. However, unlike mRNN, both weight matrices and also the bias term will be dependent to not only to the inputs, but also to the hidden states. In the MI-RNN approach, the weights are also be augmented by both the input and hidden states, via the second order term in Equation 7. In both mRNN and MI-RNN approaches, the weight augmentation terms are produced by a linear operation, while in the HyperRNN approach, the weight scaling vectors d are dynamically produced by another RNN with its own hidden states and non-linearities.",
      "exclude": false
    },
    {
      "heading": "4 EXPERIMENTS",
      "text": "In the following experiments, we will benchmark the performance of HyperLSTM on language modelling with Penn Treebank, and Hutter Prize Wikipedia. We will also benchmark the method on the tasks of handwriting generation with IAM On-Line Handwriting Database, and machine translation with WMT14 enfr.",
      "exclude": false
    },
    {
      "heading": "4.1 CHARACTER-LEVEL PENN TREEBANK LANGUAGE MODELLING",
      "text": "We first evaluation the HyperLSTM model on a character level prediction task with the Penn Treebank corpus (Marcus et al., 1993) using the train/validation/test split outlined in (Mikolov et al., 2012). As the dataset is quite small, we apply dropout on both input and output layers with a keep probability of 90%. Unlike previous approaches (Graves, 2013; Ognawala & Bayer, 2014) of applying weight noise during training, we instead also apply dropout to the recurrent layer (Henaff et al., 2016) with the same dropout probability. We compare our model to the basic LSTM cell, stacked LSTM cells (Graves, 2013), and LSTM with layer normalization applied. In addition, we also experimented with applying layer normalization to HyperLSTM. Using the setup in (Graves, 2013), we use networks with 1000 units and train the network to predict the next character. In this task, the HyperLSTM cell has 128 units and an embedding size of 4. As the HyperLSTM cell has more trainable parameters compared to the basic LSTM cell, we also experimented with an LSTM cell with 1250 units. For character-level Penn Treebank, we use mini-batches of size 128, to train on sequences of length 100. We train the model using Adam (Kingma & Ba, 2015) with a learning rate of 0.001 and gradient clipping of 1.0. During evaluation, we generate the entire sequence, and do not use information about previous test errors for prediction, e.g., dynamic evaluation (Graves, 2013; Rocki, 2016b). As mentioned earlier, we apply dropout to the input and output layers, and also apply recurrent dropout with a keep probability of 90%. For baseline models, orthogonal initialization (Henaff et al., 2016) is used for all weights. We also experiment with a version of the model using a larger embedding size of 16, and also with a lower dropout keep probability of 85%, and report results with this Large Embedding\" model in Table 1. Lastly, we stack two layers of this Large Embedding\" model together to measure the benefits of a multi-layer version of HyperLSTM, with a dropout keep probability of 80%. Our results are presented in Table 1. The key observation here is that 1) HyperLSTM outperforms standard LSTM and 2) HyperLSTM also achieves similar improvements compared to Layer Normalization. The combination of Layer Normalization and Hyper LSTM achieves the best test perplexity so far on this dataset.",
      "exclude": false
    },
    {
      "heading": "4.2 HUTTER PRIZE WIKIPEDIA LANGUAGE MODELLING",
      "text": "We train our model on the larger and more challenging Hutter Prize Wikipedia dataset, also known as enwik8 (Hutter, 2012) consisting of a sequence of 100M characters composed of 205 unique characters. Unlike Penn Treebank, enwik8 contains some foreign words (Latin, Arabic, Chinese), indented XML, metadata, and internet addresses, making it a more realistic and practical dataset to test character language models. Our setup is similar in the previous experiment, using the same mini-batch size, learning rate, weight initialization, gradient clipping parameters and optimizer. We do not use dropout for the input and output layers, but still apply recurrent dropout with a keep probability of 90%. Similar to (Chung et al., 2015), we train on the first 90M characters of the dataset, use the next 5M as a validation set for early stopping, and the last 5M characters as the test set. As enwik8 is a bigger dataset compared to Penn Treebank, we will use 1800 units for our networks. We also perform training on sequences of length 250. Our normal HyperLSTM cell consists of 256 units, and we use an embedding size of 64. To improve results, we also experiment with a larger model where both HyperLSTM and main network both have 2048 hidden units. The HyperLSTM cell consists of 512 units with an embedding size of 64. We also apply recurrent dropout to this larger model, with dropout keep probability of 85%, and train on a longer sequence length of 300. The results are summarized in Table 2. As can be seen from the table, HyperLSTM is once again competitive to Layer Norm LSTM, and if we combine both techniques, the Layer Norm HyperLSTM achieves respectable results. The large version of HyperLSTM with normalization that uses 2048 hidden units achieve near state-of-the-art performance for this task. In addition, HyperLSTM converges more quickly compared to LSTM and Layer Norm LSTM (see Figure 2). We perform additional analysis to understand the behavior of HyperLSTM by visualizing how the weight scaling vectors of the main LSTM change during the character sampling process. In Figure 3, we examine a sample text passage generated by HyperLSTM after training on enwik8 along with the weight differences below the text. We see that in regions of low intensity, where the weights of the main LSTM are relatively static, the types of phrases generated seem more deterministic. For example, the weights do not change much during the words Europeans, possessions and reservation. The regions of high intensity is when the HyperLSTM cell is making relatively large changes to the weights of the main LSTM. 1We do not compare against methods that use dynamic evaluation. 2Our implementation. 3Based on results of version 2 at the time of writing. http://arxiv.org/abs/1609.01704v2 4This method uses information about test errors during inference for predicting the next characters, hence it is not directly comparable to other methods that do not use this information. In 1955-37 most American and Europeans signed into the sea. An absence of [[Japan (Korea city)|Japan]], the Mayotte like Constantino ple (in its first week, in [[880]]) that served as the mother of emperors, as the Corinthians, Bernard on his continued sequel toget her ordered [[Operation Moabili]]. The Gallup churches in the army promulgated the possessions sitting at the reservation, and [[Mel ito de la Vegeta Provine|Felix]] had broken Diocletian desperate from the full victory of Augustus, cited by Stephen I. Alexander Se nate became Princess Cartara, an annual ruler of war (777-184) and founded numerous extremiti of justice practitioners. Figure 3: Example text generated from HyperLSTM model. We visualize how four of the main RNNs weight matrices (W ih, W g h , W f h , W o h ) effectively change over time by plotting the norm of the changes below each generated character. High intensity represent large changes being made to weights of main RNN.",
      "exclude": false
    },
    {
      "heading": "4.3 HANDWRITING SEQUENCE GENERATION",
      "text": "In addition to modelling discrete sequential data, we want to see how the model performs when modelling sequences of real valued data. We will train our model on the IAM online handwriting database (Liwicki & Bunke, 2005) and have our model predict pen strokes as per Section 4.2 of (Graves, 2013). The dataset has contains 12179 handwritten lines from 221 writers, digitally recorded from a tablet. We will model the (x, y) coordinate of the pen location at each recorded time step, along with a binary indicator of pen-up/pen-down. The average sequence length is around 700 steps and the longest around 1900 steps, making the training task particularly challenging as the network needs to retain information about both the stroke history and also the handwriting style in order to predict plausible future handwriting strokes. We will use the same model architecture described in (Graves, 2013) and use a Mixture Density Network layer (Bishop, 1994) to generate a mixture of bi-variate Gaussian distributions to model at each time step to model the pen location. We normalize the data and use the same train/validation split as per (Graves, 2013) in this experiment. We remove samples less than length 300 as we found these samples contain a lot of recording errors and noise. After the pre-processing, as the dataset is small, we introduce data augmentation of chosen uniformly from +/- 10% and apply a this random scaling a the samples used for training. For model training, will apply recurrent dropout and also dropout to the output layer with a keep probability of 0.95. The model is trained on mini-batches of size 32 containing sequences of variable length. We trained the model using Adam (Kingma & Ba, 2015) with a learning rate of 0.0001 and gradient clipping of 5.0. Our HyperLSTM cell consists of 128 units and a signal size of 4. For baseline models, orthogonal initialization (Henaff et al., 2016) is performed for all weights. 1Our implementation, to replicate setup of (Graves, 2013). 2Our implementation, with data augmentation, dropout and recurrent dropout. The results are summarized in Table 3. Our main result is that HyperLSTM with 900 units, without Layer Norm, achieves best log loss on the validation set across all models in published work and in our experiment. HyperLSTM also converges more quickly compared to other models (see Figure 2). Similar to the earlier character generation experiment, we show a generated handwriting sample from the HyperLSTM model in Figure 4, along with a plot of how the weight scaling vectors of the main RNN is changing over time below the sample. For a more detailed interactive demonstration of handwriting generation using HyperLSTM, visit http://blog.otoro.net/2016/09/28/ hyper-networks/. We observe that the regions of high intensity is concentrated at many discrete instances, rather than slowly varying over time. This implies that the weights experience regime changes rather than gradual slow adjustments. We can see that many of these weight changes occur at the boundaries between words, and between characters. While the LSTM model alone already does a decent job of generating time-varying parameters of a Mixture Gaussian distribution used to generate realistic handwriting samples, the ability to go one level deeper, and to dynamically generate the generative model is one of the key advantages of HyperLSTM over a normal LSTM.",
      "exclude": false
    },
    {
      "heading": "4.4 NEURAL MACHINE TRANSLATION",
      "text": "Finally, we experiment with the Neural Machine Translation task using the same experimental setup outlined in (Wu et al., 2016). Our model is the same wordpiece model architecture with a vocabulary size of 32k, but we replace the LSTM cells with HyperLSTM cells. We benchmark both models on WMT14 EnFr using the same test/validation set split described in the GNMT paper (Wu et al., 2016). The GNMT network has 8 layers in the encoder, 8 layers in the decoder. The first layer of the encoder has bidirectional connections. The attention module is a neural network with 1 hidden layer. When a LSTM cell is used, the number of hidden units in each layer is 1024. The model is trained in a distributed setting with a parameter sever and 12 workers. Additionally, each worker uses 8 GPUs and a minibatch of 128. Our experimental setup is similar to that in the GNMT paper (Wu et al., 2016), with two simplifications. First, we use only Adam without SGD at the end. Adam was used with the same same hyperparameters described in the GNMT paper: learning rate of 0.0002 for 1M training steps. We apply the HyperLSTM cell with Layer Norm to the GNMT architecture that uses a vocabulary of 32K wordpieces. We keep the same number of hidden units, which means that our model will have 16% more parameters. The results are reported in Table 4, which shows that the HyperLSTM cell improves the performance of the existing GNMT model, achieving state-of-the-art single model results for this dataset. In addition, we demonstrate the applicability of hypernetworks to large-scale models used in production systems.",
      "exclude": false
    },
    {
      "heading": "5 CONCLUSION",
      "text": "In this paper, we presented a method to use one network to generate weights for another neural network. Our hypernetworks are trained end-to-end with backpropagation and therefore are efficient and scalable. We focused on applying hypernetworks to generate weights for recurrent networks. On language modelling and handwriting generation, hypernetworks are competitive to or sometimes better than state-of-the-art models. On machine translation, hypernetworks achieve a significant gain on top of a state-of-the-art production-level model.",
      "exclude": true
    },
    {
      "heading": "ACKNOWLEDGMENTS",
      "text": "We thank Jeff Dean, Geoffrey Hinton, Mike Schuster and the Google Brain team for their help with the project.",
      "exclude": true
    },
    {
      "heading": "A APPENDIX",
      "text": "A.1 EXAMPLES OF GENERATED WIKIPEDIA TEXT A.2 EXAMPLES OF RANDOMLY CHOSEN GENERATED HANDWRITING SAMPLES A.3 EXAMPLES OF RANDOMLY CHOSEN MACHINE TRANSLATION SAMPLES We randomly selected translation samples generated from both LSTM baseline and HyperLSTM models from the WMT14 EnFr Test Set. Given an English phrase, we can compare between the correct French translation, the LSTM translation, and the HyperLSTM translation. English Input I was expecting to see gnashing of teeth and a fight breaking out at the gate . French (Ground Truth) Je m attendais a voir des grincements de dents et une bagarre eclater a la porte . LSTM Translation Je m attendais a voir des larmes de dents et un combat a la porte . HyperLSTM Translation Je m attendais a voir des dents grincer des dents et une bataille eclater a la porte . English Input Prosecuting , Anne Whyte said : \" If anyone should know not to the break the law , it is a criminal solicitor . \" French (Ground Truth) Le procureur Anne Whyte a declare : Si quelqu un doit savoir qu il ne faut pas violer la loi , c est bien un avocat penaliste . LSTM Translation Prosecuting , Anne Whyte a dit : Si quelqu un doit savoir qu il ne faut pas enfreindre la loi , c est un solicitor criminel . HyperLSTM Translation En poursuivant , Anne Whyte a dit : Si quelqu un doit savoir ne pas enfreindre la loi , c est un avocat criminel . English Input According to her , the CSRS was invited to a mediation and she asked for an additional period for consideration . French (Ground Truth) Selon elle , la CSRS a ete invitee a une mediation et elle a demande un delai supplementaire pour y reflechir . LSTM Translation Selon elle , le SCRS a ete invite a une mediation et elle a demande un delai supplementaire . HyperLSTM Translation Selon elle , le SCRS a ete invite a une mediation et elle a demande une periode de reflexion supplementaire . English Input Relations between the US and Germany have come under strain following claims that the NSA bugged Chancellor Angela s Merkel s phone . French (Ground Truth) Les relations entre les Etats-Unis et l Allemagne ont ete mises a rude epreuve a la suite de plaintes selon lesquelles la NSA avait mis sur ecoute le telephone portable de la chanceliere allemande Angela Merkel . LSTM Translation Les relations entre les Etats-Unis et l Allemagne ont ete mises a rude epreuve suite aux affirmations selon lesquelles la NSA aurait pris le telephone de Merkel de la chanceliere Angela . HyperLSTM Translation Les relations entre les Etats-Unis et l Allemagne ont ete mises a rude epreuve apres que la NSA a attaque le telephone de la chanceliere Angela Angela . English Input Germany s BfV advises executives to consider using simple prepaid mobiles when on foreign trips because of the risk that smart phones are compromised . French (Ground Truth) Le BfV d Allemagne conseille a ses dirigeants d envisager d utiliser de simples telephones portables prepayes lors de leurs voyages a l etranger en raison du risque d atteinte a l integrite des smartphones . LSTM Translation Le BfV allemand conseille aux dirigeants d envisager l utilisation de mobiles prepayes simples lors de voyages a l etranger en raison du risque de compromission des telephones intelligents . HyperLSTM Translation Le BfV allemand conseille aux dirigeants d envisager l utilisation de telephones mobiles prepayes simples lors de voyages a l etranger en raison du risque que les telephones intelligents soient compromis . English Input I was on the mid-evening news that same evening , and on TV the following day as well . French (Ground Truth) Le soir-meme , je suis au 20h , le lendemain aussi je suis a la tele . LSTM Translation J etais au milieu de l actualite le soir meme , et a la television le lendemain egalement . HyperLSTM Translation J etais au milieu de la soiree ce soir-la et a la television le lendemain .",
      "exclude": true
    }
  ],
  "fewShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": false,
        "confidence": 0.92,
        "primary_reason": "Novel architectural contribution with strong empirical validation across diverse tasks (language modeling, handwriting generation, machine translation). Clear methodological innovation in dynamic weight generation via hypernetworks, comprehensive experiments with state-of-the-art results, and good analysis of learned behaviors."
      },
      "token": {
        "prompt_tokens": 5488,
        "completion_tokens": 90,
        "total_tokens": 5578
      },
      "time": "2026-02-08T22:23:10.728090+00:00"
    }
  ],
  "test": false
}