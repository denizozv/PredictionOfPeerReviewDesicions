{
  "id": "549",
  "title": "Energy-Based Spherical Sparse Coding",
  "abstract": "In this paper, we explore an efficient variant of convolutional sparse coding with unit norm code vectors and reconstructions are evaluated using an inner product (cosine distance). To use these codes for discriminative classification, we describe a model we term Energy-Based Spherical Sparse Coding (EB-SSC) in which the hypothesized class label introduces a learned linear bias into the coding step. We evaluate and visualize performance of stacking this encoder to make a deep layered model for image classification.",
  "accepted": false,
  "zeroShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": true,
        "confidence": 0.72,
        "primary_reason": "Limited experimental validation (single dataset CIFAR-10), modest improvements over baselines (~1-2%), and unclear practical advantages over standard CNNs. The theoretical contribution of spherical sparse coding is interesting but the empirical evidence for its superiority is weak. Missing comparisons with other sparse coding methods and modern architectures."
      },
      "token": {
        "prompt_tokens": 5551,
        "completion_tokens": 95,
        "total_tokens": 5646
      },
      "time": "2026-02-05T22:58:12.286790+00:00"
    },
    {
      "model": "gpt-5.2",
      "decision": {
        "rejection": true,
        "confidence": 0.78,
        "primary_reason": "Insufficient experimental evidence and limited novelty: results only on CIFAR-10 with modest gains over strong CNN baselines, and the core method largely repackages known components (shrinkage/rectification, normalization, unrolled inference/energy-based conditioning) without compelling new theory or broad validation."
      },
      "token": {
        "prompt_tokens": 4902,
        "completion_tokens": 79,
        "total_tokens": 4981
      },
      "time": "2026-02-09T21:28:08.560534+00:00"
    }
  ],
  "article": [
    {
      "heading": "1 INTRODUCTION",
      "text": "Sparse coding has been widely studied as a representation for images, audio and other vectorial data. This has been a highly successful method that has found its way into many applications, from signal compression and denoising (Donoho, 2006; Elad & Aharon, 2006) to image classification (Wright et al., 2009), to modeling neuronal receptive fields in visual cortex (Olshausen & Field, 1997). Since its introduction, subsequent works have brought sparse coding into the supervised learning setting by introducing classification loss terms to the original formulation to encourage features that are not only able to reconstruct the original signal but are also discriminative (Jiang et al., 2011; Yang et al., 2010; Zeiler et al., 2010; Ji et al., 2011; Zhou et al., 2012; Zhang et al., 2013). While supervised sparse coding methods have been shown to find more discriminative features leading to improved classification performance over their unsupervised counterparts, they have received much less attention in recent years and have been eclipsed by simpler feed-forward architectures. This is in part because sparse coding is computationally expensive. Convex formulations of sparse coding typically consist of a minimization problem over an objective that includes a least-squares (LSQ) reconstruction error term plus a sparsity inducing regularizer. Because there is no closed-form solution to this formulation, various iterative optimization techniques are generally used to find a solution (Zeiler et al., 2010; Bristow et al., 2013; Yang et al., 2013; Heide et al., 2015). In applications where an approximate solution suffices, there is work that learns non-linear predictors to estimate sparse codes rather than solve the objective more directly (Gregor & LeCun, 2010). The computational overhead for iterative schemes becomes quite significant when training discriminative models due to the demand of processing many training examples necessary for good performance, and so sparse coding has fallen out of favor by not being able to keep up with simpler non-iterative coding methods. In this paper we introduce an alternate formulation of sparse coding using unit length codes and a reconstruction loss based on the cosine similarity. Optimal sparse codes in this model can be computed in a non-iterative fashion and the coding objective lends itself naturally to embedding in a discriminative, energy-based classifier which we term energy-based spherical sparse coding (EBSSC). This bi-directional coding method incorporates both top-down and bottom-up information where the features representation depends on both a hypothesized class label and the input signal. Like Cao et al. (2015), our motivation for bi-directional coding comes from the Biased Competition Theory, which suggests that visual processing can be biased by other mental processes (e.g., topdown influence) to prioritize certain features that are most relevant to current task. Fig. 1 illustrates the flow of computation used by our SSC and EB-SSC building blocks compared to a standard feed-forward layer. Our energy based approach for combining top-down and bottom-up information is closely tied to the ideas of Larochelle & Bengio (2008); Ji et al. (2011); Zhang et al. (2013); Li & Guo (2014) although the model details are substantially different (e.g., Ji et al. (2011) and Zhang et al. (2013) use sigmoid non-linearities while Li & Guo (2014) use separate representations for top-down and bottom-up information). The energy function of Larochelle & Bengio (2008) is also similar but includes an extra classification term and is trained as a restricted Boltzmann machine.",
      "exclude": true
    },
    {
      "heading": "1.1 NOTATION",
      "text": "Matrices are denoted as uppercase bold (e.g., A), vectors are lowercase bold (e.g., a), and scalars are lowercase (e.g., a). We denote the transpose operator with T, the element-wise multiplication operator with , the convolution operator with , and the cross-correlation operator with ?. For vectors where we dropped the subscript k (e.g., d and z), we refer to a super vector with K components stacked together (e.g., z = [zT1 , . . . , z T K ] T).",
      "exclude": false
    },
    {
      "heading": "2 ENERGY-BASED SPHERICAL SPARSE CODING",
      "text": "Energy-based models capture dependencies between variables using an energy function that measure the compatibility of the configuration of variables (LeCun et al., 2006). To measure the compatibility between the top-down and bottom-up information, we define the energy function of EB-SSC to be the sum of bottom-up coding term and a top-down classification term: E(x, y, z) = Ecode(x, z) + Eclass(y, z). (1) The bottom-up information (input signal x) and the top-down information (class label y) are tied together by a latent feature map z.",
      "exclude": false
    },
    {
      "heading": "2.1 BOTTOM-UP RECONSTRUCTION",
      "text": "To measure the compatibility between the input signal x and the latent feature maps z, we introduce a novel variant of sparse coding that is amenable to efficient feed-forward optimization. While the idea behind this variant can be applied to either patch-based or convolutional sparse coding, we specifically use the convolutional variant that shares the burden of coding an image among nearby overlapping dictionary elements. Using such a shift-invariant approach avoids the need to learn dictionary elements which are simply translated copies of each other, freeing up resources to discover more diverse and specific filters (see Kavukcuoglu et al. (2010)). Convolutional sparse coding (CSC) attempts to find a set of dictionary elements d1, . . . ,dK and corresponding sparse codes z1, . . . , zK so that the resulting reconstruction, r = K k=1 dk zk accurately represents the input signal x. This is traditionally framed as a least-squares minimization with a sparsity inducing prior on z: arg min z x K k=1 dk zk22 + z1. (2) Unlike standard feed-forward CNN models that convolve the input signal x with the filters, this energy function corresponds to a generative model where the latent feature maps z1, . . . , zK are convolved with the filters and compared to the input signal (Bristow et al., 2013; Heide et al., 2015; Zeiler et al., 2010). To motivate our novel variant of CSC, consider expanding the squared reconstruction error x r22 = x22 2xTr + r22. If we constrain the reconstruction r to have unit norm, the reconstruction error depends entirely on the inner product between x and r and is equivalent to the cosine similarity (up to additive and multiplicative constants). This suggests the closely related unit-length reconstruction problem: arg max z xT ( K k=1 dk zk ) z1 (3) s.t. K k=1 dk zk 2 1 In Appendix A we show that, given an optimal unit length reconstruction r with corresponding codes z, the solution to the least squares reconstruction problem (Eq. 2) can be computed by a simple scaling r = (xTr 2 z 1)r. The unit-length reconstruction problem is no easier than the original least-squares optimization due to the constraint on the reconstruction which couples the codes for different filters. Instead consider a simplified constraint on z which we refer to as spherical sparse coding (SSC): arg max z21 Ecode(x, z) = arg max z21 xT ( K k=1 dk zk ) z1. (4) In 2.3 below, we show that the solution to this problem can be found very efficiently without requiring iterative optimization. This problem is a relaxation of convolutional sparse coding since it ignores non-orthogonal interactions between the dictionary elements1. Alternately, assuming unit norm dictionary elements, the code norm constraint can be used to upper-bound the reconstruction length. We have by the triangle and Youngs inequality that: k dk zk 2 k dk zk2 k dk1zk1 D k zk2 (5) where the factor D is the dimension of zk and arises from switching from the 1-norm to the 2-norm. Since D k zk2 1 is a tighter constraint we have max k dkzk21 Ecode(x, z) max k zk2 1 D Ecode(x, z) (6) However, this relaxation is very loose, primarily due to the triangle inequality. Except in special cases (e.g., if the dictionary elements have disjoint spectra) the SSC codes will be quite different from the standard least-squares reconstruction. 1We note that our formulation is also closely related to the dynamical model suggested by Rozell et al. (2008), but without the dictionary-dependent lateral inhibition between feature maps. Lateral inhibition can solve the unit-length reconstruction formulation of standard sparse coding but requires iterative optimization.",
      "exclude": false
    },
    {
      "heading": "2.2 TOP-DOWN CLASSIFICATION",
      "text": "To measure the compatibility between the class label y and the latent feature maps z, we use a set of one-vs-all linear classifiers. To provide more flexibility, we generalize this by splitting the code vector into positive and negative components: zk = z + k + z k z + k 0 z k 0 and allow the linear classifier to operate on each component separately. We express the classifier score for a hypothesized class label y by: Eclass(y, z) = K k=1 w+Ty z + k + K k=1 wTy z k . (7) The classifier thus is parameterized by a pair of weight vectors (w+yk and w yk) for each class label y and k-th channel of the latent feature map. This splitting, sometimes referred to as full-wave rectification, is useful since a dictionary element and its negative do not necessarily have opposite visual semantics. This splitting also allows the classifier the flexibility to assign distinct meanings or alternately be completely invariant to contrast reversal depending on the problem domain. For example, Shang et al. (2016) found CNN models with ReLU non-linearities which discard the negative activations tend to learn pairs of filters which are related by negation. Keeping both positive and negative responses allowed them to halve the number of dictionary elements. We note that it is also straightforward to introduce spatial average pooling prior to classification by introducing a fixed linear operator P used to pool the codes (e.g., w+Ty Pz + k ). This is motivated by a variety of hand-engineered feature extractors and sparse coding models, such as Ren & Ramanan (2013), which use spatially pooled histograms of sparse codes for classification. This fixed pooling can be viewed as a form of regularization on the linear classifier which enforces shared weights over spatial blocks of the latent feature map. Splitting is also quite important to prevent information loss when performing additive pooling since positive and negative components of zk can cancel each other out.",
      "exclude": false
    },
    {
      "heading": "2.3 CODING",
      "text": "Bottom-up reconstruction and top-down classification each provide half of the story, coupled by the latent feature maps. For a given input x and hypothesized class y, we would like to find the optimal activations z that maximize the joint energy function E(x, y, z). This requires solving the following optimization: arg max z21 xT ( K k=1 dk zk ) z1 + K k=1 w+Tyk z + k + K k=1 wTyk z k , (8) where x RD is an image and y Y is a class hypothesis. zk RF is the k-th component latent variable being inferred; z+k and z k are the positive and negative coefficients of zk, such that zk = z + k + z k . The parameters dk RM , w + yk RF , and w yk RF are the dictionary filter, positive coefficient classifier, and negative coefficient classifier for the k-th component respectively. A key aspect of our formulation is that the optimal codes can be found very efficiently in closedformin a feed-forward manner (see Appendix B for a detailed argument).",
      "exclude": false
    },
    {
      "heading": "2.3.1 ASYMMETRIC SHRINKAGE",
      "text": "To describe the coding processes, let us first define a generalized version of the shrinkage function commonly used in sparse coding. Our asymmetric shrinkage is parameterized by upper and lower thresholds + shrink(+,)(v) = v + if v + > 0 0 otherwise v + if v + < 0 (9) Fig. 2 shows a visualization of this function which generalizes the standard shrinkage proximal operator by allowing for the positive and negative thresholds. In particular, it corresponds to the proximal operator for a version of the `1-norm that penalizes the positive and negative components with different weights |v|asym = +v+1 +v1. The standard shrink operator corresponds to shrink(,)(v) while the rectified linear unit common in CNNs is given by a limiting case shrink(0,)(v). We note that + is required for shrink(+,) to be a proper function (see Fig. 2).",
      "exclude": false
    },
    {
      "heading": "2.3.2 FEED-FORWARD CODING",
      "text": "We now describe how codes can be computed in a simple feed-forward pass. Let +yk = w + yk, yk = w yk (10) be vectors of positive and negative biases whose entries are associated with a spatial location in the feature map k for class y. The optimal code z can be computed in three sequential steps: 1. Cross-correlate the data with the filterbank dk ? x 2. Apply an asymmetric version of the standard shrinkage operator zk = shrink(+yk, yk) (dk ? x) (11) where, with abuse of notation, we allow the shrinkage function (Eq. 9) to apply entries in the vectors of threshold parameter pairs +yk, yk to the corresponding elements of the argument. 3. Project onto the feasible set of unit length codes z = z z2 . (12)",
      "exclude": false
    },
    {
      "heading": "2.3.3 RELATIONSHIP TO CNNS:",
      "text": "We note that this formulation of coding has a close connection to single layer convolutional neural network (CNN). A typical CNN layer consists of convolution with a filterbank followed by a nonlinear activation such as a rectified linear unit (ReLU). ReLUs can be viewed as another way of inducing sparsity, but rather than coring the values around zero like the shrink function, ReLU truncates negative values. On the other hand, the asymmetric shrink function can be viewed as the sum of two ReLUs applied to appropriately biased inputs: shrink(+,)(x) = ReLU(x +) ReLU((x+ )), SSC coding can thus be seen as a CNN in which the ReLU activation has been replaced with shrinkage followed by a global normalization.",
      "exclude": false
    },
    {
      "heading": "3 LEARNING",
      "text": "We formulate supervised learning using the softmax log-loss that maximizes the energy for the true class label yi while minimizing energy of incorrect labels y. arg min d,w+,w,0 2 (w+22 + w22 + d22) + 1 N N i=1 [ max z21 E(xi, yi, z) + log yY max z21 eE(xi,y,z)] s.t. ( wyk) ( w + yk) y, k , (13) where is the hyperparameter regularizing w+y , w y , and d. We constrain the relationship between and the entries of w+y and w y in order for the asymmetric shrinkage to be a proper function (see Sec. 2.3.1 and Appendix B for details). In classical sparse coding, it is typical to constrain the `2-norm of each dictionary filter to unit length. Our spherical coding objective behaves similarly. For any optimal code z, there is a 1-dimensional subspace of parameters for which z is optimal given by scaling d inversely to w, . For simplicity of the implementation, we opt to regularize d to assure a unique solution. However, as Tygert et al. (2015) point out, it may be advantageous from the perspective of optimization to explicitly constrain the norm of the filter bank. Note that unlike classical sparse coding, where is a hyperparameter that is usually set using crossvalidation, we treat it as a parameter of the model that is learned to maximize performance.",
      "exclude": false
    },
    {
      "heading": "3.1 OPTIMIZATION",
      "text": "In order to solve Eq. 13, we explicitly formulate our model as a directed-acyclic-graph (DAG) neural network with shared weights, where the forward-pass computes the sparse code vectors and the backward-pass updates the parameter weights. We optimize the objective using stochastic gradient descent (SGD). As mentioned in Sec. 2.3 shrinkage function is assymetric with parameters +yk or yk as defined in Eq. 10. However, the inequality constraint on their relationship to keep the shrinkage function a proper function is difficult to enforce when optimizing with SGD. Instead, we introduce a central offset parameter and reduce the ordering constraint to pair of positivity constraints. Let w+yk = + yk bk w yk = yk + bk (14) be the modified linear classifiers relative to the central offset bk. It is straightforward to see that if +yk and yk that satisfy the constrain in Eq. 13, then adding the same value to both sides of the inequality will not change that. However, taking bk to be a midpoint between them, then both +yk bk and yk + bk will be strictly non-negative. Using this variable substitution, we rewrite the energy function (Eq. 1) as E(x, y, z) = xT ( K k=1 dk zk ) + K k=1 bk1 Tzk K k=1 w+Tyk z + k + K k=1 wTyk z k . (15) where b is constant offset for each code channel. The modified linear classification terms now take on a dual role of inducing sparsity and measuring the compatibility between z and y. This yields a modified learning objective that can easily be solved with existing implementations for learning convolutional neural nets: arg min d,w+,w,b 2 (w+22 + w22 + d22) + 1 N N i=1 [ max z21 E(xi, yi, z) + log yY max z21 eE (xi,y,z)] s.t. w+yk, w yk 0 y, k , (16) where w+ and w are the new sparsity inducing classifiers, and b are the arbitrary origin points. In particular, adding the K origin points allows us to enforce the constraint by simply projecting w+ and w onto the positive orthant during SGD.",
      "exclude": false
    },
    {
      "heading": "3.1.1 STACKING BLOCKS",
      "text": "We also examine stacking multiple blocks of our energy function in order to build a hierarchical representation. As mentioned in Sec. 3.1.1, the optimal codes can be computed in a simple feedforward passthis applies to shallow versions of our model. When stacking multiple blocks of our energy-based model, solving for the optimal codes cannot be done in a feed-forward pass since the codes for different blocks are coupled (bilinearly) in the joint objective. Instead, we can proceed in an iterative manner, performing block-coordinate descent by repeatedly passing up and down the hierarchy updating the codes. In this section we investigate the trade-off between the number of passes used to find the optimal codes for the stacked model and classification performance. For this purpose, we train multiple instances of a 2-block version of our energy-based model that differ in the number of iterations used when solving for the codes. For recurrent networks such as this, inference is commonly implemented by unrolling the network, where the parts of the network structure are repeated with parameters shared across these repeated parts to mimic an iterative algorithm that stops at a fixed number of iterations rather than at some convergence criteria. In Fig. 3, we compare the performance between models that were unrolled zero to four times. We see that there is a difference in performance based on how many sweeps of the variables are made. In terms of the training objective, more unrolling produces models that have lower objective values with convergence after only a few passes. In terms of testing error, however, we see that full code inference is not necessarily better, as unrolling once or twice has lower errors than unrolling three or four times. The biggest difference was between not unrolling and unrolling once, where both the training objective and testing error goes down. The testing error decreases from 0.0131 to 0.0074. While there is a clear benefit in terms of performance for unrolling at least once, there is also a trade-off between performance and computational resource, especially for deeper models.",
      "exclude": false
    },
    {
      "heading": "4 EXPERIMENTS",
      "text": "We evaluate the benefits of combining top-down and bottom-up information to produce classspecific features on the CIFAR-10 (Krizhevsky & Hinton, 2009) dataset using a deep version of our EB-SSC. All experiments were performed using MatConvNet (Vedaldi & Lenc, 2015) framework with the ADAM optimizer (Kingma & Ba, 2014). The data was preprocessed and augmented following the procedure in Goodfellow et al. (2013). Specifically, the data was made zero mean and whitened, augmented with horizontal flips (with a 0.5 probability) and random cropping. No weight decay was used, but we used a dropout rate of 0.3 before every convolution layer except for the first. For these experiments we consider a single forward pass (no unrolling).",
      "exclude": false
    },
    {
      "heading": "4.1 CLASSIFICATION",
      "text": "We compare our proposed EB-SSC model to that of Springenberg et al. (2015), which uses rectified linear units (ReLU) as its non-linearity. This model can be viewed as a basic feed-forward version of our proposed model which we take as a baseline. We also consider variants of the baseline model that utilize a subset of architectural features of our proposed model (e.g., concatenated rectified linear units (CReLU) and spherical normalization (SN)) to understand how subtle design changes of the network architecture affects performance. We describe the model architecture in terms of the feature extractor and classifier. Table 1 shows the overall network architecture of feature extractors, which consist of seven convolution blocks and two pooling layers. We test two possible classifiers: a simple linear classifier (LC) and our energy-based classifier (EBC), and use softmax-loss for all models. For linear classifiers, a numerical subscript indicates which of the seven conv blocks of the feature extractor is used for classification (e.g., LC7 indicates the activations out of the last conv block is fed into the linear classifier). For energy-based classifiers, a numerical subscript indicates which conv blocks of the feature extractor are replace with a energy-based classifier (e.g., EBC67 indicates the activations out of conv5 is fed into the energy-based classifier and the energy-based classifier has a similar architecture to the conv blocks it replaces). The notation differ because for energy-based classifiers, the optimal activations are a function of the hypothesized class label, whereas for linear classifiers, they are not. The results shown in Table 2 compare our proposed model to the baselines ReLU+LC7 (Springenberg et al., 2015) and CReLU+LC7 (Shang et al., 2016), and to intermediate variants. The baseline models all perform very similarly with some small reductions in error rates over the baseline CReLU+LC7. However, CReLU+LC7 reduces the error rate over ReLU+LC7 by more than one percent (from 11.40% to 10.17%), which confirms the claims by Shang et al. (2016) and demonstrates the benefits of splitting positive and negative activations. Likewise, we see further decrease in the error rate (to 9.74%) from using spherical normalization. Though normalizing the activations doesnt add any capacity to the model, this improved performance is likely because scale-invariant activations makes training easier. On the other hand, further sparsifying the activations yielded no benefit. We tested values = 0.001, 0.01 and found 0.001 to perform better. Replacing the linear classifier with our energy-based classifier further decreases the error rate by another half percent (to 9.23%).",
      "exclude": false
    },
    {
      "heading": "4.2 DECODING CLASS-SPECIFIC CODES",
      "text": "A unique aspect of our model is that it is generative in the sense that each layer is explicitly trying to encode the activation pattern in the prior layer. Similar to the work on deconvolutional networks built on least-squares sparse coding (Zeiler et al., 2010), we can synthesize input images from activations in our spherical coding network by performing repeated deconvolutions (transposed convolutions) back through the network. Since our model is energy based, we can further examine how the topdown information of a hypothesized class effects the intermediate activations. The first column in Fig. 4 visualizes reconstructions of a given input image based on activations from different layers of the model by convolution transpose. In this case we put in zeros for class biases (i.e., no top-down) and are able to recover high fidelity reconstructions of the input. In the remaining columns, we use the same deconvolution pass to construct input space representations of the learned classifier biases. At low levels of the feature hierarchy, these biases are spatially smooth since the receptive fields are small and there is little spatial invariance capture in the activations. At higher levels these class-conditional bias fields become more tightly localized. Finally, in Fig. 5 we shows decodings from the conv2 and conv5 layer of the EB-SSC model for a given input under different class hypotheses. Here we subtract out the contribution of the top-down bias term in order to isolate the effect of the class conditioning on the encoding of input features. As visible in the figure, the modulation of the activations focused around particular regions of the image and the differences across class hypotheses becomes more pronounced at higher layers of the network.",
      "exclude": false
    },
    {
      "heading": "5 CONCLUSION",
      "text": "We presented an energy-based sparse coding method that efficiently combines cosine similarity, convolutional sparse coding, and linear classification. Our model shows a clear mathematical connection between the activation functions used in CNNs to introduce sparsity and our cosine similarity convolutional sparse coding formulation. Our proposed model outperforms the baseline model and we show which attributes of our model contributes most to the increase in performance. We also demonstrate that our proposed model provides an interesting framework to probe the effects of class-specific coding.",
      "exclude": true
    },
    {
      "heading": "APPENDIX A",
      "text": "Here we show that spherical sparse coding (SSC) with a norm constraint on the reconstruction is equivalent to standard convolutional sparse coding (CSC). Expanding the least squares reconstruction error and dropping the constant term x2 gives the CSC problem: max z 2xT ( K k=1 dk zk ) K k=1 dk zk22 K k=1 zk1. Let = K k=1 dk zk2 be the norm of the reconstruction for some code z and let u be the reconstruction scaled to have unit norm so that: u = K k=1 dk zk K k=1 dk zk2 = K k=1 dk zk with z = 1 z We rewrite the least-squares objective in terms of these new variables: max z, >0 g(z, ) = max z, >0 2xT ( u ) u22 z1 = max z, >0 2 ( xTu 2 z1 ) 2 Taking the derivative of g w.r.t. yields the optimal scaling as a function of z: (z) = xTu 2 z1. Plugging (z) back into g yields: max z, >0 g(z, ) = max z,u2=1 ( xTu 2 z1 )2 . Discarding solutions with < 0 can be achieved by simply dropping the square which results in the final constrained problem: arg max z xT ( K k=1 dk zk ) 2 K k=1 zk1 s.t. K k=1 dk zk2 1.",
      "exclude": true
    },
    {
      "heading": "APPENDIX B",
      "text": "We show in this section that coding in the EB-SSC model can be solved efficiently by a combination of convolution, shrinkage and projection, steps which can be implemented with standard libraries on a GPU. For convenience, we first rewrite the objective in terms of cross-correlation rather than convolution (i.e., , xT(dk zk) = (dk ? x)Tzk). For ease of understanding, we first consider the coding problem when there is no classification term. z = arg max z221 vTz z1, where v = [(d1 ? x)T, . . . , (dK ? x)T]T. Pulling the constraint into the objective, we get its Lagrangian function: L(z, ) = vTz z1 + ( 1 z22 ) . From the partial subderivative of the Lagrangian w.r.t. zi we derive the optimal solution as a function of ; and from that find the conditions in which the solutions hold, giving us: zi() = 1 2 vi vi > 0 otherwise vi + vi < . (17) This can also be compactly written as: z() = 1 2 z, (18) z = s2 v s where s = sign(z) 1, 0, 1|z| and s2 = s s 0, 1|z|. The sign vector of z can be determined without knowing , as is a Lagrangian multiplier for an inequality it must be nonnegative and therefore does not change the sign of the optimal solution. Lastly, we define the squared `2-norm of z, a result that will be used later: z22 = zT(s2 v) zTs = zTv z1. (19) Substituting z() back into the Lagrangian we get: L(z(), ) = 1 2 vTz 2 z1 + ( 1 1 42 z22 ) , and the derivative w.r.t. is: L(z() = 1 22 vTz + 22 z1 + 1 + 1 42 z22. Setting the derivative equal to zero and using the result from Eq. 19, we can find the optimal solution to : 2 = 1 2 zTv 2 z1 1 4 z22 = 1 2 z22 1 4 z22 = = 1 2 z2. Finally, plugging into Eq. 18 we find the optimal solution z = z z2 . (20)",
      "exclude": true
    }
  ],
  "fewShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": true,
        "confidence": 0.72,
        "primary_reason": "Limited novelty and experimental scope. The core contribution—spherical sparse coding with class-conditional biases—is a relatively incremental modification of existing sparse coding and energy-based models. Experiments are restricted to CIFAR-10 with modest improvements (9.23% vs 10.17% baseline). The closed-form coding solution is elegant but not sufficiently novel for a top venue. Stacking analysis is preliminary, and comparisons lack depth against modern deep learning baselines. The generative visualization is interesting but insufficient to overcome limited methodological novelty and narrow experimental validation."
      },
      "token": {
        "prompt_tokens": 5713,
        "completion_tokens": 158,
        "total_tokens": 5871
      },
      "time": "2026-02-08T22:28:09.244609+00:00"
    },
    {
      "model": "gpt-5.2",
      "decision": {
        "rejection": true,
        "confidence": 0.72,
        "primary_reason": "Interesting energy-based reinterpretation of CNN blocks (asymmetric shrinkage + spherical normalization + class-conditional bias during inference), but the core technical novelty is modest and closely overlaps with known components (ReLU/CReLU, normalization, unrolled inference/energy-based classification). Empirical validation is limited (mainly CIFAR-10, small gains ~0.5% over strong architectural baselines, little evidence of broader impact or necessity of the energy-based formulation), and the stacked/inference story is not convincingly developed beyond shallow/unrolled variants."
      },
      "token": {
        "prompt_tokens": 7536,
        "completion_tokens": 137,
        "total_tokens": 7673
      },
      "time": "2026-02-09T20:29:56.982902+00:00"
    }
  ],
  "test": false
}