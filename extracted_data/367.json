{
  "id": "367",
  "title": "Optimal Binary Autoencoding with Pairwise Correlations",
  "abstract": "We formulate learning of a binary autoencoder as a biconvex optimization problem which learns from the pairwise correlations between encoded and decoded bits. Among all possible algorithms that use this information, ours finds the autoencoder that reconstructs its inputs with worst-case optimal loss. The optimal decoder is a single layer of artificial neurons, emerging entirely from the minimax loss minimization, and with weights learned by convex optimization. All this is reflected in competitive experimental results, demonstrating that binary autoencoding can be done efficiently by conveying information in pairwise correlations in an optimal fashion.",
  "accepted": true,
  "zeroShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": true,
        "confidence": 0.72,
        "primary_reason": "Limited experimental validation and narrow scope. While the theoretical framework is novel with minimax optimal guarantees for binary autoencoders using pairwise correlations, the experimental section is weak: (1) only compared against basic single-layer AE and PCA baselines, not modern methods; (2) limited to small binary datasets; (3) the approach is restricted to binary data and single-layer decoders, severely limiting practical applicability; (4) no comparison with VAEs or other contemporary methods; (5) the claim of 'competitive results' is overstated given the limited baselines. The theoretical contributions, while interesting, don't sufficiently compensate for the narrow experimental scope and practical limitations for a top-tier venue."
      },
      "token": {
        "prompt_tokens": 11399,
        "completion_tokens": 183,
        "total_tokens": 11582
      },
      "time": "2026-02-05T22:38:17.279281+00:00"
    }
  ],
  "article": [
    {
      "heading": "1 INTRODUCTION",
      "text": "Consider a general autoencoding scenario, in which an algorithm learns a compression scheme for independently, identically distributed (i.i.d.) V -dimensional bit vector data x(1), . . . , x(n) . For some encoding dimension H , the algorithm encodes each data example x(i) = (x(i)1 , . . . , x (i) V ) > into an H-dimensional representation e(i), with H < V . It then decodes each e(i) back into a reconstructed example x(i) using some small amount of additional memory, and is evaluated on the quality of the reconstruction by the cross-entropy loss commonly used to compare bit vectors. A good autoencoder learns to compress the data into H bits so as to reconstruct it with low loss. When the loss is squared reconstruction error and the goal is to compress data in RV to RH , this is often accomplished with principal component analysis (PCA), which projects the input data on the top H eigenvectors of their covariance matrix (Bourlard & Kamp (1988); Baldi & Hornik (1989)). These eigenvectors in RV constitute V H real values of additional memory needed to decode the compressed data in RH back to the reconstructions in RV , which are linear combinations of the eigenvectors. Crucially, this total additional memory does not depend on the amount of data n, making it applicable when data are abundant. This paper considers a similar problem, except using bit-vector data and the cross-entropy reconstruction loss. Since we are compressing samples of i.i.d. V -bit data into H-bit encodings, a natural approach is to remember the pairwise statistics: the V H average correlations between pairs of bits in the encoding and decoding, constituting as much additional memory as the eigenvectors used in PCA. The decoder uses these along with the H-bit encoded data, to produce V -bit reconstructions. We show how to efficiently learn the autoencoder with the worst-case optimal loss in this scenario, without any further assumptions, parametric or otherwise. It has some striking properties. The decoding function is identical in form to the one used in a standard binary autoencoder with one hidden layer (Bengio et al. (2013a)) and cross-entropy reconstruction loss. Specifically, each bit v of the decoding is the output of a logistic sigmoid artificial neuron of the encoded bits, with some learned weights wv RH . This form emerges as the uniquely optimal decoding function, and is not assumed as part of any explicit model. We show that the worst-case optimal reconstruction loss suffered by the autoencoder is convex in these decoding weights W = wvv[V ], and in the encoded representations E. Though it is not Most of the work was done as a PhD student at UC San Diego. jointly convex in both, the situation still admits a natural and efficient optimization algorithm in which the loss is alternately minimized in E and W while the other is held fixed. The algorithm is practical and performs well empirically, learning incrementally from minibatches of data in a stochastic optimization setting.",
      "exclude": true
    },
    {
      "heading": "1.1 NOTATION",
      "text": "The observed data and encodings can be written in matrix form, representing bits as 1: X = x (1) 1 x (n) 1 ... . . . ... x (1) V x (n) V [1, 1]Vn , E = e (1) 1 e (n) 1 ... . . . ... e (1) H e (n) H [1, 1]Hn (1) Here the encodings are allowed to be randomized, represented by values in [1, 1] instead of just the two values 1, 1; e.g. e(1)i = 12 is +1 w.p. 3 4 and 1 w.p. 1 4 . The data in X are also allowed to be randomized, which we will see essentially loses no generality (Appendix B). We write the columns of X,E as x(i), e(i) for i [n] (where [s] := 1, . . . , s), representing the data. The rows are written as xv = (x (1) v , . . . , x (n) v )> for v [V ] and eh = (e(1)h , . . . , e (n) h ) > for h [H]. We also consider the correlation of each bit h of the encoding with each decoded bit v over the data, i.e. bv,h := 1n n i=1 x (i) v e (i) h . This too can be written in matrix form as B := 1 nXE > RVH , whose rows and columns we respectively write as bv = (bv,1, . . . , bv,H)> over v [V ] and bh = (b1,h, . . . , bV,h) > over h [H]; the indexing will be clear from context. As alluded to earlier, the loss incurred on any example x(i) is the cross-entropy between the example and its reconstruction x(i), in expectation over the randomness in x(i). Defining `(x (i) v ) = ln ( 2 1x(i)v ) (the partial losses to true labels 1), the loss is written as: `(x(i), x(i)) := V v=1 [( 1 + x (i) v 2 ) `+(x (i) v ) + ( 1 x(i)v 2 ) `(x (i) v ) ] (2) In addition, define a potential well (m) := ln (1 + em) + ln (1 + em) with derivative (m) := 1em 1+em . Univariate functions like this are applied componentwise to matrices in this paper.",
      "exclude": false
    },
    {
      "heading": "1.2 PROBLEM SETUP",
      "text": "With these definitions, the autoencoding problem we address can be precisely stated as two tasks, encoding and decoding. These share only the side information B. Our goal is to perform these steps so as to achieve the best possible guarantee on reconstruction loss, with no further assumptions. This can be written as a zero-sum game of an autoencoding algorithm seeking to minimize loss against an adversary, by playing encodings and reconstructions: Using X, algorithm plays (randomized) encodings E, resulting in pairwise correlations B. Using E and B, algorithm plays reconstructions X = ( x(1); . . . ; x(n) ) [1, 1]Vn. Given X,E,B, adversary plays X [1, 1]Vn to maximize reconstruction loss 1 n n i=1 `(x (i), x(i)). To incur low loss, the algorithm must use an E and B such that no adversary playing X can inflict higher loss. The algorithm never sees X, which represents the worst the data could be given the algorithms incomplete memory of it (E,B) and reconstructions (X). We find the autoencoding algorithms best strategy in two parts. First, we find the optimal decoding function of any encodings E given B, in Section 2. Then, we use the resulting optimal reconstruction function to outline the best encoding procedure, i.e. one that finds the E,B that lead to the best reconstruction, in Section 3.1. Combining these ideas yields an autoencoding algorithm in Section 3.2 (Algorithm 1), where its implementation and interpretation are specified. Further discussion and related work in Section 4 are followed by more extensions of the framework in Section 5. Experiments in Section 6 show extremely competitive results with equivalent fully-connected autoencoders trained with backpropagation.",
      "exclude": false
    },
    {
      "heading": "2 OPTIMALLY DECODING AN ENCODED REPRESENTATION",
      "text": "To address the game of Section 1.2, we first assume E and B are fixed, and derive the optimal decoding rule given this information. We show in this section that the form of this optimal decoder is precisely the same as in a classical autoencoder: having learned a weight vector wv RH for each v [V ], the vth bit of each reconstruction xi is expressed as a logistic function of a wv-weighted combination of the H encoded bits ei a logistic artificial neuron with weights wv. The weight vectors are learned by convex optimization, despite the nonconvexity of the transfer functions. To develop this, we minimize the worst-case reconstruction error, where X is constrained by our prior knowledge that B = 1nXE >, i.e. 1nExv = bv v [V ]. This can be written as a function of E: LB(E) := min x(1),...,x(n)[1,1]V max x(1),...,x(n)[1,1]V , v[V ]: 1nExv=bv 1 n n i=1 `(x(i), x(i)) (3) We solve this minimax problem for the optimal reconstructions played by the minimizing player in (3), written as x(1), . . . , x(n). Theorem 1. Define the bitwise slack function E(w,b) := b>w + 1n n i=1 (w >e(i)), which is convex in w. W.r.t. any bv, this has minimizing weights wv := w v(E,B) := arg min wRH E(w,bv). Then the minimax value of the game (3) is LB(E) = 1 2 V v=1 E(wv,bv). For any example i [n], the minimax optimal reconstruction can be written for any bit v as x(i)v := 1e w>v e (i) 1+ew > v e (i) . This tells us that the optimization problem of finding the minimax optimal reconstructions x(i) is extremely convenient in several respects. The learning problem decomposes over the V bits in the decoding, reducing to solving for a weight vector wv RH for each bit v, by optimizing each bitwise slack function. Given the weights, the optimal reconstruction of any example i can be specified by a layer of logistic sigmoid artificial neurons of its encoded bits, with w>v e (i) as the bitwise logits. Hereafter, we write W RVH as the matrix of decoding weights, with rows wvVv=1. In particular, the optimal decoding weights W(E,B) are the matrix with rows wv(E,B) V v=1.",
      "exclude": false
    },
    {
      "heading": "3 LEARNING AN AUTOENCODER",
      "text": "",
      "exclude": false
    },
    {
      "heading": "3.1 FINDING AN ENCODED REPRESENTATION",
      "text": "Having computed the optimal decoding function in the previous section given any E and B, we now switch perspectives to the encoder, which seeks to compress the input data X into encoded representations E (from which B is easily calculated to pass to the decoder). We seek to find (E,B) to ensure the lowest worst-case reconstruction loss after decoding; recall that this is LB(E) from (3). Observe that 1nXE > = B by definition, and that the encoder is given X. Therefore, by using Thm. 1 and substituting bv = 1nExv v [V ], LB(E) = 1 2n n i=1 V v=1 [ x(i)v (w>v e(i)) + (w>v e(i)) ] := L(W,E) (4) So it is convenient to define the feature distortion 1 for any v [V ] with respect to W, between any example x and its encoding e: Wv (e,x) := xvw>v e + (w>v e) (5) From the above discussion, the best E given any decoding W, written as E(W), solves the minimization min E[1,1]Hn L(W,E) = 1 2n n i=1 min e(i)[1,1]H V v=1 Wv (e (i), x(i)) which immediately yields the following result. Proposition 2. Define the optimal encodings for decoding weights W as E(W) := arg min E[1,1]Hn L(W,E). Then e(i)(W) can be computed separately for each example x(i) [1, 1]V , minimizing its total feature distortion over the decoded bits w.r.t. W: ENC(x(i);W) := e(i)(W) := arg min e[1,1]H V v=1 Wv (e, x (i)) (6) Observe that the encoding function ENC(x(i);W) can be efficiently computed to any desired precision since the feature distortion Wv (e, x (i)) of each bit v is convex and Lipschitz in e; an L1 error of can be reached in O( 2) linear-time first-order optimization iterations. Note that the encodings need not be bits, and can be e.g. unconstrained RH instead; the proof of Thm. 1 assumes no structure on them, and the optimization will proceed as above but without projecting into the hypercube.",
      "exclude": false
    },
    {
      "heading": "3.2 AN AUTOENCODER LEARNING ALGORITHM",
      "text": "Our ultimate goal is to minimize the worst-case reconstruction loss. As we have seen in (3) and (6), it is convex in the encoding E and in the decoding parameters W, each of which can be fixed while minimizing with respect to the other. This suggests a learning algorithm that alternately performs two steps: finding encodings E that minimize L(W,E) as in (6) with a fixed W, and finding decoding parameters W(E,B), as given in Algorithm 1. Algorithm 1 Pairwise Correlation Autoencoder (PC-AE) Input: Size-n dataset X, number of epochs T Initialize W0 (e.g. with each element being i.i.d. N (0, 1)) for t = 1 to T do Encode each example to ensure accurate reconstruction using weights Wt1, and compute the associated pairwise bit correlations Bt: i [n] : [e(i)]t = ENC(x(i);Wt1) , Bt = 1 n XE>t Update weight vectors [wv]t for each v [V ] to minimize slack function, using encodings Et: v [V ] : [wv]t = arg min wRH [ [bv]>t w + 1 n n i=1 (w>e (i) t ) ] end for Output: Weights WT 1Noting that (w>v e) w>v e, we see that Wv (e, x) w>v e (sgn(w>v e) xv). So the optimizer tends to change e so that w>v e matches signs with xv , motivating the name.",
      "exclude": false
    },
    {
      "heading": "3.3 EFFICIENT IMPLEMENTATION",
      "text": "Our derivation of the encoding and decoding functions involves no model assumptions at all, only using the minimax structure and pairwise statistics that the algorithm is allowed to remember. Nevertheless, the (en/de)coders can be learned and implemented efficiently. Decoding is a convex optimization in H dimensions, which can be done in parallel for each bit v [V ]. This is relatively easy to solve in the parameter regime of primary interest when data are abundant, in which H < V n. Similarly, encoding is also a convex optimization problem in only H dimensions. If the data examples are instead sampled in minibatches of size n, they can be encoded in parallel, with a new minibatch being sampled to start each epoch t. The number of examples n (per batch) is essentially only limited by nH , the number of compressed representations that fit in memory. So far in this paper, we have stated our results in the transductive setting, in which all data are given together a priori, with no assumptions whatsoever made about the interdependences between the V features. However, PC-AE operates much more efficiently than this might suggest. Crucially, the encoding and decoding tasks both depend on n only to average a function of x(i) or e(i) over i [n], so they can both be solved by stochastic optimization methods that use first-order gradient information, like variants of stochastic gradient descent (SGD). We find it remarkable that the minimax optimal encoding and decoding can be efficiently learned by such methods, which do not scale computationally in n. Note that the result of each of these steps involves (n) outputs (E and X), which are all coupled together in complex ways. Furthermore, efficient first-order convex optimization methods for both encoding and decoding steps manipulate more intermediate gradient-related quantities, with facile interpretations. For details, see Appendix A.2.",
      "exclude": false
    },
    {
      "heading": "3.4 CONVERGENCE AND WEIGHT REGULARIZATION",
      "text": "As we noted previously, the objective function of the optimization is biconvex. This means that the alternating minimization algorithm we specify is an instance of alternating convex search, shown in that literature to converge under broad conditions (Gorski et al. (2007)). It is not guaranteed to converge to the global optimum, but each iteration will monotonically decrease the objective function. In light of our introductory discussion, the properties and rate of such convergence would be interesting to compare to stochastic optimization algorithms for PCA, which converge efficiently under broad conditions (Balsubramani et al. (2013); Shamir (2016)). The basic game used so far has assumed perfect knowledge of the pairwise correlations, leading to equality constraints v [V ] : 1nExv = bv. This makes sense in PC-AE, where the encoding phase of each epoch gives the exact Bt for the decoding phase. However, in other stochastic settings as for denoising autoencoders (see Sec. 5.2), it may be necessary to relax this constraint. A relaxed constraint of 1 nExv bv exactly corresponds to an extra additive regularization term of wv1 on the corresponding weights in the convex optimization used to find W (Appendix D.1). Such regularization leads to provably better generalization (Bartlett (1998)) and is often practical to use, e.g. to encourage sparsity. But we do not use it for our PC-AE experiments in this paper.",
      "exclude": false
    },
    {
      "heading": "4 DISCUSSION AND RELATED WORK",
      "text": "Our approach PC-AE is quite different from existing autoencoding work in several ways. First and foremost, we posit no explicit decision rule, and avoid optimizing the highly non-convex decision surface traversed by traditional autoencoding algorithms that learn with backpropagation (Rumelhart et al. (1986)). The decoding function, given the encodings, is a single layer of artificial neurons only because of the minimax structure of the problem when minimizing worst-case loss. This differs from reasoning typically used in neural net work (see Jordan (1995)), in which the loss is the negative log-likelihood (NLL) of the joint probability, which is assumed to follow a form specified by logistic artificial neurons and their weights. We instead interpret the loss in the usual direct way as the NLL of the predicted probability of the data given the visible bits, and avoid any assumptions on the decision rule (e.g. not monotonicity in the score w>v e (i), or even dependence on such a score). This justification of artificial neurons as the minimax optimal decision rules given information on pairwise correlations is one of our more distinctive contributions (see Sec. 5.1). Crucially, we make no assumptions whatsoever on the form of the encoding or decoding, except on the memory used by the decoding. Some such regularizing\" restriction is necessary to rule out the autoencoder just memorizing the data, and is typically expressed by assuming a model class of compositions of artificial neuron layers. We instead impose it axiomiatically by limiting the amount of information transmitted through B, which does not scale in n; but we do not restrict how this information is used. This confers a clear theoretical advantage, allowing us to attain the strongest robust loss guarantee among all possible autoencoders that use the correlations B. More importantly in practice, avoiding an explicit model class means that we do not have to optimize the typically non-convex model, which has long been a central issue for backpropagation-based learning methods (e.g. Dauphin et al. (2014)). Prior work related in spirit has attempted to avoid this through convex relaxations, including for multi-layer optimization under various structural assumptions (Aslan et al. (2014); Zhang et al. (2016)), and when the number of hidden units is varied by the algorithm (Bengio et al. (2005); Bach (2014)). Our approach also isolates the benefit of higher n in dealing with overfitting, as the pairwise correlations B can be measured progressively more accurately as n increases. In this respect, we follow a line of research using such pairwise correlations to model arbitary higher-order structure among visible units, rooted in early work on (restricted) Boltzmann Machines (Ackley et al. (1985); Smolensky (1986); Rumelhart & McClelland (1987); Freund & Haussler (1992)). More recently, theoretical algorithms have been developed with the perspective of learning from the correlations between units in a network, under various assumptions on the activation function, architecture, and weights, for both deep (Arora et al. (2014)) and shallow networks (using tensor decompositions, e.g. Livni et al. (2014); Janzamin et al. (2015)). Our use of ensemble aggregation techniques (from Balsubramani & Freund (2015a; 2016)) to study these problems is anticipated in spirit by prior work as well, as discussed at length by Bengio (2009) in the context of distributed representations.",
      "exclude": true
    },
    {
      "heading": "4.1 OPTIMALITY, OTHER ARCHITECTURES, AND DEPTH",
      "text": "We have established that a single layer of logistic artificial neurons is an optimal decoder, given only indirect information about the data through pairwise correlations. This is not a claim that autoencoders need only a single-layer architecture in the worst case. Sec. 3.1 establishes that the best representations E are the solution to a convex optimization, with no artificial neurons involved in computing them from the data. Unlike the decoding function, the optimal encoding function ENC cannot be written explicitly in terms of artificial neurons, and is incomparable to existing architectures (though it is analogous to PCA in prescribing an efficient operation that yields the encodings from unlabeled data). Also, the encodings are only optimal given the pairwise correlations; training algorithms like backpropagation, which communicate other knowledge of the data through derivative composition, can learn final decoding layers that outperform ours, as we see in experiments. In our framework so far, we explore using all the pairwise correlations between hidden and visible bits to inform learning by constraining the adversary, resulting in a Lagrange parameter a weight for each constraint. These V H weights W constitute the parameters of the optimal decoding layer, describing a fully connected architecture. If just a select few of these correlations were used, only they would constrain the adversary in the minimax problem of Sec. 2, so weights would only be introduced for them, giving rise to sparser architectures. Our central choices to store only pairwise correlations and minimize worst-case reconstruction loss play a similar regularizing role to explicit model assumptions, and other autoencoding methods may achieve better performance on data for which these choices are too conservative, by e.g. making distributional assumptions on the data. From our perspective, other architectures with more layers particularly highly successful ones like convolutional, recurrent, residual, and ladder networks (LeCun et al. (2015); He et al. (2015); Rasmus et al. (2015)) lend the autoencoding algorithm more power by allowing it to measure more nuanced correlations using more parameters, which decreases the worst-case loss. Applying our approach with these would be interesting future work. Extending this papers convenient minimax characterization to deep representations with empirical success is a very interesting open problem. Prior work on stacking autoencoders/RBMs (Vincent et al. (2010)) and our learning algorithm PC-AE suggest that we could train a deep network in alternating forward and backward passes. Using this papers ideas, the forward pass would learn the weights to each layer given the previous layers activations (and inter-layer pairwise correlations) by minimizing the slack function, with the backward pass learning the activations for each layer given the weights to / activations of the next layer by convex optimization (as we learn E). Both passes would consist of successive convex optimizations dictated by our approach, quite distinct from backpropagation, though loosely resembling the wake-sleep algorithm (Hinton et al. (1995)).",
      "exclude": false
    },
    {
      "heading": "4.2 GENERATIVE APPLICATIONS",
      "text": "Particularly recently, autoencoders have been of interest largely for their many applications beyond compression, especially for their generative uses. The most directly relevant to us involve repurposing denoising autoencoders (Bengio et al. (2013b); see Sec. 5.2); moment matching among hidden and visible units (Li et al. (2015)); and generative adversarial network ideas (Goodfellow et al. (2014); Makhzani et al. (2015)), the latter particularly since the techniques of this paper have been applied to binary classification (Balsubramani & Freund (2015a;b)). These are outside this papers scope, but suggest themselves as future extensions of our approach.",
      "exclude": false
    },
    {
      "heading": "5 EXTENSIONS",
      "text": "",
      "exclude": false
    },
    {
      "heading": "5.1 OTHER RECONSTRUCTION LOSSES",
      "text": "It may make sense to use another reconstruction loss other than cross-entropy, for instance the expected Hamming distance between x(i) and x(i). It turns out that the minimax manipulations we use work under very broad conditions, for nearly any loss that additively decomposes over the V bits as cross-entropy does. In such cases, all that is required is that the partial losses `+(x (i) v ), `(x (i) v ) are monotonically decreasing and increasing respectively (recall that for cross-entropy loss, this is true as `(x (i) v ) = ln ( 2 1x(i)v ) ); they need not even be convex. This monotonicity is a natural condition, because the loss measures the discrepancy to the true label, and holds for all losses in common use. Changing the partial losses only changes the structure of the minimax solution in two respects: by altering the form of the transfer function on the decoding neurons, and the univariate potential well optimized to learn the decoding weights. Otherwise, the problem remains convex and the algorithm is identical. Formal statements of these general results are in Appendix E.",
      "exclude": false
    },
    {
      "heading": "5.2 DENOISING AUTOENCODING",
      "text": "Our framework can be easily applied to learn a denoising autoencoder (DAE; Vincent et al. (2008; 2010)), which uses noise-corrupted data (call it X) for training, and uncorrupted data for evaluation. From our perspective, this corresponds to leaving the learning of W unchanged, but using corrupted data when learning E. Consequently, the minimization problem over encodings must be changed to account for the bias on B introduced by the noise; so the algorithm plays given the noisy data, but to minimize loss against X. This is easiest to see for zero-mean noise, for which our algorithms are completely unchanged because B does not change (in expectation) after the noise is added. Another common scenario illustrating this technique is to mask a fraction of the input bits uniformly at random (in our notation, changing 1s to1s). This masking noise changes each pairwise correlation bv,h by an amount v,h := 1n n i=1(x (i) v x(i)v )e(i)h . Therefore, the optimand Eq. (4) must be modified by subtracting this factor v,h. This v,h can be estimated (w.h.p.) given xv, eh, ,xv . But even with just the noisy data and not xv , we can estimate v,h w.h.p. by extrapolating the correlation of the bits of xv that are left as +1 (a 1 fraction) with the corresponding values in eh (see Appendix C).",
      "exclude": false
    },
    {
      "heading": "6 EXPERIMENTS",
      "text": "In this section we compare our approach 2 empirically to a standard autoencoder with one hidden layer (termed AE here) trained with backpropagation, and a thresholded PCA baseline. Our goal is simply to verify that our approach, though very different, is competitive in reconstruction performance. The datasets we use are first normalized to [0, 1], and then binarized by sampling each pixel stochastically in proportion to its intensity, following prior work (Salakhutdinov & Murray (2008)). Changing between binary and real-valued encodings in PC-AE requires just a line of code, to project the encodings into [1, 1]H after convex optimization updates to compute ENC(). We use Adagrad (Duchi et al. (2011)) for the convex minimizations of our algorithms; we observed that their performance is not very sensitive to the choice of optimization method, explained by our approachs convexity. We compare to a basic AE with a single hidden layer, trained using the Adam method with default parameters (Kingma & Ba (2014)). Other models like variational autoencoders (Kingma & Welling (2013)) are not shown here because they do not aim to optimize reconstruction loss or are not comparably general autoencoding architectures. We also use a sign-thresholded PCA baseline (essentially a completely linear autoencoder, but with the output layer thresholded to be in [1, 1]); see Appendix A for more details. We vary the number of hidden units H for all algorithms, and try both binary and unconstrained real-valued encodings where appropriate; the respective AE uses logistic sigmoid and ReLU transfer functions for the encoding neurons. The results are in Table 1. The reconstruction performance of PC-AE indicates that it can encode information very well using pairwise correlations, compared to the directly learned AE and PCA approaches. Loss can become extremely low when H is raised, giving B the capacity to robustly encode almost all the information in the input bits X. The performance is roughly equal between binary hidden units and unconstrained ones, which is expected by our derivations. We also try learning just the decoding layer of Sec. 2, on the encoded representation of the AE. This is motivated by the fact that Sec. 2 establishes our decoding method to be worst-case optimal given any E and B. We find the results to be significantly worse than the AE alone in all datasets used (e.g. reconstruction loss of 171/133 on MNIST, and 211/134 on Omniglot, with 32/100 hidden units respectively). This reflects the AEs training backpropagating information about the data beyond pairwise correlations, through non-convex function compositions however, this comes at the cost of being more difficult to optimize. The representations learned by the ENC function of PC-AE are quite different and capture much more of the pairwise correlation information, which is used by the decoding layer in a worst-case optimal fashion. We attempt to visually depict the differences between the representations in Fig. 3. As discussed in Sec. 4, we do not claim that this papers method will always achieve the best empirical reconstruction loss, even among single-layer autoencoders. We would like to make the encoding 2TensorFlow code available at https://github.com/aikanor/pc-autoencoder . function quicker to compute, as well. But we believe this papers results, especially when H is high, illustrate the potential of using pairwise correlations for autoencoding as in our approach, learning to encode with alternating convex minimization and extremely strong worst-case robustness guarantees.",
      "exclude": false
    },
    {
      "heading": "ACKNOWLEDGMENTS",
      "text": "I am grateful to Jack Berkowitz, Sanjoy Dasgupta, and Yoav Freund for helpful discussions; Daniel Hsu and Akshay Krishnamurthy for instructive examples; and Gary Cottrell for an enjoyable chat. I acknowledge funding from the NIH (grant R01ES02500902).",
      "exclude": true
    },
    {
      "heading": "A EXPERIMENTAL DETAILS",
      "text": "In addition to MNIST, we use the preprocessed version of the Omniglot dataset found in Burda et al. (2016), split 1 of the Caltech-101 Silhouettes dataset, the small notMNIST dataset, and the UCI Adult (a1a) dataset. The results reported are the mean of 10 Monte Carlo runs, and the PC-AE significance results use 95% Monte Carlo confidence intervals. Only notMNIST comes without a predefined split, so the displayed results use 10-fold cross-validation. Non-binarized versions of all datasets (grayscale pixels) resulted in nearly identical PC-AE performance (not shown); this is as expected from its derivation using expected pairwise correlations, which with high probability are nearly invariant under binarization (by e.g. Hoeffding bounds). We used minibatches of size 250. All standard autoencoders use the Xavier initialization and trained for 500 epochs or using early stopping on the test set. The PCA\" baseline was run on exactly the same input data as the others; it finds decodings by mean-centering this input, finding the top H principal components with standard PCA, reconstructing the mean-centered input with these components, adding back the means, and finally thresholding the result to [1, 1]V . We did not evaluate against other types of autoencoders which regularize (Kingma & Welling (2013)) or are otherwise not trained for direct reconstruction loss minimization. Also, not shown is the performance of a standard convolutional autoencoder (32-bit representation, depth-3 64-64-32 (en/de)coder) which performs better than the standard autoencoder, but is still outperformed by PC-AE on our image-based datasets. A deeper architecture could quite possibly achieve superior performance, but the greater number of channels through which information is propagated makes fair comparison with our flat fully-connected approach difficult. We consider extension of our PC-AE approach to such architectures to be fascinating future work. A.1 FURTHER RESULTS Our bound on worst-case loss is invariably quite tight, as shown in Fig. 4. Similar results are found on all datasets. This is consistent with our conclusions about the nature of the PC-AE representations conveying almost exactly the information available in pairwise correlations. A 2D visualization of MNIST is in Fig. 6, showing that even with just two hidden units there is enough information in pairwise correlations for PC-AE to learn a sensible embedding. We also include more pictures of our autoencoders reconstructions, and visualizations of the hidden units when H = 100 in Fig. 5. A.2 PC-AE INTERPRETATION AND IMPLEMENTATION DETAILS Here we give some details that are useful for interpretation and implementation of the proposed method. A.2.1 ENCODING Proposition 2 defines the encoding function for any data example x as the vector that minimizes the total feature distortion, summed over the bits in the decoding, rewritten here for convenience: ENC(x(i);W) := arg min e[1,1]H V v=1 [ x(i)v w>v e(i) + (w>v e(i)) ] (7) Doing this on multiple examples at once (in memory as a minibatch) can be much faster than on each example separately. We can now compute the gradient of the objective function w.r.t. each example i [n], writing the gradient w.r.t. example i as column i of a matrix G RHn. G can be calculated efficiently in a number of ways, for example as follows: Compute matrix of hallucinated data X := (WE) RVn. Subtract X to compute residuals R := XX RVn. Compute G = 1nW >R RHn. Optimization then proceeds with gradient descent using G, with the step size found using line search. Note that since the objective function is convex, the optimum E leads to optimal residuals R RVn such that G = 1nW >R = 0Hn, so each column of R is in the null space of W>, which maps the residual vectors to the encoded space. We conclude that although the compression is not perfect (so the optimal residuals R 6= 0Vn in general), each column of R is orthogonal to the decoding weights at an equilibrium towards which the convex minimization problem of (7) is guaranteed to stably converge. A.2.2 DECODING The decoding step finds W to ensure accurate decoding of the given encodings E with correlations B, solving the convex minimization problem: W = arg min WRVH V v=1 [ b>v wv + 1 n n i=1 (w>v e (i)) ] (8) This can be minimized by first-order convex optimization. The gradient of (8) at W is: B + 1 n [(WE)]E> (9) The second term can be understood as hallucinated\" pairwise correlations B, between bits of the encoded examples E and bits of their decodings under the current weights, X := (WE). The hallucinated correlations can be written as B := 1nXE >. Therefore, (9) can be interpreted as the residual correlations B B. Since the slack function of (8) is convex, the optimum W leads to hallucinated correlations B = B, which is the limit reached by the optimization algorithm after many iterations.",
      "exclude": false
    },
    {
      "heading": "B ALLOWING RANDOMIZED DATA AND ENCODINGS",
      "text": "In this paper, we represent the bit-vector data in a randomized way in [1, 1]V . Randomizing the data only relaxes the constraints on the adversary in the game we play; so at worst we are working with an upper bound on worst-case loss, instead of the exact minimax loss itself, erring on the conservative side. Here we briefly justify the bound as being essentially tight, which we also see empirically in this papers experiments. In the formulation of Section 2, the only information we have about the data is its pairwise correlations with the encoding units. When the data are abundant (n large), then w.h.p. these correlations are close to their expected values over the datas internal randomization, so representing them as continuous values w.h.p. results in the same B and therefore the same solutions for E,W. We are effectively allowing the adversary to play each bits conditional probability of firing, rather than the binary realization of that probability. This allows us to apply minimax theory and duality to considerably simplify the problem to a convex optimization, when it would otherwise be nonconvex, and computationally hard (Baldi (2012)). The fact that we are only using information about the data through its expected pairwise correlations with the hidden units makes this possible. The above also applies to the encodings and their internal randomization, allowing us to learn binary randomized encodings by projecting to the convex set [1, 1]H .",
      "exclude": false
    },
    {
      "heading": "C DENOISING AUTOENCODER WITH MASKING NOISE: DETAILS",
      "text": "This section elaborates on the discussion of Sec. 5.2. Recall the correlation correction term v,h from Sec. 5.2: v,h = 1 n n i=1 (x(i)v x(i)v )e (i) h Here, we express this in terms of the known quantities xv, eh, , and not the unknown denoised data xv . Consider that (x(i)v x(i)v )e (i) h = 1 ( x(i)v = 1 ) (x(i)v x(i)v )e (i) h + 1 ( x(i)v = +1 ) (x(i)v x(i)v )e (i) h Now if x(i)v = 1, then x(i)v = 1, so (x(i)v x(i)v )e(i)h = 0. Therefore the first term above is zero, and the expression can be simplified: (x(i)v x(i)v )e (i) h = 1 ( x(i)v = +1 ) (x(i)v x(i)v )e (i) h = 1 ( x(i)v = +1 x(i)v = 1 ) (2)e(i)h (10) Now on any example i, independent of the value of e(i)h , a fraction of the bits where x (i) v = +1 are flipped to get x(i)v . Therefore, 1 n i=1 1 ( x(i)v = +1 x(i)v = 1 ) e (i) h 1 1 n i=1 1 ( x(i)v = +1 x(i)v = +1 ) e (i) h Putting it all together, v,h = 1 n n i=1 (x(i)v x(i)v )e (i) h = 2 n n i=1 1 ( x(i)v = +1 x(i)v = 1 ) e (i) h 2 n 1 n i=1 1 ( x(i)v = +1 x(i)v = +1 ) e (i) h = 2 n 1 n i=1 1 ( x(i)v = +1 ) e (i) h",
      "exclude": false
    },
    {
      "heading": "D PROOFS",
      "text": "Proof of Theorem 1. Writing (x(i)v ) := `(x (i) v ) `+(x(i)v ) = ln ( 1+x(i)v 1x(i)v ) for convenience, we can simplify L, using the definition of the loss (2), and Lagrange duality for all V H constraints involving B. This leads to the following chain of equalities, where for brevity the constraint sets are sometimes omitted when clear, and we write X as shorthand for the data x(1), . . . ,x(n) and X analogously for the reconstructions. L = 1 2 min x(1),...,x(n) [1,1]V max x(1),...,x(n)[1,1]V , v[V ]: 1nExv=bv 1 n n i=1 V v=1 [( 1 + x(i)v ) `+(x (i) v ) + ( 1 x(i)v ) `(x (i) v ) ] = 1 2 min X max X min WRVH [ 1 n n i=1 V v=1 ( `+(x (i) v ) + `(x (i) v ) x(i)v (x(i)v ) ) + V v=1 w>v ( 1 n Exv bv )] (a) = 1 2 min w1,...,wV [ V v=1 b>v wv + 1 n min X max X V v=1 [ n i=1 ( `+(x (i) v ) + `(x (i) v ) x(i)v (x(i)v ) ) + w>v Exv ]] = 1 2 min w1,...,wV [ V v=1 b>v wv + 1 n min X n i=1 V v=1 [ `+(x (i) v ) + `(x (i) v ) + max x(i)[1,1]V x(i)v ( w>v e (i) (x(i)v ) )]] (11) where (a) uses the minimax theorem (Cesa-Bianchi & Lugosi (2006)), which can be applied as in linear programming, because the objective function is linear in x(i) and wv. Note that the weights are introduced merely as Lagrange parameters for the pairwise correlation constraints, not as model assumptions. The strategy x(i) which solves the inner maximization of (11) is to simply match signs with w>v e (i) (x (i) v ) coordinate-wise for each v [V ]. Substituting this into the above, L = 1 2 min w1,...,wV [ V v=1 b>v wv + 1 n n i=1 min x(i)[1,1]V V v=1 ( `+(x (i) v ) + `(x (i) v ) + w>v e(i) (x(i)v )) ] = 1 2 V v=1 min wvRH [ b>v wv + 1 n n i=1 min x (i) v [1,1] ( `+(x (i) v ) + `(x (i) v ) + w>v e(i) (x(i)v )) ] The absolute value breaks down into two cases, so the inner minimizations objective can be simplified: `+(x (i) v ) + `(x (i) v ) + w>v e(i) (x(i)v ) = 2`+(x (i) v ) + w>v e (i) if w>v e (i) (x(i)v ) 2`(x (i) v )w>v e(i) if w>v e(i) v e (i) (x(i)v ). By definition of `+(), 2`+(x (i) v ) +w>v e (i) is decreasing in x(i)v , so it is minimized for the greatest x (i) v 1 s.t. (x(i)v ) w>v e (i). This means (x(i)v ) = w>v e (i), so the minimand (12) is `+(x (i) v ) + `(x (i) v ), where xiv = 1ew > v e (i) 1+ew > v e (i) . A precisely analogous argument holds if x(i)v falls in the second case of (12), where w>v e (i) v e (i), where wv is the minimizer of the outer minimization of (11). This completes the proof. D.1 L CORRELATION CONSTRAINTS AND L1 WEIGHT REGULARIZATION Here we formalize the discussion of Sec. 3.4 with the following result. Theorem 3. min x(1),...,x(n)[1,1]V max x(1),...,x(n)[1,1]V , v[V ]: 1nExvbv v 1 n n i=1 `(x(i), x(i)) = 1 2 V v=1 min wvRH [ b>v wv + 1 n n i=1 (w>v e (i)) + v wv1 ] For each v, i, the minimizing x(i)v is a logistic function of the encoding e(i) with weights equal to the minimizing wv above, exactly as in Theorem 1. Proof. The proof adapts the proof of Theorem 1, following the result on L1 regularization in Balsubramani & Freund (2016) in a very straightforward way; we describe this here. We break each L constraint into two one-sided constraints for each v, i.e. 1nExv bv v1 n and 1 nExv bv v1 n. These respectively give rise to two sets of Lagrange parameters v, v 0H for each v, replacing the unconstrained Lagrange parameters wv RH . The conditions for the minimax theorem apply here just as in the proof of Theorem 1, so that (11) is replaced by 1 2 min 1,...,V 1,...,V [ V v=1 ( b>v (v v) v1>(v + v) ) (13) + 1 n min X n i=1 V v=1 [ `+(x (i) v ) + `(x (i) v ) + max x(i) x(i)v ( (v v)>e(i) (x(i)v ) )]] (14) Suppose for some h [H] that v,h > 0 and v,h > 0. Then subtracting min(v,h, v,h) from both does not affect the value [v v]h, but always decreases [v + v]h, and therefore always decreases the objective function. Therefore, we can w.l.o.g. assume that h [H] : min(v,h, v,h) = 0. Defining wv = v v (so that v,h = [wv,h]+ and v,h = [wv,h] for all h), we see that the term v1 >(v + v) in (13) can be replaced by v wv1. Proceeding as in the proof of Theorem 1 gives the result.",
      "exclude": false
    },
    {
      "heading": "E GENERAL RECONSTRUCTION LOSSES",
      "text": "In this section we extend Theorem 1 to a larger class of reconstruction losses for binary autoencoding, of which cross-entropy loss is a special case. This uses techniques recently employed by Balsubramani & Freund (2016) for binary classification. Since the data X are still randomized binary, we first broaden the definition of (2), rewritten here: `(x(i), x(i)) := V v=1 [( 1 + x (i) v 2 ) `+(x (i) v ) + ( 1 x(i)v 2 ) `(x (i) v ) ] (15) We do this by redefining the partial losses `(x (i) v ), to any functions satisfying the following monotonicity conditions. Assumption 1. Over the interval (1, 1), `+() is decreasing and `() is increasing, and both are twice differentiable. Assumption 1 is a very natural one and includes many non-convex losses (see Balsubramani & Freund (2016) for a more detailed discussion, much of which applies bitwise here). This and the additive decomposability of (15) over the V bits are the only assumptions we make on the reconstruction loss `(x(i), x(i)). The latter decomposability assumption is often natural when the loss is a log-likelihood, where it is tantamount to conditional independence of the visible bits given the hidden ones. Given such a reconstruction loss, define the increasing function (y) := `(y)`+(y) : [1, 1] 7 R, for which there exists an increasing (pseudo)inverse 1. Using this we broaden the definition of the potential function in terms of `: (m) := m+ 2`(1) if m (1) `+( 1(m)) + `( 1(m)) if m ((1),(1)) m+ 2`+(1) if m (1) Then we may state the following result, describing the optimal decoding function for a general reconstruction loss. Theorem 4. Define the potential function min x(1),...,x(n)[1,1]V max x(1),...,x(n)[1,1]V , v[V ]: 1nExv=bv 1 n n i=1 `(x(i), x(i)) = 1 2 V v=1 min wvRH [ b>v wv + 1 n n i=1 (w>v e (i)) ] For each v [V ], i [n], the minimizing x(i)v is a sigmoid function of the encoding e(i) with weights equal to the minimizing wv above, as in Theorem 1. The sigmoid is defined as x(i)v := 1 if wv>e(i) (1) 1(wv >e(i)) if wv >e(i) ((1),(1)) 1 if wv >e(i) (1) (16) The proof is nearly identical to that of the main theorem of Balsubramani & Freund (2016). That proof is essentially recapitulated here for each bit v [V ] due to the additive decomposability of the loss, through algebraic manipulations (and one application of the minimax theorem) identical to the proof of Theorem 1, but using the more general specifications of and in this section. So we do not rewrite it in full here. A notable special case of interest is the Hamming loss, for which `(x (i) v ) = 1 2 ( 1 x(i)v ) , where the reconstructions are allowed to be randomized binary values. In this case, we have (m) = max(|m| , 1), and the sigmoid used for each decoding neuron is the clipped linearity max(1,min(wv>e(i), 1)).",
      "exclude": false
    },
    {
      "heading": "F ALTERNATE APPROACHES",
      "text": "We made some technical choices in the derivation of PC-AE, which prompt possible alternatives not explored here for a variety of reasons. Recounting these choices gives more insight into our framework. The output reconstructions could have restricted pairwise correlations, i.e. 1nXE > = B. One option is to impose such restrictions instead of the existing constraints on X, leaving X unrestricted. However, this is not in the spirit of this paper, because B is our means of indirectly conveying information to the decoder about how X is decoded. Another option is to restrict both X and X. This is possible and may be useful in propagating correlation information between layers of deeper architectures while learning, but its minimax solution does not have the conveniently clean structure of the PC-AE derivation. In a similar vein, we could restrict E during the encoding phase, using B and X. As B is changed only during this phase to better conform to the true data X, this tactic fixes B during the optimization, which is not in the spirit of this papers approach. It also performed significantly worse in our experiments.",
      "exclude": false
    }
  ]
}