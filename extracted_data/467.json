{
  "id": "467",
  "title": "Adversarial Feature Learning",
  "abstract": "The ability of the Generative Adversarial Networks (GANs) framework to learn generative models mapping from simple latent distributions to arbitrarily complex data distributions has been demonstrated empirically, with compelling results showing generators learn to \"linearize semantics\" in the latent space of such models. Intuitively, such latent spaces may serve as useful feature representations for auxiliary problems where semantics are relevant. However, in their existing form, GANs have no means of learning the inverse mapping -- projecting data back into the latent space. We propose Bidirectional Generative Adversarial Networks (BiGANs) as a means of learning this inverse mapping, and demonstrate that the resulting learned feature representation is useful for auxiliary supervised discrimination tasks, competitive with contemporary approaches to unsupervised and self-supervised feature learning.",
  "accepted": true,
  "zeroShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": false,
        "confidence": 0.92,
        "primary_reason": "Novel theoretical framework (BiGAN) with solid mathematical foundations, clear inverse mapping guarantee, and comprehensive empirical validation across multiple vision tasks. Strong contribution to unsupervised feature learning with practical applicability."
      },
      "token": {
        "prompt_tokens": 6249,
        "completion_tokens": 78,
        "total_tokens": 6327
      },
      "time": "2026-02-05T22:50:10.631699+00:00"
    }
  ],
  "article": [
    {
      "heading": "1 INTRODUCTION",
      "text": "Deep convolutional networks (convnets) have become a staple of the modern computer vision pipeline. After training these models on a massive database of image-label pairs like ImageNet (Russakovsky et al., 2015), the network easily adapts to a variety of similar visual tasks, achieving impressive results on image classification (Donahue et al., 2014; Zeiler & Fergus, 2014; Razavian et al., 2014) or localization (Girshick et al., 2014; Long et al., 2015) tasks. In other perceptual domains such as natural language processing or speech recognition, deep networks have proven highly effective as well (Bahdanau et al., 2015; Sutskever et al., 2014; Vinyals et al., 2015; Graves et al., 2013). However, all of these recent results rely on a supervisory signal from large-scale databases of hand-labeled data, ignoring much of the useful information present in the structure of the data itself. Meanwhile, Generative Adversarial Networks (GANs) (Goodfellow et al., 2014) have emerged as a powerful framework for learning generative models of arbitrarily complex data distributions. The GAN framework learns a generator mapping samples from an arbitrary latent distribution to data, as well as an adversarial discriminator which tries to distinguish between real and generated samples as accurately as possible. The generators goal is to fool the discriminator by producing samples which are as close to real data as possible. When trained on databases of natural images, GANs produce impressive results (Radford et al., 2016; Denton et al., 2015). Interpolations in the latent space of the generator produce smooth and plausible semantic variations, and certain directions in this space correspond to particular semantic attributes along which the data distribution varies. For example, Radford et al. (2016) showed that a GAN trained on a database of human faces learns to associate particular latent directions with gender and the presence of eyeglasses. A natural question arises from this ostensible semantic juice flowing through the weights of generators learned using the GAN framework: can GANs be used for unsupervised learning of rich feature representations for arbitrary data distributions? An obvious issue with doing so is that the generator maps latent samples to generated data, but the framework does not include an inverse mapping from data to latent representation. Hence, we propose a novel unsupervised feature learning framework, Bidirectional Generative Adversarial Networks (BiGAN). The overall model is depicted in Figure 1. In short, in addition to the generator G from the standard GAN framework (Goodfellow et al., 2014), BiGAN includes an encoder E which maps data x to latent representations z. The BiGAN discriminator D discriminates not only in data space (x versus G(z)), but jointly in data and latent space (tuples (x, E(x)) versus (G(z), z)), where the latent component is either an encoder output E(x) or a generator input z. It may not be obvious from this description that the BiGAN encoder E should learn to invert the generator G. The two modules cannot directly communicate with one another: the encoder never sees generator outputs (E(G(z)) is not computed), and vice versa. Yet, in Section 3, we will both argue intuitively and formally prove that the encoder and generator must learn to invert one another in order to fool the BiGAN discriminator. Because the BiGAN encoder learns to predict features z given data x, and prior work on GANs has demonstrated that these features capture semantic attributes of the data, we hypothesize that a trained BiGAN encoder may serve as a useful feature representation for related semantic tasks, in the same way that fully supervised visual models trained to predict semantic labels given images serve as powerful feature representations for related visual tasks. In this context, a latent representation z may be thought of as a label for x, but one which came for free, without the need for supervision. An alternative approach to learning the inverse mapping from data to latent representation is to directly model p(z|G(z)), predicting generator input z given generated data G(z). Well refer to this alternative as a latent regressor, later arguing (Section 4.1) that the BiGAN encoder may be preferable in a feature learning context, as well as comparing the approaches empirically. BiGANs are a robust and highly generic approach to unsupervised feature learning, making no assumptions about the structure or type of data to which they are applied, as our theoretical results will demonstrate. Our empirical studies will show that despite their generality, BiGANs are competitive with contemporary approaches to self-supervised and weakly supervised feature learning designed specifically for a notoriously complex data distribution natural images. Dumoulin et al. (2016) independently proposed an identical model in their concurrent work, exploring the case of a stochastic encoder E and the ability of such models to learn in a semi-supervised setting.",
      "exclude": true
    },
    {
      "heading": "2 PRELIMINARIES",
      "text": "Let pX(x) be the distribution of our data for x X (e.g. natural images). The goal of generative modeling is capture this data distribution using a probabilistic model. Unfortunately, exact modeling of this probability density function is computationally intractable (Hinton et al., 2006; Salakhutdinov & Hinton, 2009) for all but the most trivial models. Generative Adversarial Networks (GANs) (Good- fellow et al., 2014) instead model the data distribution as a transformation of a fixed latent distribution pZ(z) for z Z. This transformation, called a generator, is expressed as a deterministic feed forward network G : Z X with pG(x|z) = (xG(z)) and pG(x) = EzpZ [pG(x|z)]. The goal is to train a generator such that pG(x) pX(x). The GAN framework trains a generator, such that no discriminative model D : X 7 [0, 1] can distinguish samples of the data distribution from samples of the generative distribution. Both generator and discriminator are learned using the adversarial (minimax) objective min G max D V (D,G), where V (D,G) := ExpX [logD(x)] + ExpG [log (1D(x))]} {{ } EzpZ [log(1D(G(z)))] (1) Goodfellow et al. (2014) showed that for an ideal discriminator the objective C(G) := maxD V (D,G) is equivalent to the Jensen-Shannon divergence between the two distributions pG and pX. The adversarial objective 1 does not directly lend itself to an efficient optimization, as each step in the generator G requires a full discriminator D to be learned. Furthermore, a perfect discriminator no longer provides any gradient information to the generator, as the gradient of any global or local maximum of V (D,G) is 0. To provide a strong gradient signal nonetheless, Goodfellow et al. (2014) slightly alter the objective between generator and discriminator updates, while keeping the same fixed point characteristics. They also propose to optimize (1) using an alternating optimization switching between updates to the generator and discriminator. While this optimization is not guaranteed to converge, empirically it works well if the discriminator and generator are well balanced. Despite the empirical strength of GANs as generative models of arbitrary data distributions, it is not clear how they can be applied as an unsupervised feature representation. One possibility for learning such representations is to learn an inverse mapping regressing from generated data G(z) back to the latent input z. However, unless the generator perfectly models the data distribution pX, a nearly impossible objective for a complex data distribution such as that of high-resolution natural images, this idea may prove insufficient.",
      "exclude": false
    },
    {
      "heading": "3 BIDIRECTIONAL GENERATIVE ADVERSARIAL NETWORKS",
      "text": "In Bidirectional Generative Adversarial Networks (BiGANs) we not only train a generator, but additionally train an encoder E : X Z. The encoder induces a distribution pE(z|x) = (z E(x)) mapping data points x into the latent feature space of the generative model. The discriminator is also modified to take input from the latent space, predicting PD(Y |x, z), where Y = 1 if x is real (sampled from the real data distribution pX), and Y = 0 if x is generated (the output of G(z), z pZ). The BiGAN training objective is defined as a minimax objective min G,E max D V (D,E,G) (2) where V (D,E,G) := ExpX [ EzpE(|x) [logD(x, z)]} {{ } logD(x,E(x)) ] + EzpZ [ ExpG(|z) [log (1D(x, z))]} {{ } log(1D(G(z),z)) ] . (3) We optimize this minimax objective using the same alternating gradient based optimization as Goodfellow et al. (2014). See Section 3.4 for details. BiGANs share many of the theoretical properties of GANs (Goodfellow et al., 2014), while additionally guaranteeing that at the global optimum, G and E are each others inverse. BiGANs are also closely related to autoencoders with an `0 loss function. In the following sections we highlight some of the appealing theoretical properties of BiGANs. Definitions Let pGZ(x, z) := pG(x|z)pZ(z) and pEX(x, z) := pE(z|x)pX(x) be the joint distributions modeled by the generator and encoder respectively. := X Z is the joint latent and data space. For a region R , PEX(R) := pEX(x, z)1[(x,z)R] d(x, z) = X pX(x) Z pE(z|x)1[(x,z)R] dzdx PGZ(R) := pGZ(x, z)1[(x,z)R] d(x, z) = Z pZ(z) X pG(x|z)1[(x,z)R] dx dz are probability measures over that region. We also define PX(RX) := X pX(x)1[xRX] dx PZ(RZ) := Z pZ(z)1[zRZ] dz as measures over regions RX X and RZ Z. We refer to the set of features and data samples in the support of PX and PZ as X := supp(PX) and Z := supp(PZ) respectively. DKL (P ||Q ) and DJS (P ||Q ) respectively denote the Kullback-Leibler (KL) and Jensen-Shannon divergences between probability measures P and Q. By definition, DKL (P ||Q ) := ExP [log fPQ(x)] DJS (P ||Q ) := 12 ( DKL ( P P+Q2 )+ DKL (Q P+Q2 )) , where fPQ := dPdQ is the Radon-Nikodym (RN) derivative of measure P with respect to measure Q, with the defining property that P (R) = R fPQ dQ. The RN derivative fPQ : 7 R0 is defined for any measures P and Q on space such that P is absolutely continuous with respect to Q: i.e., for any R , P (R) > 0 = Q(R) > 0.",
      "exclude": false
    },
    {
      "heading": "3.1 OPTIMAL DISCRIMINATOR, GENERATOR, & ENCODER",
      "text": "We start by characterizing the optimal discriminator for any generator and encoder, following Goodfellow et al. (2014). This optimal discriminator then allows us to reformulate objective (3), and show that it reduces to the Jensen-Shannon divergence between the joint distributions PEX and PGZ. Proposition 1 For any E and G, the optimal discriminator DEG := arg maxD V (D,E,G) is the Radon-Nikodym derivative fEG := dPEXd(PEX+PGZ) : 7 [0, 1] of measure PEX with respect to measure PEX + PGZ. Proof. Given in Appendix A.1. This optimal discriminator now allows us to characterize the optimal generator and encoder. Proposition 2 The encoder and generators objective for an optimal discriminator C(E,G) := maxD V (D,E,G) = V (D EG, E,G) can be rewritten in terms of the Jensen-Shannon divergence between measures PEX and PGZ as C(E,G) = 2 DJS (PEX ||PGZ ) log 4. Proof. Given in Appendix A.2. Theorem 1 The global minimum of C(E,G) is achieved if and only if PEX = PGZ. At that point, C(E,G) = log 4 and DEG = 12 . Proof. From Proposition 2, we have that C(E,G) = 2 DJS (PEX ||PGZ ) log 4. The JensenShannon divergence DJS (P ||Q ) 0 for any P and Q, and DJS (P ||Q ) = 0 if and only if P = Q. Therefore, the global minimum of C(E,G) occurs if and only if PEX = PGZ, and at this point the value is C(E,G) = log 4. Finally, PEX = PGZ implies that the optimal discriminator is chance: DEG = dPEX d(PEX+PGZ) = dPEX2 dPEX = 1 2 . The optimal discriminator, encoder, and generator of BiGAN are similar to the optimal discriminator and generator of the GAN framework (Goodfellow et al., 2014). However, an important difference is that BiGAN optimizes a Jensen-Shannon divergence between a joint distribution over both data X and latent features Z. This joint divergence allows us to further characterize properties of G and E, as shown below.",
      "exclude": false
    },
    {
      "heading": "3.2 OPTIMAL GENERATOR & ENCODER ARE INVERSES",
      "text": "We first present an intuitive argument that, in order to fool a perfect discriminator, a deterministic BiGAN encoder and generator must invert each other. (Later we will formally state and prove this property.) Consider a BiGAN discriminator input pair (x, z). Due to the sampling procedure, (x, z) must satisfy at least one of the following two properties: (a) x X E(x) = z (b) z Z G(z) = x If only one of these properties is satisfied, a perfect discriminator can infer the source of (x, z) with certainty: if only (a) is satisfied, (x, z) must be an encoder pair (x, E(x)) and DEG(x, z) = 1; if only (b) is satisfied, (x, z) must be a generator pair (G(z), z) and DEG(x, z) = 0. Therefore, in order to fool a perfect discriminator at (x, z) (so that 0 < DEG(x, z) < 1), E and G must satisfy both (a) and (b). In this case, we can substitute the equality E(x) = z required by (a) into the equality G(z) = x required by (b), and vice versa, giving the inversion properties x = G(E(x)) and z = E(G(z)). Formally, we show in Theorem 2 that the optimal generator and encoder invert one another almost everywhere on the support X and Z of PX and PZ. Theorem 2 If E and G are an optimal encoder and generator, then E = G1 almost everywhere; that is, G(E(x)) = x for PX-almost every x X, and E(G(z)) = z for PZ-almost every z Z. Proof. Given in Appendix A.4. While Theorem 2 characterizes the encoder and decoder at their optimum, due to the non-convex nature of the optimization, this optimum might never be reached. Experimentally, Section 4 shows that on standard datasets, the two are approximate inverses; however, they are rarely exact inverses. It is thus also interesting to show what objective BiGAN optimizes in terms of E and G. Next we show that BiGANs are closely related to autoencoders with an `0 loss function.",
      "exclude": false
    },
    {
      "heading": "3.3 RELATIONSHIP TO AUTOENCODERS",
      "text": "As argued in Section 1, a model trained to predict features z given data x should learn useful semantic representations. Here we show that the BiGAN objective forces the encoder E to do exactly this: in order to fool the discriminator at a particular z, the encoder must invert the generator at that z, such that E(G(z)) = z. Theorem 3 The encoder and generator objective given an optimal discriminator C(E,G) := maxD V (D,E,G) can be rewritten as an `0 autoencoder loss function C(E,G) = ExpX [ 1[E(x)ZG(E(x))=x] log fEG(x, E(x)) ] + EzpZ [ 1[G(z)XE(G(z))=z] log (1 fEG(G(z), z)) ] with log fEG (, 0) and log (1 fEG) (, 0) PEX-almost and PGZ-almost everywhere. Proof. Given in Appendix A.5. Here the indicator function 1[G(E(x))=x] in the first term is equivalent to an autoencoder with `0 loss, while the indicator 1[E(G(z))=z] in the second term shows that the BiGAN encoder must invert the generator, the desired property for feature learning. The objective further encourages the functions E(x) and G(z) to produce valid outputs in the support of PZ and PX respectively. Unlike regular autoencoders, the `0 loss function does not make any assumptions about the structure or distribution of the data itself; in fact, all the structural properties of BiGAN are learned as part of the discriminator.",
      "exclude": false
    },
    {
      "heading": "3.4 LEARNING",
      "text": "In practice, as in the GAN framework (Goodfellow et al., 2014), each BiGAN module D, G, and E is a parametric function (with parameters D, G, and E , respectively). As a whole, BiGAN can be optimized using alternating stochastic gradient steps. In one iteration, the discriminator parameters D are updated by taking one or more steps in the positive gradient direction DV (D,E,G), then the encoder parameters E and generator parameters G are together updated by taking a step in the negative gradient direction E ,GV (D,E,G). In both cases, the expectation terms of V (D,E,G) are estimated using mini-batches of n samples x(i) pXni=1 and z(i) pZni=1 drawn independently for each update step. Goodfellow et al. (2014) found that an objective in which the real and generated labels Y are swapped provides stronger gradient signal to G. We similarly observed in BiGAN training that an inverse objective provides stronger gradient signal to G and E. For efficiency, we also update all modules D, G, and E simultaneously at each iteration, rather than alternating between D updates and G, E updates. See Appendix B for details.",
      "exclude": false
    },
    {
      "heading": "3.5 GENERALIZED BIGAN",
      "text": "It is often useful to parametrize the output of the generator G and encoder E in a different, usually smaller, space X and Z rather than the original X and Z. For example, for visual feature learning, the images input to the encoder should be of similar resolution to images used in the evaluation. On the other hand, generating high resolution images remains difficult for current generative models. In this situation, the encoder may take higher resolution input while the generator output and discriminator input remain low resolution. We generalize the BiGAN objective V (D,G,E) (3) with functions gX : X 7 X and gZ : Z 7 Z, and encoderE : X 7 Z, generatorG : Z 7 X, and discriminatorD : XZ 7 [0, 1]: ExpX [ EzpE(|x) [logD(gX(x), z )]} {{ } logD(gX(x),E(x)) ] + EzpZ [ ExpG(|z) [log (1D(x , gZ(z)))]} {{ } log(1D(G(z),gZ(z))) ] An identity gX(x) = x and gZ(z) = z (and X = X, Z = Z) yields the original objective. For visual feature learning with higher resolution encoder inputs, gX is an image resizing function that downsamples a high resolution image x X to a lower resolution image x X, as output by the generator. (gZ is identity.) In this case, the encoder and generator respectively induce probability measures PEX and PGZ over regions R of the joint space := X Z, with PEX(R) := X X Z pEX(x, z )1[(x,z)R](gX(x) x) dz dx dx = X pX(x)1[(gX(x),E(x))R] dx, and PGZ defined analogously. For optimal E and G, we can show PEX = PGZ : a generalization of Theorem 1. When E and G are deterministic and optimal, Theorem 2 that E and G invert one another can also be generalized: zZE(x) = gZ(z) G(z) = gX(x) for PX-almost every x X, and xXE(x) = gZ(z) G(z) = gX(x) for PZ-almost every z Z.",
      "exclude": false
    },
    {
      "heading": "4 EVALUATION",
      "text": "We evaluate the feature learning capabilities of BiGANs by first training them unsupervised as described in Section 3.4, then transferring the encoders learned feature representations for use in auxiliary supervised learning tasks. To demonstrate that BiGANs are able to learn meaningful feature representations both on arbitrary data vectors, where the model is agnostic to any underlying structure, as well as very high-dimensional and complex distributions, we evaluate on both permutation-invariant MNIST (LeCun et al., 1998) and on the high-resolution natural images of ImageNet (Russakovsky et al., 2015). In all experiments, each module D, G, and E is a parametric deep (multi-layer) network. The BiGAN discriminator D(x, z) takes data x as its initial input, and at each linear layer thereafter, the latent representation z is transformed using a learned linear transformation to the hidden layer dimension and added to the non-linearity input.",
      "exclude": false
    },
    {
      "heading": "4.1 BASELINE METHODS",
      "text": "Besides the BiGAN framework presented above, we considered alternative approaches to learning feature representations using different GAN variants. Discriminator The discriminatorD in a standard GAN takes data samples x pX as input, making its learned intermediate representations natural candidates as feature representations for related tasks.",
      "exclude": false
    },
    {
      "heading": "97.39 97.30 97.44 97.13 97.58 97.63",
      "text": "This alternative is appealing as it requires no additional machinery, and is the approach used for unsupervised feature learning in Radford et al. (2016). On the other hand, it is not clear that the task of distinguishing between real and generated data requires or benefits from intermediate representations that are useful as semantic feature representations. In fact, if G successfully generates the true data distribution pX(x), D may ignore the input data entirely and predict P (Y = 1) = P (Y = 1|x) = 12 unconditionally, not learning any meaningful intermediate representations. Latent regressor We consider an alternative encoder training by minimizing a reconstruction loss L(z, E(G(z))), after or jointly during a regular GAN training, called latent regressor or joint latent regressor respectively. We use a sigmoid cross entropy loss L as it naturally maps to a uniformly distributed output space. Intuitively, a drawback of this approach is that, unlike the encoder in a BiGAN, the latent regressor encoder E is trained only on generated samples G(z), and never sees real data x pX. While this may not be an issue in the theoretical optimum where pG(x) = pX(x) exactly i.e., G perfectly generates the data distribution pX in practice, for highly complex data distributions pX, such as the distribution of natural images, the generator will almost never achieve this perfect result. The fact that the real data x are never input to this type of encoder limits its utility as a feature representation for related tasks, as shown later in this section.",
      "exclude": false
    },
    {
      "heading": "4.2 PERMUTATION-INVARIANT MNIST",
      "text": "We first present results on permutation-invariant MNIST (LeCun et al., 1998). In the permutationinvariant setting, each 2828 digit image must be treated as an unstructured 784D vector (Goodfellow et al., 2013). In our case, this condition is met by designing each module as a multi-layer perceptron (MLP), agnostic to the underlying spatial structure in the data (as opposed to a convnet, for example). See Appendix C.1 for more architectural and training details. We set the latent distribution pZ = [U(1, 1)]50 a 50D continuous uniform distribution. Table 1 compares the encoding learned by a BiGAN-trained encoder E with the baselines described in Section 4.1, as well as autoencoders (Hinton & Salakhutdinov, 2006) trained directly to minimize either `2 or `1 reconstruction error. The same architecture and optimization algorithm is used across all methods. All methods, including BiGAN, perform at roughly the same level. This result is not overly surprising given the relative simplicity of MNIST digits. For example, digits generated by G in a GAN nearly perfectly match the data distribution (qualitatively), making the latent regressor (LR) baseline method a reasonable choice, as argued in Section 4.1. Qualitative results are presented in Figure 2.",
      "exclude": false
    },
    {
      "heading": "4.3 IMAGENET",
      "text": "Next, we present results from training BiGANs on ImageNet LSVRC (Russakovsky et al., 2015), a large-scale database of natural images. GANs trained on ImageNet cannot perfectly reconstruct the data, but often capture some interesting aspects. Here, each of D, G, and E is a convnet. In all experiments, the encoder E architecture follows AlexNet (Krizhevsky et al., 2012) through the fifth and last convolution layer (conv5). We also experiment with an AlexNet-based discriminator D as a baseline feature learning approach. We set the latent distribution pZ = [U(1, 1)]200 a 200D continuous uniform distribution. Additionally, we experiment with higher resolution encoder input images 112 112 rather than the 64 64 used elsewhere using the generalization described in Section 3.5. See Appendix C.2 for more architectural and training details. Qualitative results The convolutional filters learned by each of the three modules are shown in Figure 3. We see that the filters learned by the encoder E have clear Gabor-like structure, similar to those originally reported for the fully supervised AlexNet model (Krizhevsky et al., 2012). The filters also have similar grouping structure where one half (the bottom half, in this case) is more color sensitive, and the other half is more edge sensitive. (This separation of the filters occurs due to the AlexNet architecture maintaining two separate filter paths for computational efficiency.) In Figure 4 we present sample generations G(z), as well as real data samples x and their BiGAN reconstructions G(E(x)). The reconstructions, while certainly imperfect, demonstrate empirically that the BiGAN encoder E and generator G learn approximate inverse mappings, as shown theoretically in Theorem 2. In Appendix C.2, we present nearest neighbors in the BiGAN learned feature space. ImageNet classification Following Noroozi & Favaro (2016), we evaluate by freezing the first N layers of our pretrained network and randomly reinitializing and training the remainder fully supervised for ImageNet classification. Results are reported in Table 2. VOC classification, detection, and segmentation We evaluate the transferability of BiGAN representations to the PASCAL VOC (Everingham et al., 2014) computer vision benchmark tasks, including classification, object detection, and semantic segmentation. The classification task involves simple binary prediction of presence or absence in a given image for each of 20 object categories. The object detection and semantic segmentation tasks go a step further by requiring the objects to be localized, with semantic segmentation requiring this at the finest scale: pixelwise prediction of object identity. For detection, the pretrained model is used as the initialization for Fast R-CNN (Girshick, 2015) (FRCN) training; and for semantic segmentation, the model is used as the initialization for Fully Convolutional Network (Long et al., 2015) (FCN) training, in each case replacing the AlexNet (Krizhevsky et al., 2012) model trained fully supervised for ImageNet classification. We report results on each of these tasks in Table 3, comparing BiGANs with contemporary approaches to unsupervised (Krahenbuhl et al., 2016) and self-supervised (Doersch et al., 2015; Agrawal et al., 2015; Wang & Gupta, 2015; Pathak et al., 2016) feature learning in the visual domain, as well as the baselines discussed in Section 4.1.",
      "exclude": false
    },
    {
      "heading": "4.4 DISCUSSION",
      "text": "Despite making no assumptions about the underlying structure of the data, the BiGAN unsupervised feature learning framework offers a representation competitive with existing self-supervised and even weakly supervised feature learning approaches for visual feature learning, while still being a purely generative model with the ability to sample data x and predict latent representation z. Furthermore, BiGANs outperform the discriminator (D) and latent regressor (LR) baselines discussed in Section 4.1, confirming our intuition that these approaches may not perform well in the regime of highly complex data distributions such as that of natural images. The version in which the encoder takes a higher resolution image than output by the generator (BiGAN 112 112 E) performs better still, and this strategy is not possible under the LR and D baselines as each of those modules take generator outputs as their input. Although existing self-supervised approaches have shown impressive performance and thus far tended to outshine purely unsupervised approaches in the complex domain of high-resolution images, purely unsupervised approaches to feature learning or pre-training have several potential benefits. BiGAN and other unsupervised learning approaches are agnostic to the domain of the data. The self-supervised approaches are specific to the visual domain, in some cases requiring weak supervision from video unavailable in images alone. For example, the methods are not applicable in the permutation-invariant MNIST setting explored in Section 4.2, as the data are treated as flat vectors rather than 2D images. Furthermore, BiGAN and other unsupervised approaches neednt suffer from domain shift between the pre-training task and the transfer task, unlike self-supervised methods in which some aspect of the data is normally removed or corrupted in order to create a non-trivial prediction task. In the context prediction task (Doersch et al., 2015), the network sees only small image patches the global image structure is unobserved. In the context encoder or inpainting task (Pathak et al., 2016), each image is corrupted by removing large areas to be filled in by the prediction network, creating inputs with dramatically different appearance from the uncorrupted natural images seen in the transfer tasks. Other approaches (Agrawal et al., 2015; Wang & Gupta, 2015) rely on auxiliary information unavailable in the static image domain, such as video, egomotion, or tracking. Unlike BiGAN, such approaches cannot learn feature representations from unlabeled static images. We finally note that the results presented here constitute only a preliminary exploration of the space of model architectures possible under the BiGAN framework, and we expect results to improve significantly with advancements in generative image models and discriminative convolutional networks alike.",
      "exclude": true
    },
    {
      "heading": "ACKNOWLEDGMENTS",
      "text": "The authors thank Evan Shelhamer, Jonathan Long, and other Berkeley Vision labmates for helpful discussions throughout this work. This work was supported by DARPA, AFRL, DoD MURI award N000141110688, NSF awards IIS-1427425 and IIS-1212798, and the Berkeley Artificial Intelligence Research laboratory. The GPUs used for this work were donated by NVIDIA.",
      "exclude": true
    },
    {
      "heading": "APPENDIX A ADDITIONAL PROOFS",
      "text": "A.1 PROOF OF PROPOSITION 1 (OPTIMAL DISCRIMINATOR) Proposition 1 For any E and G, the optimal discriminator DEG := arg maxD V (D,E,G) is the Radon-Nikodym derivative fEG := dPEXd(PEX+PGZ) : 7 [0, 1] of measure PEX with respect to measure PEX + PGZ. Proof. For measures P and Q on space , with P absolutely continuous with respect to Q, the RN derivative fPQ := dPdQ exists, and we have ExP [g(x)] = g dP = g dPdQ dQ = gfPQ dQ = ExQ [fPQ(x)g(x)] . (4) Let the probability measure PEG := PEX+PGZ2 denote the average of measures PEX and PGZ. Both PEX and PGZ are each absolutely continuous with respect to PEG. Hence the RN derivatives fEG := dPEX d(PEX+PGZ) = 12 dPEX dPEG and fGE := dPGZd(PEX+PGZ) = 1 2 dPGZ dPEG exist and sum to 1: fEG + fGE = dPEX d(PEX+PGZ) + dPGZd(PEX+PGZ) = d(PEX+PGZ) d(PEX+PGZ) = 1. (5) We use (4) and (5) to rewrite the objective V (3) as a single expectation under measure PEG: V (D,E,G) = E(x,z)PEX [logD(x, z)] + E(x,z)PGZ [log (1D(x, z))] = E(x,z)PEG [2fEG} {{ } dPEX dPEG (x, z) logD(x, z)] + E(x,z)PEG [2fGE} {{ } dPGZ dPEG (x, z) log (1D(x, z))] = 2E(x,z)PEG [fEG(x, z) logD(x, z) + fGE(x, z) log (1D(x, z))] = 2E(x,z)PEG [fEG(x, z) logD(x, z) + (1 fEG(x, z)) log (1D(x, z))] . Note that arg maxy a log y + (1 a) log(1 y) = a for any a [0, 1]. Thus, DEG = fEG. A.2 PROOF OF PROPOSITION 2 (ENCODER AND GENERATOR OBJECTIVE) Proposition 2 The encoder and generators objective for an optimal discriminator C(E,G) := maxD V (D,E,G) = V (D EG, E,G) can be rewritten in terms of the Jensen-Shannon divergence between measures PEX and PGZ as C(E,G) = 2 DJS (PEX ||PGZ ) log 4. Proof. Using Proposition 1 along with (5) (1DEG = 1 fEG = fGE) we rewrite the objective C(E,G) = maxDV (D,E,G) = V (D EG, E,G) = E(x,z)PEX [logD EG(x, z)] + E(x,z)PGZ [log (1D EG(x, z))] = E(x,z)PEX [log fEG(x, z)] + E(x,z)PGZ [log fGE(x, z)] = E(x,z)PEX [log (2fEG(x, z))] + E(x,z)PGZ [log (2fGE(x, z))] log 4 = DKL (PEX ||PEG ) + DKL (PGZ ||PEG ) log 4 = DKL ( PEX PEX+PGZ 2 ) + DKL ( PGZ PEX+PGZ 2 ) log 4 = 2 DJS (PEX ||PGZ ) log 4. A.3 MEASURE DEFINITIONS FOR DETERMINISTIC E AND G While Theorem 1 and Propositions 1 and 2 hold for any encoder pE(z|x) and generator pG(x|z), stochastic or deterministic, Theorems 2 and 3 assume the encoderE and generatorG are deterministic functions; i.e., with conditionals pE(z|x) = (z E(x)) and pG(x|z) = (xG(z)) defined as functions. For use in the proofs of those theorems, we simplify the definitions of measures PEX and PGZ given in Section 3 for the case of deterministic functions E and G below: PEX(R) = X pX(x) Z pE(z|x)1[(x,z)R] dzdx = X pX(x) ( Z (z E(x))1[(x,z)R] dz ) dx = X pX(x)1[(x,E(x))R] dx PGZ(R) = Z pZ(z) X pG(x|z)1[(x,z)R] dx dz = Z pZ(z) ( X (xG(z))1[(x,z)R] dx ) dz = Z pZ(z)1[(G(z),z)R] dz A.4 PROOF OF THEOREM 2 (OPTIMAL GENERATOR AND ENCODER ARE INVERSES) Theorem 2 If E and G are an optimal encoder and generator, then E = G1 almost everywhere; that is, G(E(x)) = x for PX-almost every x X, and E(G(z)) = z for PZ-almost every z Z. Proof. Let R0X := x X : x 6= G(E(x)) be the region of X in which the inversion property x = G(E(x)) does not hold. We will show that, for optimal E and G, R0X has measure zero under PX (i.e., PX(R0X) = 0) and therefore x = G(E(x)) holds PX-almost everywhere. Let R0 := (x, z) : z = E(x) x R0X be the region of such that (x, E(x)) R0 if and only if x R0X. Well use the definitions of PEX and PGZ for deterministicE andG (Appendix A.3), and the fact that PEX = PGZ for optimal E and G (Theorem 1). PX(R 0 X) = X pX(x)1[xR0X] dx = X pX(x)1[(x,E(x))R0] dx = PEX(R 0) = PGZ(R 0) = Z pZ(z)1[(G(z),z)R0] dz = Z pZ(z)1[z=E(G(z))G(z)R0X] dz = Z pZ(z) 1[z=E(G(z))G(z)6=G(E(G(z)))]} {{ } =0 for any z, as z=E(G(z)) = G(z)=G(E(G(z))) dz = 0. Hence region R0X has measure zero (PX(R 0 X) = 0), and the inversion property x = G(E(x)) holds PX-almost everywhere. An analogous argument shows that R0Z := z Z : z 6= E(G(z)) has measure zero on PZ (i.e., PZ(R 0 Z) = 0) and therefore z = E(G(z)) holds PZ-almost everywhere. A.5 PROOF OF THEOREM 3 (RELATIONSHIP TO AUTOENCODERS) As shown in Proposition 2 (Section 3), the BiGAN objective is equivalent to the Jensen-Shannon divergence between PEX and PGZ. We now go a step further and show that this Jensen-Shannon divergence is closely related to a standard autoencoder loss. Omitting the 12 scale factor, a KL divergence term of the Jensen-Shannon divergence is given as DKL ( PEX PEX+PGZ 2 ) = log 2 + log dPEX d(PEX + PGZ) dPEX = log 2 + log f dPEX, (6) where we abbreviate as f the Radon-Nikodym derivative fEG := dPEXd(PEX+PGZ) [0, 1] defined in Proposition 1 for most of this proof. Well make use of the definitions of PEX and PGZ for deterministic E and G found in Appendix A.3. The integral term of the KL divergence expression given in (6) over a particular region R will be denoted by F (R) := R log dPEX d (PEX + PGZ) dPEX = R log f dPEX. Next we will show that f > 0 holds PEX-almost everywhere, and hence F is always well defined and finite. We then show that F is equivalent to an autoencoder-like reconstruction loss function. Proposition 3 f > 0 PEX-almost everywhere. Proof. Let Rf=0 := (x, z) : f(x, z) = 0 be the region of in which f = 0. Using the definition of the Radon-Nikodym derivative f , the measure PEX(Rf=0) = Rf=0 f d(PEX + PGZ) = Rf=0 0 d(PEX + PGZ) = 0 is zero. Hence f > 0 PEX-almost everywhere. Proposition 3 ensures that log f is defined PEX-almost everywhere, and F (R) is well-defined. Next we will show that F (R) mimics an autoencoder with `0 loss, meaning F is zero for any region in which G(E(x)) 6= x, and non-zero otherwise. Proposition 4 The KL divergence F outside the support of PGZ is zero: F ( \\ supp(PGZ)) = 0. Well first show that in region RS := \\ supp(PGZ), we have f = 1 PEX-almost everywhere. Let Rf 0 has non-zero measure. Then, using the definition of the Radon-Nikodym derivative, PEX(R f 0 and PGZ(Rf=1) > 0. The Radon-Nikodym derivative on Rf=1 is then given by PEX(R f=1) = Rf=1 f d(PEX + PGZ) = Rf=1 1 d(PEX + PGZ) = PEX(R f=1) + PGZ(R f=1), which implies PGZ(Rf=1) = 0 and contradicts the definition of support. Hence Rf=1 = and f 0 here. Note that supp(PEX) = (x, E(x)) : x X supp(PGZ) = (G(z), z) : z Z = R1 := supp(PEX) supp(PGZ) = (x, z) : E(x) = z x X G(z) = x z Z So a point (x, E(x)) is in R1 if x X, E(x) Z, and G(E(x)) = x. (We can omit the x X condition from inside an expectation over PX, as PX-almost all x / X have 0 probability.) Therefore, DKL ( PEX PEX+PGZ 2 ) log 2 = F () = F (R1) = R1 log f(x, z) dPEX = 1[(x,z)R1] log f(x, z) dPEX = E(x,z)PEX [ 1[(x,z)R1] log f(x, z) ] = ExpX [ 1[(x,E(x))R1] log f(x, E(x)) ] = ExpX [ 1[E(x)ZG(E(x))=x] log f(x, E(x)) ] . Finally, with Propositions 3 and 5, we have f (0, 1) PEX-almost everywhere in R1, and therefore log f (, 0), taking a finite and strictly negative value PEX-almost everywhere. An analogous argument (along with the fact that fEG + fGE = 1) lets us rewrite the other KL divergence term DKL ( PGZ PEX+PGZ 2 ) log 2 = EzpZ [ 1[G(z)XE(G(z))=z] log fGE(G(z), z) ] = EzpZ [ 1[G(z)XE(G(z))=z] log (1 fEG(G(z), z)) ] The Jensen-Shannon divergence is the mean of these two KL divergences, giving C(E,G): C(E,G) = 2 DJS (PEX ||PGZ ) log 4 = DKL ( PEX PEX+PGZ 2 ) + DKL ( PGZ PEX+PGZ 2 ) log 4 = ExpX [ 1[E(x)ZG(E(x))=x] log fEG(x, E(x)) ] + EzpZ [ 1[G(z)XE(G(z))=z] log (1 fEG(G(z), z)) ]",
      "exclude": true
    },
    {
      "heading": "APPENDIX B LEARNING DETAILS",
      "text": "In this section we provide additional details on the BiGAN learning protocol summarized in Section 3.4. Goodfellow et al. (2014) found for GAN training that an objective in which the real and generated labels Y are swapped provides stronger gradient signal to G. We similarly observed in BiGAN training that an inverse objective (with the same fixed point characteristics as V ) provides stronger gradient signal to G and E, where (D,G,E) = ExpX [ EzpE(|x) [log (1D(x, z))]} {{ } log(1D(x,E(x))) ] + EzpZ [ ExpG(|z) [logD(x, z)]} {{ } logD(G(z),z) ] . In practice, G and E are updated by moving in the positive gradient direction of this inverse objective E ,G, rather than the negative gradient direction of the original objective. We also observed that learning behaved similarly when all parameters D, G, E were updated simultaneously at each iteration rather than alternating between D updates and G, E updates, so we took the simultaneous updating (non-alternating) approach for computational efficiency. (For standard GAN training, simultaneous updates of D, G performed similarly well, so our standard GAN experiments also follow this protocol.)",
      "exclude": true
    },
    {
      "heading": "APPENDIX C MODEL AND TRAINING DETAILS",
      "text": "In the following sections we present additional details on the models and training protocols used in the permutation-invariant MNIST and ImageNet evaluations presented in Section 4. Optimization For unsupervised training of BiGANs and baseline methods, we use the Adam optimizer (Kingma & Ba, 2015) to compute parameter updates, following the hyperparameters (initial step size = 2 104, momentum 1 = 0.5 and 2 = 0.999) used by Radford et al. (2016). The step size is decayed exponentially to = 2 106 starting halfway through training. The mini-batch size is 128. `2 weight decay of 2.5 105 is applied to all multiplicative weights in linear layers (but not to the learned bias or scale parameters applied after batch normalization). Weights are initialized from a zero-mean normal distribution with a standard deviation of 0.02, with one notable exception: BiGAN discriminator weights that directly multiply z inputs to be added to spatial convolution outputs have initializations scaled by the convolution kernel size e.g., for a 5 5 kernel, weights are initialized with a standard deviation of 0.5, 25 times the standard initialization. Software & hardware We implement BiGANs and baseline feature learning methods using the Theano (Theano Development Team, 2016) framework, based on the convolutional GAN implementation provided by Radford et al. (2016). ImageNet transfer learning experiments (Section 4.3) use the Caffe (Jia et al., 2014) framework, per the Fast R-CNN (Girshick, 2015) and FCN (Long et al., 2015) reference implementations. Most computation is performed on an NVIDIA Titan X or Tesla K40 GPU. C.1 PERMUTATION-INVARIANT MNIST In all permutation-invariant MNIST experiments (Section 4.2), D, G, and E each consist of two hidden layers with 1024 units. The first hidden layer is followed by a non-linearity; the second is followed by (parameter-free) batch normalization (Ioffe & Szegedy, 2015) and a non-linearity. The second hidden layer in each case is the input to a linear prediction layer of the appropriate size. In D and E, a leaky ReLU (Maas et al., 2013) non-linearity with a leak of 0.2 is used; in G, a standard ReLU non-linearity is used. All models are trained for 400 epochs. C.2 IMAGENET In all ImageNet experiments (Section 4.3), the encoder E architecture follows AlexNet (Krizhevsky et al., 2012) through the fifth and last convolution layer (conv5), with local response normalization (LRN) layers removed and batch normalization (Ioffe & Szegedy, 2015) (including the learned scaling and bias) with leaky ReLU non-linearity applied to the output of each convolution at unsupervised training time. (For supervised evaluation, batch normalization is not used, and the pre-trained scale and bias is merged into the preceding convolutions weights and bias.) In most experiments, both the discriminatorD and generatorG architecture are those used by Radford et al. (2016), consisting of a series of four 5 5 convolutions (or deconvolutions fractionallystrided convolutions for the generator G) applied with 2 pixel stride, each followed by batch normalization and rectified non-linearity. The sole exception is our discriminator baseline feature learning experiment, in which we let the discriminatorD be the AlexNet variant described above. Generally, using AlexNet (or similar convnet architecture) as the discriminator D is detrimental to the visual fidelity of the resulting generated images, likely due to the relatively large convolutional filter kernel size applied to the input image, as well as the max-pooling layers, which explicitly discard information in the input. However, for fair comparison of the discriminators feature learning abilities with those of BiGANs, we use the same architecture as used in the BiGAN encoder. Preprocessing To produce a data sample x, we first sample an image from the database, and resize it proportionally such that its shorter edge has a length of 72 pixels. Then, a 64 64 crop is randomly selected from the resized image. The crop is flipped horizontally with probability 12 . Finally, the crop is scaled to [1, 1], giving the sample x. Timing A single epoch (one training pass over the 1.2 million images) of BiGAN training takes roughly 40 minutes on a Titan X GPU. Models are trained for 100 epochs, for a total training time of under 3 days. Nearest neighbors In Figure 5 we present nearest neighbors in the feature space of the BiGAN encoder E learned in unsupervised ImageNet training.",
      "exclude": true
    }
  ],
  "fewShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": false,
        "confidence": 0.92,
        "primary_reason": "Novel bidirectional GAN framework with strong theoretical contributions (inverse mapping guarantee, JS divergence characterization), comprehensive experiments across MNIST/ImageNet/VOC, and significant impact on unsupervised feature learning."
      },
      "token": {
        "prompt_tokens": 6411,
        "completion_tokens": 81,
        "total_tokens": 6492
      },
      "time": "2026-02-08T22:20:04.104742+00:00"
    },
    {
      "model": "gpt-5.2",
      "decision": {
        "rejection": false,
        "confidence": 0.78,
        "primary_reason": "Introduces BiGANs, a clear and novel extension of GANs that jointly learns an encoder and generator via adversarial matching of joint (x,z) distributions, with solid theory (optimality implies E and G are inverses a.e.) and convincing large-scale representation-learning results on ImageNet/VOC competitive with contemporary unsupervised/self-supervised methods."
      },
      "token": {
        "prompt_tokens": 8108,
        "completion_tokens": 99,
        "total_tokens": 8207
      },
      "time": "2026-02-09T20:22:17.642730+00:00"
    }
  ],
  "test": false
}