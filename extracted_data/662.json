{
  "id": "662",
  "title": "Dynamic Neural Turing Machine with Continuous and Discrete Addressing Schemes",
  "abstract": "In this paper, we extend neural Turing machine (NTM) into a dynamic neural Turing machine (D-NTM) by introducing a trainable memory addressing scheme. This addressing scheme maintains for each memory cell two separate vectors, content and address vectors. This allows the D-NTM to learn a wide variety of location-based addressing strategies including both linear and nonlinear ones. We implement the D-NTM with both continuous, differentiable and discrete, non-differentiable read/write mechanisms. We investigate the mechanisms and effects for learning to read and  write to a memory through experiments on Facebook bAbI tasks using both a feedforward and GRU-controller. The D-NTM is evaluated on a set of Facebook bAbI tasks and shown to outperform NTM and LSTM baselines. We also provide further experimental results on sequential MNIST, associative recall and copy tasks.",
  "accepted": false,
  "zeroShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": true,
        "confidence": 0.72,
        "primary_reason": "Limited novelty and experimental validation. While the paper extends NTM with learnable address vectors and discrete addressing via REINFORCE, the core contributions are incremental. The experimental evaluation is weak: bAbI results significantly underperform published baselines (MemN2N, DMN+), sequential MNIST shows marginal improvements, and toy tasks lack generalization testing. The paper lacks theoretical justification for design choices and doesn't convincingly demonstrate when/why D-NTM should be preferred over existing methods."
      },
      "token": {
        "prompt_tokens": 6828,
        "completion_tokens": 136,
        "total_tokens": 6964
      },
      "time": "2026-02-05T23:09:08.939998+00:00"
    }
  ],
  "article": [
    {
      "heading": "1 INTRODUCTION",
      "text": "Designing general-purpose learning algorithms is one of the long-standing goals of artificial intelligence. Despite the success of deep learning in this area (see, e.g., (Goodfellow et al., 2016)) there are still a set of complex tasks that are not well addressed by conventional neural networks. Those tasks often require a neural network to be equipped with an explicit, external memory in which a larger, potentially unbounded, set of facts need to be stored. They include, but are not limited to, episodic question-answering (Weston et al., 2015b; Hermann et al., 2015; Hill et al., 2015), compact algorithms (Zaremba et al., 2015), dialogue (Serban et al., 2016; Vinyals & Le, 2015) and video caption generation (Yao et al., 2015). Recently two promising approaches based on neural networks to this type of tasks have been proposed. Memory networks (Weston et al., 2015b) explicitly store all the facts, or information, available for each episode in an external memory (as continuous vectors) and use the attention-based mechanism to index them when returning an output. On the other hand, neural Turing machines (NTM, (Graves et al., 2014)) read each fact in an episode and decides whether to read, write the fact or do both to the external, differentiable memory. A crucial difference between these two models is that the memory network does not have a mechanism to modify the content of the external memory, while the NTM does. In practice, this leads to easier learning in the memory network, which in turn resulted in it being used more in real tasks (Bordes et al., 2015; Dodge et al., 2015). On the contrary, the NTM has mainly been tested on a series of small-scale, carefully-crafted tasks such as copy and associative recall. The NTM, however is more expressive, precisely because it can store and modify the internal state of the network as it processes an episode. The original NTM supports two modes of addressing (which can be used simultaneously.) They are content-based and location-based addressing. We notice that the location-based strategy is based on linear addressing. The distance between each pair of consecutive memory cells is fixed to a constant. We address this limitation, in this paper, by introducing a learnable address vector for each memory cell of the NTM with least recently used memory addressing mechanism, and we call this variant a dynamic neural Turing machine (D-NTM). We evaluate the proposed D-NTM on the full set of Facebook bAbI task (Weston et al., 2015b) using either continuous, differentiable attention or discrete, non-differentiable attention (Zaremba & Sutskever, 2015) as an addressing strategy. Our experiments reveal that it is possible to use the discrete, non-differentiable attention mechanism, and in fact, the D-NTM with the discrete attention and GRU controller outperforms the one with the continuous attention. After we published our paper on arXiv, a new extension of NTM called DNC (Graves et al., 2016) has also provided results on bAbI task as well. We also provide results on sequential-MNIST and algorithmic tasks proposed by (Graves et al., 2014) in order to investigate the ability of our model when dealing with long-term dependencies. Our Contributions 1. We propose a generalization of Neural Turing Machine called a dynamic neural Turing machine (D-NTM) which employs a learnable and location-based addressing. 2. We demonstrate the application of neural Turing machines on a more natural and less toyish task: episodic question-answering besides the toy tasks. We provide detailed analysis of our model on this task. 3. We propose to use the discrete attention mechanism and empirically show that, it can outperform the continuous attention based addressing for episodic QA task. 4. We propose a curriculum strategy for our model with the feedforward controller and discrete attention that improves our results significantly.",
      "exclude": true
    },
    {
      "heading": "2 DYNAMIC NEURAL TURING MACHINE",
      "text": "The proposed dynamic neural Turing machine (D-NTM) extends the neural Turing machine (NTM, (Graves et al., 2014)) which has a modular design. The NTM consists of two main modules, a controller and, a memory. The controller, which is often implemented as a recurrent neural network, issues a command to the memory so as to read, write to and erase a subset of memory cells. Although the memory was originally envisioned as an integrated module, it is not necessary, and the memory may be an external, black box (Zaremba & Sutskever, 2015).",
      "exclude": false
    },
    {
      "heading": "2.1 CONTROLLER",
      "text": "At each time step t, the controller (1) receives an input value xt, (2) addresses and reads the memory and creates the content vector t, (3) erases/writes a portion of the memory, (4) updates its own hidden state ht, and (5) outputs a value yt (if needed.) In this paper, we use both a gated recurrent unit (GRU, (Cho et al., 2014)) and a feedforward-controller to implement the controller such that for a GRU controller ht = GRU(xt,ht1, t) (1) or for a feedforward-controller ht = (xt, t). (2)",
      "exclude": false
    },
    {
      "heading": "2.2 MEMORY",
      "text": "We use a rectangular matrix M RN(dc+da) to denote N memory cells. Unlike the original NTM, we partition each memory cell vector into two parts: M = [A;C] . The first part A RNda is a learnable address matrix, and the second C RNdc a content matrix. In other words, each memory cell mi is now mi = [ai; ci] . The address part ai is considered a model parameter that is updated during training. During inference, the address part is not overwritten by the controller and remains constant. On the other hand, the content part ci is both read and written by the controller both during training and inference. At the beginning of each episode, the content part of the memory is refreshed to be an all-zero matrix, C0 = 0. This introduction of the learnable address portion for each memory cell allows the model to learn sophisticated location-based addressing strategies. A similar addressing mechanism is also explored in (Reed & de Freitas, 2015) in the context of learning program traces.",
      "exclude": false
    },
    {
      "heading": "2.3 MEMORY ADDRESSING",
      "text": "Memory addressing in the D-NTM is equivalent to computing an N -dimensional address vector. The DNTM computes three such vectors for respectively reading wt RN , erasing et Rdc and writing ut RN . Specifically for writing, the controller further computes a candidate memory content vector ct Rdc based on its current hidden state of the controller ht Rdh and the input of the controller scaled with a scalar gate t which is a function of the hidden state and the input of the controller as well, see Eqn 4. t = f(ht,xt), (3) ct = ReLU(Wmht + tWxxt + bm). (4) Reading With the read vector wt, the content vector read from the memory t Rda+dc is retrieved by t = (wt)>Mt1, (5) where wt is a row vector. Erasing and Writing Given the erase, write and candidate memory content vectors (et, utj , and ct respectively) generated by a simple MLP conditioned on the hidden state of the controller ht, the memory matrix is updated by, Ct[j] = (1 etutj) Ct1[j] + utj ct. (6) where the subscript j in Ct[j] denotes the j-th row of the content part Ct of the memory matrix Mt. No Operation (NOP) As found in (Joulin & Mikolov, 2015), an additional NOP action might be beneficial for the controller not to access the memory once in a while. We model this situation by designating one memory cell as a NOP cell. Reading or writing from this memory cell is ignored.",
      "exclude": false
    },
    {
      "heading": "2.4 LEARNING",
      "text": "Once the proposed D-NTM is executed, it returns the output distribution p(y|x1, . . . ,xT ). As a result, we define a cost function as the negative log-likelihood: C() = 1 N N n=1 log p(yn|xn1 , . . . ,xnT ), (7) where is a set of all the parameters. As the proposed D-NTM, just like the original NTM, is fully end-to-end differentiable, we can compute the gradient of this cost function by using backpropagation and learn the parameters of the model with a gradient-based optimization algorithm, such as stochastic gradient descent, to train it end-to-end.",
      "exclude": false
    },
    {
      "heading": "3 ADDRESSING MECHANISM",
      "text": "",
      "exclude": false
    },
    {
      "heading": "3.1 ADDRESS VECTORS",
      "text": "Each of the address vectors (both read and write) is computed in the same way. The way they are computed are very similar to the content based addressing in (Graves et al., 2014). First, the controller computes a key vector: kt = W>k h t + bk, where Wk RN(da+dc) and bk Rda+dc if the read head is being computed, otherwise Wk RNdc and bk Rdc if the write head weights are being computed. They can be the parameters for a specific head (either read or write.) Also, the sharpening factor t R1 is computed as: softplus(x) = log(exp(x) + 1) (8) t = softplus(u> h t + b) + 1. (9) u and b are the parameters of the sharpening t. The address vector is then computed by, zti = tS ( kt,mti ) (10) wti = exp(zti) j exp(z t j) , (11) where the similarity function S R0 is defined as S (x,y) = x y (||x||||y||+ ) .",
      "exclude": false
    },
    {
      "heading": "3.2 MULTI-STEP ADDRESSING",
      "text": "At each time-step, controller may require more than one-step for accessing to the memory. The original NTM addresses this by implementing multiple sets of read, erase and write heads. In this paper, we explore an option of allowing each head to operate more than once at each time step, similar to the multi-hop mechanism from the end-to-end memory network (Sukhbaatar et al., 2015).",
      "exclude": false
    },
    {
      "heading": "3.3 DYNAMIC LEAST RECENTLY USED ADDRESSING",
      "text": "We introduce a memory addressing schema that can learn to put more emphasis on the least recently used (LRU) memory locations. As observed in (Santoro et al., 2016; Rae et al., 2016), we find it easier to learn the write operations with the use of LRU addressing. To learn a LRU based addressing, first we compute the exponentially moving averages of the logits (zt) as vt, vt = 0.1vt1 + 0.9zt. We rescale the accumulated vt with t, such that the controller adjusts the influence of how much previously written memory locations should effect the attention weights of a particular time-step. Next, we subtract vt from zt in order to reduce the weights of previously read or written memory locations. t is a shallow MLP with a scalar output and it is conditioned on the hidden state of the controller. t is parametrized with the parameters u and b , t = sigmoid(u> ht + b), (12) wt = softmax(zt tvt1). (13) This addressing method increases the weights of the least recently used rows of the memory. The magnitude of the influence of the least-recently used memory locations is being learned and adjusted with t. Our LRU addressing is dynamic due to the models ability to switch between pure content-based addressing and LRU. During the training, we do not backpropagate through vt. Due to the dynamic nature of this addressing mechanism, it can be used for both read and write operations. If needed, the model will automatically learn to disable LRU while reading from the memory.",
      "exclude": false
    },
    {
      "heading": "4 GENERATING DISCRETE ADDRESS VECTORS",
      "text": "In this section, we describe the discrete attention based addressing strategy. Discrete Addressing Let us use w to denote an address vector (either read, write or erase) at time t. By definition in Eq. (10), every element in this address vector is positive and sums up to one. In other words, we can treat this vector as the probabilities of a categorical distribution C(w) with dim(w) choices: p(j) = wj , where wj is the j-th element of w. We can readily sample from this categorical distribution and form an one-hot vector w such that wk = I(k = j), where j C(w), and I is an indicator function. Training We use this sampling-based strategy for all the heads during training. This clearly makes the use of backpropagation infeasible to compute the gradient, as the sampling procedure is not differentiable. Thus, we use REINFORCE (Williams, 1992) together with the three variance reduction techniquesglobal baseline, input-dependent baseline and variance normalization suggested in (Mnih & Gregor, 2014). Let us define R(x) = log p(y|x1, . . . ,xT ) as a reward. We first center and re-scale the reward by R(x) = R(x) b 2 + , where b and is running average and standard deviation of R. We can further center it for each input x separately, i.e., R(x) R(x) b(x), where b(x) is computed by a baseline network which takes as input x and predicts its estimated reward. The baseline network is trained to minimize the Huber loss (Huber, 1964) between the true reward R(x) and the predicted reward b(x). We use the Huber loss, which is defined by H(x) = x2 for |x| , (2|x| ), otherwise, due to its robustness. As a further measure to reduce the variance, we regularize the negative entropy of all those category distributions to facilitate a better exploration during training (Xu et al., 2015). Then, the cost function for each training example is approximated as Cn() = log p(y|x1:T , w1:J , u1:J , e1:J) J j=1 R(xn)(log p(wj |x1:T ) + log p(uj |x1:T ) + log p(ej |x1:T )) H J j=1 (H(wj |x1:T ) +H(uj |x1:T ) +H(ej |x1:T )). where J is the number of addressing steps, H is the entropy regularization coefficient, andH denotes the entropy. Inference Once training is over, we switch to a deterministic strategy. We simply choose an element of w with the largest value to be the index of the target memory cell, such that wk = I(k = argmax(w)). Curriculum Learning for the Discrete Attention Training discrete attention with feed-forward controller and REINFORCE is challenging. We propose to use a curriculum strategy for training with the discrete attention in order to tackle this problem. For each minibatch, we sample from a binomial distribution with the probability pt, t Bin(pt). The model will either use the discrete or the continuous-attention based on the t. We start the training procedure with p0 = 1 and during the training pt is annealed to 0 by setting pt = p 0 1+t . We can rewrite the weights wt as in Equation 14, where it is expressed as the combination of continuous attention weights wt and discrete attention weights wt with t being a binary variable that chooses to use one of them, wt twt + (1 t)wt. (14) By using this curriculum learning strategy, at the beginning of the training, the model learns to use the memory mainly with the continuous attention. As we anneal the pt, the model will rely more on the discrete attention.",
      "exclude": false
    },
    {
      "heading": "5 REGULARIZING DYNAMIC NEURAL TURING MACHINES",
      "text": "When the controller of D-NTM is a powerful recurrent neural network, it is important to regularize training of the D-NTM so as to avoid suboptimal solutions in which the D-NTM ignores the memory and works as a simple recurrent neural network. Read-Write Consistency Regularizer One such suboptimal solution we have observed in our preliminary experiments with the proposed D-NTM is that the D-NTM uses the address part A of the memory matrix simply as an additional weight matrix, rather than as a means to accessing the content part C. We found that this pathological case can be effectively avoided by encouraging the read head to point to a memory cell which has also been pointed by the write head. This can be implemented as the following regularization term: Rrw(w,u) = T t=1 ||1 ( 1 t t t=1 ut) >wt ||22 (15) In the equations above, ut is the write and wt is the read weights. Next Input Prediction as Regularization Temporal structure is a strong signal that should be exploited by the controller based on a recurrent neural network. We exploit this structure by letting the controller predict the input in the future. We maximize the predictability of the next input by the controller during training. This is equivalent to minimizing the following regularizer: Rpred(W) = log p(ft+1|ft,wt,ut,Mt;W)) where ft is the current input and ft+1 is the input at next timestep. We found this regularizer to be effective in our preliminary experiments and use it for bAbI tasks.",
      "exclude": false
    },
    {
      "heading": "6 RELATED WORK",
      "text": "A recurrent neural network (RNN), which is used as a controller in the proposed D-NTM, has an implicit memory in the form of recurring hidden states. Even with this implicit memory, a vanilla RNN is however known to have difficulties in storing information for long time-spans (Bengio et al., 1994; Hochreiter, 1991). Long short-term memory (LSTM, (Hochreiter & Schmidhuber, 1997)) and gated recurrent units (GRU, (Cho et al., 2014)) have been found to address this issue. However all these models based solely on RNNs have been found to be limited when they are used to solve, e.g., algorithmic tasks and episodic question-answering. In addition to the finite random access memory of the neural Turing machine, based on which the D-NTM is designed, other data structures have been proposed as external memory for neural networks. In (Sun et al., 1997; Grefenstette et al., 2015; Joulin & Mikolov, 2015), a continuous, differentiable stack was proposed. In (Zaremba et al., 2015; Zaremba & Sutskever, 2015), grid and tape storages are used. These approaches differ from the NTM in that their memory is unbounded and can grow indefinitely. On the other hand, they are often not randomly accessible. Memory networks (Weston et al., 2015b) form another family of neural networks with external memory. In this class of neural networks, information is stored explicitly as it is (in the form of its continuous representation) in the memory, without being erased or modified during an episode. Memory networks and their variants have been applied to various tasks successfully (Sukhbaatar et al., 2015; Bordes et al., 2015; Dodge et al., 2015; Xiong et al., 2016). Miller et al. (2016) have also independently proposed the idea of having separate key and value vectors for memory networks. Another related family of models is the attention-based neural networks. Neural networks with continuous or discrete attention over an input have shown promising results on a variety of challenging tasks, including machine translation (Bahdanau et al., 2015; Luong et al., 2015), speech recognition (Chorowski et al., 2015), machine reading comprehension (Hermann et al., 2015) and image caption generation (Xu et al., 2015). The latter two, the memory network and attention-based networks, are however clearly distinguishable from the D-NTM by the fact that they do not modify the content of the memory.",
      "exclude": true
    },
    {
      "heading": "7 EXPERIMENTS",
      "text": "We provide experimental results to demonstrate the abilities of our model, first on Facebook bAbI task (Weston et al., 2015a). We give detailed analysis and experimental results on this task. We also compare different variations of NTM on bAbI tasks. We have performed experiments on sequential permuted MNIST (Le et al., 2015) and on toy tasks to compare other published models on these tasks with a recurrent controller. The details of our experiments are provided in the supplementary material.",
      "exclude": false
    },
    {
      "heading": "7.1 EPISODIC QUESTION-ANSWERING: BABI TASKS",
      "text": "In this section, we evaluate the proposed D-NTM on the recently proposed episodic question-answering task called Facebook bAbI. We use the dataset with 10k training examples per sub-task provided by Facebook.1 For each episode, the D-NTM reads a sequence of factual sentences followed by a question, all of which are given as natural language sentences. The D-NTM is expected to store and retrieve relevant information in the memory in order to answer the question based on the presented facts. Exact implementation details and hyper-parameter settings are provided in the appendix.",
      "exclude": false
    },
    {
      "heading": "7.1.1 GOALS",
      "text": "The goal of this experiment is three-fold. First, we present for the first time the performance of a memory-based network that can both read and write dynamically on the Facebook bAbI tasks2. We aim to understand whether a model that has to learn to write an incoming fact to the memory, rather than storing it as it is, is able to work well, and to do so, we compare both the original NTM and proposed D-NTM against an LSTM-RNN. Second, we investigate the effect of having to learn how to write. The fact that the NTM needs to learn to write likely has adverse effect on the overall performance, when compared to, for instance, end-to-end memory networks (MemN2N, (Sukhbaatar et al., 2015)) and dynamic memory network (DMN+, (Xiong et al., 2016)) both of which simply store the incoming facts as they are. We quantify this effect in this experiment. Lastly, we show the effect of the proposed learnable addressing scheme. We further explore the effect of using a feedforward controller instead of the GRU controller. In addition to the explicit memory, the GRU controller can use its own internal hidden state as the memory. On the other hand, the feedforward controller must solely rely on the explicit memory, as it is the only memory available.",
      "exclude": false
    },
    {
      "heading": "7.1.2 RESULTS AND ANALYSIS",
      "text": "In Table 1, we first observe that the NTMs are indeed capable of solving this type of episodic question-answering better than the vanilla LSTM-RNN. Although the availability of explicit memory in the NTM has already suggested this result, we note that this is the first time neural Turing machines have been used in this specific task. All the variants of NTM with the GRU controller outperform the vanilla LSTM-RNN. However, not all of them perform equally well. First, it is clear that the proposed dynamic NTM (D-NTM) using the GRU controller outperforms the original NTM with the GRU controller (NTM, CBA only NTM vs. continuous D-NTM, Discrete D-NTM). As discussed earlier, the learnable addressing scheme of the D-NTM allows the controller to access the memory slots by location in a potentially nonlinear way. We expect it to help with tasks that have non-trivial access patterns, and as anticipated, we see a large gain with the D-NTM over the original NTM in the tasks of, for instance, 12 - Conjunction and 17 - Positional Reasoning. Among the recurrent variants of the proposed D-NTM, we notice significant improvements by using discrete addressing over using continuous addressing. We conjecture that this is due to certain types of tasks that require precise/sharp retrieval of a stored fact, in which case continuous addressing is in disadvantage over discrete addressing. This is evident from the observation that the D-NTM with discrete addressing significantly outperforms that with continuous addressing in the tasks of 8 - 1 https://research.facebook.com/researchers/1543934539189348 2Similar experiments were done in the recently published (Graves et al., 2016), but D-NTM results for bAbI tasks were already available in arxiv by that time. Lists/Sets and 11 - Basic Coreference. Furthermore, this is in line with an earlier observation in (Xu et al., 2015), where discrete addressing was found to generalize better in the task of image caption generation. In Table 2, we also observe that the D-NTM with the feedforward controller and discrete attention performs worse than LSTM and D-NTM with continuous-attention. However, when the proposed curriculum strategy from Sec. 4 is used, the average test error drops from 68.30 to 37.79. We empirically found training of the feedforward controller more difficult than that of the recurrent controller. We train our feedforward controller based models four times longer (in terms of the number of updates) than the recurrent controller based ones in order to ensure that they are converged for most of the tasks. On the other hand, the models trained with the GRU controller overfit on bAbI tasks very quickly. For example, on tasks 3 and 16 the feedforward controller based model underfits (i.e., high training loss) at the end of the training, whereas with the same number of units the model with the GRU controller can overfit on those tasks after 3,000 updates only. When our results are compared to the variants of the memory network Weston et al. (2015b) (MemN2N and DMN+), we notice a significant performance gap. We attribute this gap to the difficulty in learning to manipulate and store a complex input. We also provide further experiments investigating different extensions on D-NTM in the appendix. 7.2 SEQUENTIAL pMNIST In sequential MNIST task, the pixels of the MNIST digits are provided to the model in scan line order, left to right and top to bottom (Le et al., 2015). At the end of sequence of pixels, the model predicts the label of the digit in the sequence of pixels. We experiment D-NTM on the variation of sequential MNIST where the order of the pixels is randomly shuffled, we call this task as permuted MNIST (pMNIST). An important contribution of this task to our paper, in particular, is to measure the models ability to perform well when dealing with long-term dependencies. We report our results in Table 33, we observe improvements over other models that we compare against. In Table 3, discrete addressing with MAB refers to D-NTM model using REINFORCE with baseline computed from moving averages of the reward. Discrete addressing with IB refers to D-NTM using REINFORCE with input-based baseline.",
      "exclude": false
    },
    {
      "heading": "7.3 NTM TOY TASKS",
      "text": "We explore the possibility of using D-NTM to solve algorithmic tasks such as copy and associative recall tasks. We train our model on the same lengths of sequences that is experimented in (Graves et al., 2014). We report our results in Table 4. We find out that D-NTM using continuous-attention can successfully learn the Copy and Associative Recall tasks. In Table 4, we train our model on sequences of the same length as the experiments in (Graves et al., 2014) and test the model on the sequences of the maximum length seen during the training. We consider model to be successful on copy or associative recall if its validation cost (binary cross-entropy) is lower than 0.02 over the sequences of maximum length seen during the training. We set the threshold to 0.02 to determine whether a model is successful on a task. Because empirically we observe that the models have higher validation costs perform badly in terms of generalization over the longer sequences. D-NTM discrete model in this table is trained with REINFORCE using moving averages to estimate the baseline. Test Acc D-NTM discrete MAB 89.6 D-NTM discrete IB 92.3 Soft D-NTM 93.4 NTM 90.9 I-RNN (Le et al., 2015) 82.0 Zoneout (Krueger et al., 2016) 93.1 LSTM (Krueger et al., 2016) 89.8 Unitary-RNN (Arjovsky et al., 2015) 91.4 Recurrent Dropout (Krueger et al., 2016) 92.5 Table 3: Sequential pMNIST. Copy Tasks Associative Recall Soft D-NTM Success Success D-NTM discrete Success Failure NTM Success Success Table 4: NTM Toy Tasks.",
      "exclude": false
    },
    {
      "heading": "8 CONCLUSION AND FUTURE WORK",
      "text": "In this paper we extend neural Turing machines (NTM) by introducing a learnable addressing scheme which allows the NTM to be capable of performing highly nonlinear location-based addressing. This extension, to which we refer by dynamic NTM (D-NTM), is extensively tested with various configurations, including different addressing mechanisms (continuous vs. discrete) and different number of addressing steps, on the Facebook bAbI tasks. This is the first time an NTM-type model was tested on this task, and we observe that the NTM, especially the proposed D-NTM, performs better than vanilla LSTM-RNN. Furthermore, the experiments revealed that the discrete, discrete addressing works better than the continuous addressing with the GRU controller, and our analysis reveals that this is the case when the task requires precise retrieval of memory content. Our experiments show that the NTM-based models can be weaker than other variants of memory networks which do not learn but have an explicit mechanism of storing incoming facts as they are. We conjecture that this is due to the difficulty in learning how to write, manipulate and delete the content of memory. Despite this difficulty, we find the NTM-based approach, such as the proposed D-NTM, 3Let us note that, the current state of art on this task is recurrent batch normalization with LSTM (Cooijmans et al., 2016) with 95.6% accuracy. It is possible to use recurrent batch normalization in our model and potentially improve our results on this task as well. to be a better, future-proof approach, because it can scale to a much longer horizon (where it becomes impossible to explicitly store all the experiences.) On pMNIST task, we show that our model can outperform other similar type of approaches proposed to deal with the long-term dependencies. On copy and associative recall tasks, we show that our model can solve the algorithmic problems that are proposed to solve with NTM type of models. The success of both the learnable address and the discrete addressing scheme suggests two future research directions. First, we should try both of these schemes in a wider array of memory-based models, as they are not specific to the neural Turing machines. Second, the proposed D-NTM needs to be evaluated on a diverse set of applications, such as text summarization (Rush et al., 2015), visual questionanswering (Antol et al., 2015) and machine translation, in order to make a more concrete conclusion.",
      "exclude": true
    },
    {
      "heading": "A EXPERIMENTAL DETAILS",
      "text": "A.1 MODEL AND TRAINING DETAILS FOR BABI We use the same hyperparameters for all the tasks for a given model. A.1.1 FACT REPRESENTATION We use a recurrent neural network with GRU units to encode a variable-length fact into a fixed-size vector representation. This allows the D-NTM to exploit the word ordering in each fact, unlike when facts are encoded as bag-of-words vectors. A.1.2 CONTROLLER We experiment with both a recurrent and feedforward neural network as the controller that generates the read and write weights. The controller has 180 units. We train our feed-forward controller using noisy-tanh activation function (Gulcehre et al., 2016) since we were experiencing training difficulties with sigmoid and tanh activation functions. We use both single-step and three-steps addressing with our GRU controller. A.1.3 MEMORY The memory contains 120 memory cells. Each memory cell consists of a 16-dimensional address part and 28-dimensional content part. A.1.4 TRAINING DETAILS We set aside a random 10% of the training examples as a validation set for each sub-task and use it for early-stopping and hyperparameter search. We train one D-NTM for each sub-task, using Adam (Kingma & Ba, 2014) with its learning rate set to 0.003 and 0.007 respectively for GRU and Feedforward controller. The size of each minibatch is 160, and each minibatch is constructed uniform-randomly from the training set. A.2 MODEL AND TRAINING DETAILS FOR SEQUENTIAL MNIST On sequential MNIST task we try to keep the capacity of our model to be close to our baselines. We use 100 GRU units in the controller and each content vector of size 8 and with address vectors of size 8. We use a learning rate of 1e 3 and trained the model with adam optimizer. We did not use the read and write consistency regularization in any of our models. A.3 MODEL AND TRAINING DETAILS FOR TOY TASKS On both copy and associative recall tasks, we try to keep the capacity of our model to be close to our baselines. We use 100 GRU units in the controller and each content vector of has a size of 8 and using address vector of size 8. We use a learning rate of 1e 3 and trained the model with adam optimizer. We did not use the read and write consistency regularization in any of our models. For the model with the discrete attention we use REINFORCE with baseline computed using moving averages. B VISUALIZATION OF DISCRETE ATTENTION We visualize the attention of D-NTM with GRU controller with discrete attention in Figure 2. From this example, we can see that D-NTM has learned to find the correct supporting fact even without any supervision for the particular story in the visualization.",
      "exclude": false
    },
    {
      "heading": "C LEARNING CURVES FOR THE RECURRENT CONTROLLER",
      "text": "In Figure 3, we compare the learning curves of the continuous and discrete attention D-NTM model with recurrent controller on Task 1. Surprisingly, the discrete attention D-NTM converges faster than the continuous-attention model. The main difficulty of learning continuous-attention is due to the fact that learning to write with continuous-attention can be challenging.",
      "exclude": false
    },
    {
      "heading": "D A COMPARISON BETWEEN THE LEARNING",
      "text": "CURVES OF INPUT BASED BASELINE AND REGULAR BASELINE ON pMNIST In Figure 4, we show the learning curves of input-based-baseline (ibb) and regular REINFORCE with moving averages baseline (mab) on the pMNIST task. We observe that input-based-baseline in general is much easier to optimize and converges faster as well. But it can quickly overfit to the task as well.",
      "exclude": false
    },
    {
      "heading": "E TRAINING WITH CONTINUOUS-ATTENTION AND TESTING WITH DISCRETE-ATTENTION",
      "text": "In Table 5, we provide results investigating the effects of using discrete attention model at the test-time for a model trained with feed-forward controller and continuous attention. Discrete D-NTM model bootstraps the discrete attention with the continuous attention, using the curriculum method that we have introduced in Section Curriculum Learning for the Discrete Attention. Discrete D-NTM model is the continuous-attention model which uses discrete-attention at the test time. We observe that the Discrete D-NTM model which is trained with continuous-attention outperforms Discrete D-NTM model.",
      "exclude": false
    },
    {
      "heading": "F D-NTM WITH BOW FACT REPRESENTATION",
      "text": "In Table 6, we provide results for D-NTM using BoW with positional encoding (PE) Sukhbaatar et al. (2015) as the representation of the input facts. The facts representations are provided as an input to the GRU controller. In agreement to our results with the GRU fact representation, with the BoW fact representation we observe improvements with multi-step of addressing over single-step and discrete addressing over continuous addressing.",
      "exclude": false
    }
  ],
  "fewShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": false,
        "confidence": 0.72,
        "primary_reason": "Novel extensions to NTM with learnable addressing (continuous/discrete), dynamic LRU mechanism, and curriculum learning strategy. Solid experimental validation across multiple tasks (bAbI, pMNIST, toy tasks) with meaningful ablations and analysis."
      },
      "token": {
        "prompt_tokens": 6990,
        "completion_tokens": 90,
        "total_tokens": 7080
      },
      "time": "2026-02-08T22:39:14.456709+00:00"
    }
  ],
  "test": false
}