{
  "id": "630",
  "title": "Efficient Summarization with Read-Again and Copy Mechanism",
  "abstract": "Encoder-decoder models have been widely used to solve sequence to sequence prediction tasks. However current approaches suffer from two shortcomings. First, the encoders compute a representation of each word taking into account only the history of the words it has read so far, yielding suboptimal representations. Second, current models utilize large vocabularies in order to minimize the problem of unknown words, resulting in slow decoding times and large storage costs. In this paper we address both shortcomings. Towards this goal, we first introduce a simple mechanism that first reads the input sequence before committing to a representation of each word. Furthermore, we propose a simple copy mechanism that is able to exploit very small vocabularies and handle out-of-vocabulary words. We demonstrate the effectiveness of our approach on the Gigaword dataset and DUC competition outperforming the state-of-the-art.",
  "accepted": false,
  "zeroShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": false,
        "confidence": 0.72,
        "primary_reason": "Novel encoder-decoder architecture with read-again mechanism and copy decoder for abstractive summarization. Demonstrates SOTA results on Gigaword and DUC2004 with practical benefits (5-30x vocabulary reduction). Solid experimental validation, though limited novelty in individual components and some presentation issues."
      },
      "token": {
        "prompt_tokens": 6331,
        "completion_tokens": 100,
        "total_tokens": 6431
      },
      "time": "2026-02-05T23:06:12.604843+00:00"
    },
    {
      "model": "gpt-5.2",
      "decision": {
        "rejection": true,
        "confidence": 0.74,
        "primary_reason": "Limited novelty and methodological weakness vs. established bidirectional/attention/pointer-generator baselines; experimental evidence is incomplete (missing ablations/significance/strong comparisons) for top-tier acceptance."
      },
      "token": {
        "prompt_tokens": 5770,
        "completion_tokens": 56,
        "total_tokens": 5826
      },
      "time": "2026-02-09T21:35:31.270223+00:00"
    }
  ],
  "article": [
    {
      "heading": "1 INTRODUCTION",
      "text": "Encoder-decoder models have been widely used in sequence to sequence tasks such as machine translation (Cho et al. (2014); Sutskever et al. (2014)). They consist of an encoder which represents the whole input sequence with a single feature vector. The decoder then takes this representation and generates the desired output sequence. The most successful models are LSTM and GRU as they are much easier to train than vanilla RNNs. In this paper we are interested in summarization where the input sequence is a sentence/paragraph and the output is a summary of the text. Several encoding-decoding approaches have been proposed (Rush et al. (2015); Hu et al. (2015); Chopra et al. (2016)). Despite their success, it is commonly believed that the intermediate feature vectors are limited as they are created by only looking at previous words. This is particularly detrimental when dealing with large input sequences. Bi-directorial RNNs (Schuster & Paliwal (1997); Bahdanau et al. (2014)) try to address this problem by computing two different representations resulting of reading the input sequence left-to-right and right-to-left. The final vectors are computed by concatenating the two representations. However, the word representations are computed with limited scope. The decoder employed in all these methods outputs at each time step a distribution over a fixed vocabulary. In practice, this introduces problems with rare words (e.g., proper nouns) which are out of vocabulary. To alleviate this problem, one could potentially increase the size of the decoder vocabulary, but decoding becomes computationally much harder, as one has to compute the soft-max over all possible words. Gulcehre et al. (2016), Nallapati et al. (2016) and Gu et al. (2016) proposed to use a copy mechanism that dynamically copy the words from the input sequence while decoding. However, they lack the ability to extract proper embeddings of out-of-vocabulary words from the input context. Bahdanau et al. (2014) proposed to use an attention mechanism to emphasize specific parts of the input sentence when generating each word. However the encoder problem still remains in this approach. In this work, we propose two simple mechanisms to deal with both encoder and decoder problems. We borrowed intuition from human readers which read the text multiple times before generating summaries. We thus propose a Read-Again model that first reads the input sequence before committing to a representation of each word. The first read representation then biases the second read representation and thus allows the intermediate hidden vectors to capture the meaning appropriate for the input text. We show that this idea can be applied to both LSTM and GRU models. Our second contribution is a copy mechanism which allows us to use much smaller vocabulary sizes resulting in much faster decoding and much smaller storage space. Our copy mechanism also allows us to construct a better representation of out-of-vocabulary words. We demonstrate the effectiveness of our approach in the challenging Gigaword dataset and DUC competition showing state-of-the-art performance.",
      "exclude": true
    },
    {
      "heading": "2 RELATED WORK",
      "text": "",
      "exclude": true
    },
    {
      "heading": "2.1 SUMMARIZATION",
      "text": "In the past few years, there has been a lot of work on extractive summarization, where a summary is created by composing words or sentences from the source text. Notable examples are Neto et al. (2002), Erkan & Radev (2004), Wong et al. (2008), Filippova & Altun (2013) and Colmenares et al. (2015). As a consequence of their extractive nature the summary is restricted to words (sentences) in the source text. Abstractive summarization, on the contrary, aims at generating consistent summaries based on understanding the input text. Although there has been much less work on abstractive methods, they can in principle produce much richer summaries. Abstractive summarization is standardized by the DUC2003 and DUC2004 competitions (Over et al. (2007)). Some of the prominent approaches on this task includes Banko et al. (2000), Zajic et al. (2004), Cohn & Lapata (2008) and Woodsend et al. (2010). Among them, the TOPIARY system (Zajic et al. (2004)) performs the best in the competitions amongst non neural net based methods. Very recently, the success of deep neural networks in many natural language processing tasks (Collobert et al. (2011)) has inspired new work in abstractive summarization . Rush et al. (2015) propose a neural attention model with a convolutional encoder to solve this task. Hu et al. (2015) build a large dataset for Chinese text summarization and propose to feed all hidden states from the encoder into the decoder. More recently, Chopra et al. (2016) extended Rush et al. (2015)s work with an RNN decoder, and Nallapati et al. (2016) proposed an RNN encoder-decoder architecture for summarization. Both techniques are currently the state-of-the-art on the DUC competition. However, the encoders exploited in these methods lack the ability to encode each word condition on the whole text, as an RNN encodes a word into a hidden vector by taking into account only the words up to that time step. In contrast, in this work we propose a Read-Again encoder-decoder architecture, which enables the encoder to understand each input word after reading the whole sentence. Our encoder first reads the text, and the results from the first read help represent the text in the second pass over the source text. Our second contribution is a simple copy mechanism that allows us to significantly reduce the decoder vocabulary size resulting in much faster inference times. Furthermore our copy mechanism allows us to handle out-of-vocabulary words in a principled manner. Finally our experiments show state-of-the-art performance on the DUC competition.",
      "exclude": false
    },
    {
      "heading": "2.2 NEURAL MACHINE TRANSLATION",
      "text": "Our work is also closely related to recent work on neural machine translation, where neural encoderdecoder models have shown promising results (Kalchbrenner & Blunsom (2013); Cho et al. (2014); Sutskever et al. (2014)). Bahdanau et al. (2014) further developed an attention mechanism in the decoder in order to pay attention to a specific part of the input at every generating time-step. Our approach also exploits an attention mechanism during decoding.",
      "exclude": false
    },
    {
      "heading": "2.3 OUT-OF-VOCABULARY AND COPY MECHANISM",
      "text": "Dealing with Out-Of-Vocabulary words (OOVs) is an important issue in sequence to sequence approaches as we cannot enumerate all possible words and learn their embeddings since they might not be part of our training set. Luong et al. (2014) address this issue by annotating words on the source, and aligning OOVs in the target with those source words. Recently, Vinyals et al. (2015) propose Pointer Networks, which calculate a probability distribution over the input sequence instead of predicting a token from a pre-defined dictionary. Cheng & Lapata (2016) develop a neural-based extractive summarization model, which predicts the targets from the input sequences. Gulcehre et al. (2016); Nallapati et al. (2016) use explicit gating to decide adaptively wether to generate a target word from the fixed-size dictionary or from the input sequence. Gu et al. (2016) use a implicit implicit gating operation instead of the explicit gating. This is similar to our decoder. However, our decoder can also extract different OOVs embedding accordingly from the input text instead of using a single embedding to represent all OOVs. This further enhances the models ability to handle OOVs.",
      "exclude": false
    },
    {
      "heading": "3 THE READ AGAIN MODEL",
      "text": "Text summarization can be formulated as a sequence to sequence prediction task, where the input is a longer text and the output is a summary of that text. In this paper we develop an encoder-decoder approach to summarization. The encoder is used to represent the input text with a set of continuous vectors, and the decoder is used to generate a summary word by word. In the following, we first introduce our Read-Again model for encoding sentences. The idea behind our approach is very intuitive and is inspired by how humans do this task. When we create summaries, we first read the text and then we do a second read where we pay special attention to the words that are relevant to generate the summary. Our Read-Again model implements this idea by reading the input text twice and using the information acquired from the first read to bias the second read. This idea can be seamlessly plugged into LSTM and GRU models. Our second contribution is a copy mechanism used in the decoder. It allows us to reduce the decoder vocabulary size dramatically and can be used to extract a better embedding for OOVs. Fig. 1(a) gives an overview of our model.",
      "exclude": false
    },
    {
      "heading": "3.1 ENCODER",
      "text": "We first review the typical encoder used in machine translation (e.g., Sutskever et al. (2014); Bahdanau et al. (2014)). Let x = x1, x2, , xn be the input sequence of words. An encoder sequentially reads each word and creates the hidden representation hi by exploting a recurrent neural network (RNN) hi = RNN(xi, hi1), (1) where xi is the word embedding of xi. The hidden vectors h = h1, h2, , hn are then treated as the feature representations for the whole input sentence and can be used by another RNN to decode and generate a target sentence. Although RNNs have been shown to be useful in modeling sequences, one of the major drawback is that hi depends only on past information i.e., x1, , xi. However, it is hard (even for humans) to have a proper representation of a word without reading the whole input sentence. Following this intuition, we propose our Read-Again model where the encoder reads the input sentence twice. In particular, the first read is used to bias the second more attentive read. We apply this idea to two popular RNN architectures, i.e. GRU and LSTM, resulting in better encodings of the input text. Note that although other alternatives, such as bidirectional RNN exist, the hidden states from the forward RNN lack direct interactions with the backward RNN, and thus forward/backward hidden states still cannot utilize the whole sequence. Besides, although we only use our model in a uni-directional manner, it can also be easily adapted to the bidirectional case. We now describe the two variants of our model.",
      "exclude": false
    },
    {
      "heading": "3.1.1 GRU READ-AGAIN",
      "text": "We read the input sentence x1, x2, , xn for the first-time using a standard GRU h1i = GRU 1(xi, h 1 i1), (2) where the function GRU1 is defined as, zi = (Wz[xi, h 1 i1]) (3) ri = (Wr[xi, h 1 i1]) h1i = tanh(Wh[xi, ri h1i1]) h1i = (1 zi) h1i1 + zi h1i It consists of two gatings zi, ri, controlling whether the current hidden state h1i should be directly copied from h1i1 or should pass through a more complex path h 1 i . Given the sentence feature vector h1n, we then compute an importance weight vector i of each word for the second reading. We put the importance weight i on the skip-connections as shown in Fig. 2(a) to bias the two information flows: If the current word xi has a very small weight i, then the second read hidden state h2i will mostly take the information directly from the previous state h2i1, ignoring the influence of the current word. If i is close to 1 then it will be similar to a standard GRU, which is only influenced from the current word. Thus the second reading has the following update rule h2i = (1 i) h2i1 + i GRU2(xi, h2i1), (4) where means element-wise product. We compute the importance weights by attending h1i with h1n as follows i = tanh(Weh 1 i + Ueh 1 n + Vexi), (5) where We, Ue, Ve are learnable parameters. Note that i is a vector representing the importance of each dimension in the word embedding. Empirically, we find that using a vector is better than a scalar gating. We hypothesize that this is because different dimensions represent different semantic meanings, and a scalar gating mechanism lacks the ability to capture the variances among these dimensions. Combining this with the standard GRU update rule GRU2(xi, h2i1) = (1 zi) h2i1 + zi h2i , we can simplify the updating rule Eq. (4) to get h2i = (1 i zi) h2i1 + (i zi) h2i (6) This equations shows that our read-again model on GRU is equivalent to replace the GRU cell with a more general gating mechanism that also depends on the feature representation of the whole sentence computed from the first reading pass. We argue that adding this global information could help direct the information flow for the forward pass resulting in a better encoder.",
      "exclude": false
    },
    {
      "heading": "3.1.2 LSTM READ-AGAIN",
      "text": "We now apply the Read-Again idea to the LSTM architecture as shown in Fig. 2(b). Our first reading is performed by an LSTM1 defined as fi = (Wf [xi, hi1]) (7) ii = (Wi[xi, hi1]) oi = (Wo[xi, hi1]) Ci = tanh(WC [xi, hi1]) Ci = ft Ci1 + ii Ci hi = oi tanh(Ci) Different from the GRU architecture, LSTM calculates the hidden state by applying a non-linear activation function to the cell state Ci, instead of a linear combination of two paths used in the GRU. Thus for our second read, instead of using skip-connections, we make the gating functions explicitly depend on the whole sentence vector computed from the first reading pass. We argue that this helps the encoding of the second reading LSTM2, as all gating and updating increments are also conditioned on the whole sequence feature vector (h1i , h 1 n). Thus h2i = LSTM 2([xi, h 1 i , h 1 n], h 2 i1), (8)",
      "exclude": false
    },
    {
      "heading": "3.1.3 READING MULTIPLE SENTENCES",
      "text": "In this section we extend our Read-Again model to the case where the input sequence has more than one sentence. Towards this goal, we propose to use a hierarchical representation, where each sentence has its own feature vector from the first reading pass. We then combine them into a single vector to bias the second reading pass. We illustrate this in the context of two input sentences, but it is easy to generalize to more sentences. Let x1, x2, , xn and x1, , xm be the two input sentences. The first RNN reads these two sentences independently to get two sentence feature vectors h1n and h 1 m respectively. Here we investigate two different ways to handle multiple sentences. Our first option is to simply concatenate the two feature vectors to bias our second reading pass: h2i = RNN 2([xi, h 1 i , h 1 n, h 1 m], h 2 i1) (9) h2i = RNN 2([xi, h 1 i , h 1 n, h 1 m], h 2 i1) where h20 and h 2 0 are initialized as zero vectors. Feeding h 1 n, h 1 m into the second RNN provides more global information explicitly and helps acquire long term dependencies. The second option we explored is shown in Fig. 3. In particular, we use a non-linear transformation to get a single feature vector hglobal from both sentence feature vectors: hglobal = tanh(Wrh 1 n + Urh 1 m + vr) (10) The second reading pass is then h2i = RNN 2([xi, h 1 i , h 1 n, hglobal], h 2 i1) (11) h2i = RNN 2([xi, h 1 i , h 1 m, hglobal], h 2 i1) Note that this is more easily scalable to more sentences. In our experiments both approaches perform similarly.",
      "exclude": false
    },
    {
      "heading": "3.2 DECODER WITH COPY MECHANISM",
      "text": "In this paper we argue that only a small number of common words are needed for generating a summary in addition to the words that are present in the source text. We can consider this as a hybrid approach which combines extractive and abstractive summarization. This has two benefits: first it allow us to use a very small vocabulary size, speeding up inference. Furthermore, we can create summaries which contain OOVs if they are present in the source text. Our decoder reads the vector representations of the input text using an attention mechanism, and generates the target summary word by word. We use an LSTM as our decoder, with a fixed-size vocabulary dictionary Y and learnable word embeddings Y R|Y |dim. At time-step t the LSTM generates a summary word yt by first computing the current hidden state st from the previous hidden state st1, previous summary word yt1 and current context vector ct st = LSTM([yt1, ct], st1), (12) where the context vector ct is computed with an attention mechanism on the encoder hidden states: ct = n i=1 ith 2 i . (13) The attention score it at time-step t on the i-th word is computed via a soft-max over oit, where oit = att(st1, h 2 i ) = v T a tanh(Wast1 + Uah 2 i ), (14) with va, Wa, Ua learnable parameters. A typical way to treat OOVs is to encode them with a single shared embedding. However, different OOVs can have very different meanings, and thus using a single embedding for all OOVs will confuse the model. This is particularly detrimental when using small vocabulary sizes. Here we address this issue by deriving the representations of OOVs from their corresponding context in the input text. Towards this goal, we change the update rule of yt1. In particular, if yt1 belongs to a word that is in our decoder vocabulary we take its representation from the word embedding, otherwise if it appears in the input sentence as xi we use yt1 = pi = tanh(Wch 2 i + bc) (15) where Wc and bc are learnable parameters. Since h2i encodes useful context information of the source word xi, pi can be interpreted as the semantics of this word extracted from the input sentence. Furthermore, if yt1 does not appear in the input text, nor in Y , then we represent yt1 using the embedding. Given the current decoders hidden state st, we can generate the target summary word yt. As shown in Fig. 1(b), at each time step during decoding, the decoder outputs a distribution over generating words from Y , as well as over copying a specific word xi from the source sentence.",
      "exclude": false
    },
    {
      "heading": "3.3 LEARNING",
      "text": "We jointly learn our encoder and decoder by maximizing the likelihood of decoding the correct word at each time step. We refer the reader to the experimental evaluation for more details.",
      "exclude": false
    },
    {
      "heading": "4 EXPERIMENTAL EVALALUATION",
      "text": "In this section, we show results of abstractive summarization on Gigaword (Graff & Cieri (2003); Napoles et al. (2012)) and DUC2004 (Over et al. (2007)) datasets. Our model can learn a meaningful re-reading weight distribution for each word in the input text, putting more emphasis on important verb and nous, while ignoring common words such as prepositions. As for the decoder, we demonstrate that our copy mechanism can successfully reduce the typical vocabulary size by a factor 5 while achieving much better performance than the state-of-the-art, and by a factor of 30 while maintaining the same level of performance. In addition, we provide an analysis and examples of which words are copied during decoding. Dataset and Evaluation Metric: We use the Gigaword corpus to train and evaluate our models. Gigaword is a news corpus where the title is employed as a proxy for the summary of the article. We follow the same pre-processing steps of Rush et al. (2015), which include filtering, PTB tokenization, lower-casing, replacing digit characters with #, replacing low-frequency words with UNK and extracting the first sentence in each article. This results in a training set of 3.8M articles, a validation set and a test set each containing 400K articles. The average sentence length is 31.3 words for the source, and 8.3 words for the summaries. Following the standard protocol we evaluate ROUGE score on 2000 random samples from the test set. As for evaluation metric, we use full-length F1 score on Rouge-1, Rouge-2 and Rouge-L, following Chopra et al. (2016) and Nallapati et al. (2016), since these metrics are less bias to the outputs length than full-length recall scores. Implemetation Details: We implement our model in Tensorflow and conduct all experiments on a NVIDIA Titan X GPU. Our models converged after 2-3 days of training, depending on model size. Our RNN cells in all models have 1 layer, 512-dimensional hidden states, and 512-dimensional word embeddings. We use dropout rate of 0.2 in all activation layers. All parameters, except the biases are initialized uniformly with a range of 3/d, where d is the dimension of the hidden state (Sussillo & Abbott (2014)). The biases are initialized to 0.1. We use plain SGD to train the model with gradient clipped at 10. We start with an initial learning rate of 2, and halve it every epoch after first 5 epochs. Our max epoch for training is 10. We use a mini-batch size of 64, which is shuffled during training.",
      "exclude": false
    },
    {
      "heading": "4.1 QUANTITATIVE EVALUATION",
      "text": "Results on Gigaword: We compare the performances of different architectures and report ROUGE scores in Table 1. Our baselines include the ABS model of Rush et al. (2015) with its proposed vocabulary size as well as an attention encoder-decoder model with uni-directional GRU encoder. We allow the decoder to generate variable length summaries. As shown in Table 1 our Read-Again models outperform the baselines on all ROUGE scores, when using both 15K and 69K sized vocabularies. We also observe that adding the copy mechanism further helps to improve performance: Even though the decoder vocabulary size of our approach with copy (15K) is much smaller than ABS (69K) and GRU (69K), it achieves a higher ROUGE score. Besides, our Multiple-Sentences model achieves the best performance. Evaluation on DUC2004: DUC 2004 (Over et al. (2007)) is a commonly used benchmark on summarization task consisting of 500 news articles. Each article is paired with 4 different humangenerated reference summaries, capped at 75 characters. This dataset is evaluation-only. Similar to Rush et al. (2015), we train our neural model on the Gigaword training set, and show the models performances on DUC2004. Following the convention, we also use ROUGE limited-length recall as our evaluation metric, and set the capping length to 75 characters. We generate summaries with 15 words using beam-size of 10. As shown in Table 2, our method outperforms all previous methods on Rouge-1 and Rouge-L, and is comparable on Rouge-2. Furthermore, our model only uses 15k decoder vocabulary, while previous methods use 69k or 200k. Importance Weight Visualization: As we described in the section before, i is a high-dimension vector representing the importance of each word xi. While the importance of a word is different over each dimension, by averaging we can still look at general trends of which word is more relevant. Fig. 4 depicts sample sentences with the importance weight i over input words. Words such as the, a, s, have small i, while words such as aeronautics, resettled, impediments, which carry more information have higher values. This shows that our read-again technique indeed extracts useful information from the first reading to help bias the second reading results. the sh utt le sp ac e do wn tou ch ed co lum bia at su nd ay ken ne dythe ce nte r ca na ve ral ca pein sp ac e flo rid a, ae ron au tic s na tio na l the sp ac e, ad mi nis tra tio n an d sa id . indonesia has moved #.# million people and resettled them in #,### villages in a national transmigration scheme over the past ## years , presi ent suharto said here monday . ind on es ia #.#ha s an d mi llio n mo ve d res ett led pe op le vill ag es the m in tra ns mi gra tio n na tio na la #.# ## sc he me pa st ov er the he re## pre sid en t . ye ars , mo nd ay su ha rto sa idin indo esia 's state- wned domestic carrier merp ti nusantara airlines will lease ## aircraft from the united states , the official antara news agency reported here thursday . ind on es ia sta teow ne ds me rpa ti ca rrie r do me sti c air lin es nu sa nta ra lea sewil l air cra ft un ite dthefro m## the sta tes thu rsd ay offi cia l he re ag en cy, ne ws an tar a rep ort ed . tar iffs ba rrie rsan d im pe dim en ts rem ainoth er to se rio us an d tra de in reg ion as ia- pa cifi c the bu sin es s de sp ite pro gre ss su bs tan tia l the las t rep ortov er se ve n . tariffs and other barriers remain serious impediments to trade and business in the asia-pacific region despite `` substantial '' progress over the last seven years , a leading economic council said in a report . ye ars , a lea din g ec on om ic co un cilsa id in a Figure 4: Weight Visualization. Black indicates high weight",
      "exclude": false
    },
    {
      "heading": "4.2 EVALUATION OF COPY MECHANISM",
      "text": "Table 3 shows the effect on our model of decreasing the decoder vocabulary size. We can see that when using the copy mechanism, we are able to reduce the decoder vocabulary size from 69K to 2K, with only 2-3 points drop on ROUGE score. This contrasts the models that do not use the copy mechanism. Equipped with a copy mechanism, our model is able to generate OOVs as summary words, and thus maintains its expressive ability even with a small decoder vocabulary size. We also observe from Table 4 that the copy mechanism help us to decrease the encoder vocabulary size as well. The model without copy suffers from severe OOV problem when encoder size is small, since a single shared embedding cannot depict many different OOVs. This makes it difficult for the encoder to understand the input text. Meanwhile, our copy model can extract an OOVs meaning accordingly from its context in the input text, and thus it is sufficient to learn and store only the high-frequency words embeddings using our model, which in turn save the storage. We also notice that shrinking the encoder vocabulary to 15k achieves better result. One possible reason is that long tail words can not learn efficient embeddings during training, and representing them with extracted embedding from our model performs better. Table 5 shows the decoding time as a function of vocabulary size. As computing the soft-max is usually the bottleneck for decoding, reducing vocabulary size dramatically reduces the decoding time from 0.38 second per sentence to 0.08 second. Table 6 provides some examples of visualization of the copy mechanism. Note that we are able to copy key words from source sentences to improve the summary. From these examples we can see that our model is able to copy different types of rare words, such as special entities names in case 1 and 2, rare nouns in case 3 and 4, adjectives in case 5 and 6, and even rare verbs in the last example. Note that in the third example, when the copy models decoder uses the embedding of headmaster as its first input, which is extracted from the source sentence, it generates the same following sentence as the no-copy model. This probably means that the extracted embedding of headmaster is closely related to the learned embedding of teacher.",
      "exclude": false
    },
    {
      "heading": "5 CONCLUSION",
      "text": "In this paper we have proposed two simple mechanisms to alleviate the problems of current encoderdecoder models. Our first contribution is a Read-Again model which does not form a representation of the input word until the whole sentence is read. Our second contribution is a copy mechanism that can handle out-of-vocabulary words in a principled manner allowing us to reduce the decoder vocabulary size and significantly speed up inference. We have demonstrated the effectiveness of our approach in the context of summarization and shown state-of-the-art performance. In the future, we plan to tackle summarization problems with large input text. We also plan to exploit our findings in other tasks such as machine translation.",
      "exclude": true
    }
  ],
  "fewShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": false,
        "confidence": 0.72,
        "primary_reason": "Novel Read-Again encoder mechanism with principled copy decoder for summarization; strong empirical results on Gigaword/DUC2004 with practical benefits (5-30x vocabulary reduction); clear methodological contributions despite incremental nature."
      },
      "token": {
        "prompt_tokens": 6493,
        "completion_tokens": 87,
        "total_tokens": 6580
      },
      "time": "2026-02-08T22:36:13.522241+00:00"
    },
    {
      "model": "gpt-5.2",
      "decision": {
        "rejection": false,
        "confidence": 0.63,
        "primary_reason": "Strong empirical gains on standard summarization benchmarks from a reasonably novel two-pass “read-again” encoder plus an effective copy/pointer-style mechanism that enables much smaller vocabularies and faster decoding; while somewhat incremental relative to emerging pointer/copy literature, the combination is well-motivated and supported with solid experiments/analysis."
      },
      "token": {
        "prompt_tokens": 8404,
        "completion_tokens": 92,
        "total_tokens": 8496
      },
      "time": "2026-02-09T20:38:48.235602+00:00"
    }
  ],
  "test": false
}