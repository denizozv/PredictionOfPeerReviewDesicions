{
  "id": "393",
  "title": "Structured Attention Networks",
  "abstract": "Attention networks have proven to be an effective approach for embedding categorical inference within a deep neural network. However, for many tasks we may want to model richer structural dependencies without abandoning end-to-end training. In this work, we experiment with incorporating richer structural distributions, encoded using graphical models, within deep networks. We show that these structured attention networks are simple extensions of the basic attention procedure, and that they allow for extending attention  beyond the standard soft-selection approach, such as attending to partial segmentations or to subtrees. We experiment with two different classes of structured attention networks: a linear-chain conditional random field and a graph-based parsing model, and describe how these models can be practically implemented as neural network layers. Experiments show that this approach is effective for incorporating structural biases, and structured attention networks outperform baseline attention models on a variety of synthetic and real tasks: tree transduction, neural machine translation, question answering, and natural language inference. We further find that models trained in this way learn interesting unsupervised hidden representations that generalize simple attention.",
  "accepted": true,
  "zeroShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": false,
        "confidence": 0.92,
        "primary_reason": "Novel integration of structured graphical models (CRFs) as differentiable attention layers within deep networks, with solid theoretical grounding, comprehensive experiments across multiple tasks, and practical implementation details for end-to-end training."
      },
      "token": {
        "prompt_tokens": 11007,
        "completion_tokens": 74,
        "total_tokens": 11081
      },
      "time": "2026-02-05T22:41:07.402980+00:00"
    }
  ],
  "article": [
    {
      "heading": "1 INTRODUCTION",
      "text": "Attention networks are now a standard part of the deep learning toolkit, contributing to impressive results in neural machine translation (Bahdanau et al., 2015; Luong et al., 2015), image captioning (Xu et al., 2015), speech recognition (Chorowski et al., 2015; Chan et al., 2015), question answering (Hermann et al., 2015; Sukhbaatar et al., 2015), and algorithm-learning (Graves et al., 2014; Vinyals et al., 2015), among many other applications (see Cho et al. (2015) for a comprehensive review). This approach alleviates the bottleneck of compressing a source into a fixed-dimensional vector by equipping a model with variable-length memory (Weston et al., 2014; Graves et al., 2014; 2016), thereby providing random access into the source as needed. Attention is implemented as a hidden layer which computes a categorical distribution (or hierarchy of categorical distributions) to make a soft-selection over source elements. Noting the empirical effectiveness of attention networks, we also observe that the standard attentionbased architecture does not directly model any structural dependencies that may exist among the source elements, and instead relies completely on the hidden layers of the network. While one might argue that these structural dependencies can be learned implicitly by a deep model with enough data, in practice, it may be useful to provide a structural bias. Modeling structural dependencies at the final, output layer has been shown to be important in many deep learning applications, most notably in seminal work on graph transformers (LeCun et al., 1998), key work on NLP (Collobert et al., 2011), and in many other areas (Peng et al., 2009; Do & Artieres, 2010; Jaderberg et al., 2014; Chen et al., 2015; Durrett & Klein, 2015; Lample et al., 2016, inter alia). In this work, we consider applications which may require structural dependencies at the attention layer, and develop internal structured layers for modeling these directly. This approach generalizes categorical soft-selection attention layers by specifying possible structural dependencies in a soft Equal contribution. manner. Key applications will be the development of an attention function that segments the source input into subsequences and one that takes into account the latent recursive structure (i.e. parse tree) of a source sentence. Our approach views the attention mechanism as a graphical model over a set of latent variables. The standard attention network can be seen as an expectation of an annotation function with respect to a single latent variable whose categorical distribution is parameterized to be a function of the source. In the general case we can specify a graphical model over multiple latent variables whose edges encode the desired structure. Computing forward attention requires performing inference to obtain the expectation of the annotation function, i.e. the context vector. This expectation is computed over an exponentially-sized set of structures (through the machinery of graphical models/structured prediction), hence the name structured attention network. Notably each step of this process (including inference) is differentiable, so the model can be trained end-to-end without having to resort to deep policy gradient methods (Schulman et al., 2015). The differentiability of inference algorithms over graphical models has previously been noted by various researchers (Li & Eisner, 2009; Domke, 2011; Stoyanov et al., 2011; Stoyanov & Eisner, 2012; Gormley et al., 2015), primarily outside the area of deep learning. For example, Gormley et al. (2015) treat an entire graphical model as a differentiable circuit and backpropagate risk through variational inference (loopy belief propagation) for minimium risk training of dependency parsers. Our contribution is to combine these ideas to produce structured internal attention layers within deep networks, noting that these approaches allow us to use the resulting marginals to create new features, as long as we do so a differentiable way. We focus on two classes of structured attention: linear-chain conditional random fields (CRFs) (Lafferty et al., 2001) and first-order graph-based dependency parsers (Eisner, 1996). The initial work of Bahdanau et al. (2015) was particularly interesting in the context of machine translation, as the model was able to implicitly learn an alignment model as a hidden layer, effectively embedding inference into a neural network. In similar vein, under our framework the model has the capacity to learn a segmenter as a hidden layer or a parser as a hidden layer, without ever having to see a segmented sentence or a parse tree. Our experiments apply this approach to a difficult synthetic reordering task, as well as to machine translation, question answering, and natural language inference. We find that models trained with structured attention outperform standard attention models. Analysis of learned representations further reveal that interesting structures emerge as an internal layer of the model. All code is available at http://github.com/harvardnlp/struct-attn.",
      "exclude": true
    },
    {
      "heading": "2 BACKGROUND: ATTENTION NETWORKS",
      "text": "A standard neural network consist of a series of non-linear transformation layers, where each layer produces a fixed-dimensional hidden representation. For tasks with large input spaces, this paradigm makes it hard to control the interaction between components. For example in machine translation, the source consists of an entire sentence, and the output is a prediction for each word in the translated sentence. Utilizing a standard network leads to an information bottleneck, where one hidden layer must encode the entire source sentence. Attention provides an alternative approach.1 An attention network maintains a set of hidden representations that scale with the size of the source. The model uses an internal inference step to perform a soft-selection over these representations. This method allows the model to maintain a variable-length memory and has shown to be crucially important for scaling systems for many tasks. Formally, let x = [x1, . . . , xn] represent a sequence of inputs, let q be a query, and let z be a categorical latent variable with sample space 1, . . . , n that encodes the desired selection among these inputs. Our aim is to produce a context c based on the sequence and the query. To do so, we assume access to an attention distribution z p(z |x, q), where we condition p on the inputs x and a query q. The context over a sequence is defined as expectation, c = Ezp(z | x,q)[f(x, z)] where f(x, z) is an annotation function. Attention of this form can be applied over any type of input, however, we will primarily be concerned with deep networks, where both the annotation function 1Another line of work involves marginalizing over latent variables (e.g. latent alignments) for sequence-tosequence transduction (Kong et al., 2016; Lu et al., 2016; Yu et al., 2016; 2017). and attention distribution are parameterized with neural networks, and the context produced is a vector fed to a downstream network. For example, consider the case of attention-based neural machine translation (Bahdanau et al., 2015). Here the sequence of inputs [x1, . . . ,xn] are the hidden states of a recurrent neural network (RNN), running over the words in the source sentence, q is the RNN hidden state of the target decoder (i.e. vector representation of the query q), and z represents the source position to be attended to for translation. The attention distribution p is simply p(z = i |x, q) = softmax(i) where Rn is a parameterized potential typically based on a neural network, e.g. i = MLP([xi;q]). The annotation function is defined to simply return the selected hidden state, f(x, z) = xz . The context vector can then be computed using a simple sum, c = Ezp(z | x,q)[f(x, z)] = n i=1 p(z = i |x, q)xi (1) Other tasks such as question answering use attention in a similar manner, for instance by replacing source [x1, . . . , xn] with a set of potential facts and q with a representation of the question. In summary we interpret the attention mechanism as taking the expectation of an annotation function f(x, z) with respect to a latent variable z p, where p is parameterized to be function of x and q.",
      "exclude": false
    },
    {
      "heading": "3 STRUCTURED ATTENTION",
      "text": "Attention networks simulate selection from a set using a soft model. In this work we consider generalizing selection to types of attention, such as selecting chunks, segmenting inputs, or even attending to latent subtrees. One interpretation of this attention is as using soft-selection that considers all possible structures over the input, of which there may be exponentially many possibilities. Of course, this expectation can no longer be computed using a simple sum, and we need to incorporate the machinery of inference directly into our neural network. Define a structured attention model as being an attention model where z is now a vector of discrete latent variables [z1, . . . , zm] and the attention distribution is p(z |x, q) is defined as a conditional random field (CRF), specifying the independence structure of the z variables. Formally, we assume an undirected graph structure withm vertices. The CRF is parameterized with clique (log-)potentials C(zC) R, where the zC indicates the subset of z given by clique C. Under this definition, the attention probability is defined as, p(z |x, q; ) = softmax( C C(zC)), where for symmetry we use softmax in a general sense, i.e. softmax(g(z)) = 1Z exp(g(z)) where Z = z exp(g(z )) is the implied partition function. In practice we use a neural CRF, where comes from a deep model over x, q. In structured attention, we also assume that the annotation function f factors (at least) into clique annotation functions f(x, z) = C fC(x, zC). Under standard conditions on the conditional independence structure, inference techniques from graphical models can be used to compute the forwardpass expectations and the context: c = Ezp(z | x,q)[f(x, z)] = C Ezp(zC | x,q)[fC(x, zC)]",
      "exclude": false
    },
    {
      "heading": "3.1 EXAMPLE 1: SUBSEQUENCE SELECTION",
      "text": "Suppose instead of soft-selecting a single input, we wanted to explicitly model the selection of contiguous subsequences. We could naively apply categorical attention over all subsequences, or hope the model learns a multi-modal distribution to combine neighboring words. Structured attention provides an alternate approach. Concretely, let m = n, define z to be a random vector z = [z1, . . . , zn] with zi 0, 1, and define our annotation function to be, f(x, z) = n i=1 fi(x, zi) where fi(x, zi) = 1zi = 1xi. The explicit expectation is then, Ez1,...,zn [f(x, z)] = n i=1 p(zi = 1 |x, q)xi (2) Equation (2) is similar to equation (1)both are a linear combination of the input representations where the scalar is between [0, 1] and represents how much attention should be focused on each input. However, (2) is fundamentally different in two ways: (i) it allows for multiple inputs (or no inputs) to be selected for a given query; (ii) we can incorporate structural dependencies across the zis. For instance, we can model the distribution over z with a linear-chain CRF with pairwise edges, p(z1, . . . , zn |x, q) = softmax ( n1 i=1 i,i+1(zi, zi+1) ) (3) where k,l is the pairwise potential for zi = k and zi+1 = l. This model is shown in Figure 1c. Compare this model to the standard attention in Figure 1a, or to a simple Bernoulli (sigmoid) selection method, p(zi = 1 |x, q) = sigmoid(i), shown in Figure 1b. All three of these methods can use potentials from the same neural network or RNN that takes x and q as inputs. In the case of the linear-chain CRF in (3), the marginal distribution p(zi = 1 |x) can be calculated efficiently in linear-time for all i using message-passing, i.e. the forward-backward algorithm. These marginals allow us to calculate (2), and in doing so we implicitly sum over an exponentially-sized set of structures (i.e. all binary sequences of length n) through dynamic programming. We refer to this type of attention layer as a segmentation attention layer. Note that the forward-backward algorithm is being used as parameterized pooling (as opposed to output computation), and can be thought of as generalizing the standard attention softmax. Crucially this generalization from vector softmax to forward-backward is just a series of differentiable steps,2 and we can compute gradients of its output (marginals) with respect to its input (potentials). This will allow the structured attention model to be trained end-to-end as part of a deep model.",
      "exclude": false
    },
    {
      "heading": "3.2 EXAMPLE 2: SYNTACTIC TREE SELECTION",
      "text": "This same approach can be used for more involved structural dependencies. One popular structure for natural language tasks is a dependency tree, which enforces a structural bias on the recursive dependencies common in many languages. In particular a dependency tree enforces that each word in a source sentence is assigned exactly one parent word (head word), and that these assignments do not cross (projective structure). Employing this bias encourages the system to make a soft-selection based on learned syntactic dependencies, without requiring linguistic annotations or a pipelined decision. A dependency parser can be partially formalized as a graphical model with the following cliques (Smith & Eisner, 2008): latent variables zij 0, 1 for all i 6= j, which indicates that the i-th word is the parent of the j-th word (i.e. xi xj); and a special global constraint that rules out configurations of zijs that violate parsing constraints (e.g. one head, projectivity). The parameters to the graph-based CRF dependency parser are the potentials ij , which reflect the score of selecting xi as the parent of xj . The probability of a parse tree z given the sentence 2As are other dynamic programming algorithms for inference in graphical models, such as (loopy and nonloopy) belief propagation. x = [x1, . . . , xn] is, p(z |x, q) = softmax 1z is valid i 6=j 1zij = 1ij (4) where z is represented as a vector of zijs for all i 6= j. It is possible to calculate the marginal probability of each edge p(zij = 1 |x, q) for all i, j inO(n3) time using the inside-outside algorithm (Baker, 1979) on the data structures of Eisner (1996). The parsing contraints ensure that each word has exactly one head (i.e. n i=1 zij = 1). Therefore if we want to utilize the soft-head selection of a position j, the context vector is defined as: fj(x, z) = n i=1 1zij = 1xi cj = Ez[fj(x, z)] = n i=1 p(zij = 1 |x, q)xi Note that in this case the annotation function has the subscript j to produce a context vector for each word in the sentence. Similar types of attention can be applied for other tree properties (e.g. soft-children). We refer to this type of attention layer as a syntactic attention layer.",
      "exclude": false
    },
    {
      "heading": "3.3 END-TO-END TRAINING",
      "text": "Graphical models of this form have been widely used as the final layer of deep models. Our contribution is to argue that these networks can be added within deep networks in place of simple attention layers. The whole model can then be trained end-to-end. The main complication in utilizing this approach within the network itself is the need to backpropagate the gradients through an inference algorithm as part of the structured attention network. Past work has demonstrated the techniques necessary for this approach (see Stoyanov et al. (2011)), but to our knowledge it is very rarely employed. Consider the case of the simple linear-chain CRF layer from equation (3). Figure 2 (left) shows the standard forward-backward algorithm for computing the marginals p(zi = 1 |x, q; ). If we treat the forward-backward algorithm as a neural network layer, its input are the potentials , and its output after the forward pass are these marginals.3 To backpropagate a loss through this layer we need to compute the gradient of the lossLwith respect to ,L , as a function of the gradient of the loss with respect to the marginals, Lp .4 As the forward-backward algorithm consists of differentiable steps, this function can be derived using reverse-mode automatic differentiation of the forward-backward algorithm itself. Note that this reverse-mode algorithm conveniently has a parallel structure to the forward version, and can also be implemented using dynamic programming. However, in practice, one cannot simply use current off-the-shelf tools for this task. For one, efficiency is quite important for these models and so the benefits of handoptimizing the reverse-mode implementation still outweighs simplicity of automatic differentiation. Secondly, numerical precision becomes a major issue for structured attention networks. For computing the forward-pass and the marginals, it is important to use the standard log-space semifield over R with binary operations ( = logadd, = +) to avoid underflow of probabilities. For computing the backward-pass, we need to remain in log- space, but also handle log of negative values (since Lp could be negative). This requires extending to the signed log-space semifield over [R ] +, with special +/ operations. Table 1, based on Li & Eisner (2009), demonstrates how to handle this issue, and Figure 2 (right) describes backpropagation through the forward-backward algorithm. For dependency parsing, the forward pass can be computed using the inside-outside implementation of Eisners algorithm (Eisner, 1996). Similarly, the backpropagation parallels the inside-outside structure. Forward/backward pass through the inside-outside algorithm is described in Appendix B.",
      "exclude": false
    },
    {
      "heading": "4 EXPERIMENTS",
      "text": "We experiment with three instantiations of structured attention networks on four different tasks: (a) a simple, synthetic tree manipulation task using the syntactic attention layer, (b) machine translation with segmentation attention (i.e. two-state linear-chain CRF), (c) question answering using an nstate linear-chain CRF for multi-step inference over n facts, and (d) natural language inference with syntactic tree attention. These experiments are not intended to boost the state-of-the-art for these tasks but to test whether these methods can be trained effectively in an end-to-end fashion, can yield improvements over standard selection-based attention, and can learn plausible latent structures. All model architectures, hyperparameters, and training details are further described in Appendix A.",
      "exclude": false
    },
    {
      "heading": "4.1 TREE TRANSDUCTION",
      "text": "The first set of experiments look at a tree-transduction task. These experiments use synthetic data to explore a failure case of soft-selection attention models. The task is to learn to convert a random formula given in prefix notation to one in infix notation, e.g., ( ( + ( + 15 7 ) 1 8 ) ( + 19 0 11 ) ) ( ( 15 + 7 ) + 1 + 8 ) ( 19 + 0 + 11 ) The alphabet consists of symbols (, ),+, , numbers between 0 and 20, and a special root symbol $. This task is used as a preliminary task to see if the model is able to learn the implicit tree structure on the source side. The model itself is an encoder-decoder model, where the encoder is defined below and the decoder is an LSTM. See Appendix A.2 for the full model. 3Confusingly, forward in this case is different than in the forward-backward algorithm, as the marginals themselves are the output. However the two uses of the term are actually quite related. The forward-backward algorithm can be interpreted as a forward and backpropagation pass on the log partition function. See Eisner (2016) for further details (appropriately titled Inside-Outside and Forward-Backward Algorithms Are Just Backprop). As such our full approach can be seen as computing second-order information. This interpretation is central to Li & Eisner (2009). 4In general we useab to denote the Jacobian of a with respect to b. Training uses 15K prefix-infix pairs where the maximum nesting depth is set to be between 2-4 (the above example has depth 3), with 5K pairs in each depth bucket. The number of expressions in each parenthesis is limited to be at most 4. Test uses 1K unseen sequences with depth between 2-6 (note specifically deeper than train), with 200 sequences for each depth. The performance is measured as the average proportion of correct target tokens produced until the first failure (as in Grefenstette et al. (2015)). For experiments we try using different forms of self -attention over embedding-only encoders. Let xj be an embedding for each source symbol; our three variants of the source representation xj are: (a) no atten, just symbol embeddings by themselves, i.e. xj = xj ; (b) simple attention, symbol embeddings and soft-pairing for each symbol, i.e. xj = [xj ; cj ] where cj = n i=1 softmax(ij)xi is calculated using soft-selection; (c) structured attention, symbol embeddings and soft-parent, i.e. xj = [xj ; cj ] where cj = n i=1 p(zij = 1 |x)xi is calculated using parsing marginals, obtained from the syntactic attention layer. None of these models use an explicit query valuethe potentials come from running a bidirectional LSTM over the source, producing hidden vectors hi, and then computing ij = tanh(s > tanh(W1hi + W2hj + b)) where s,b,W1,W2 are parameters (see Appendix A.1). Depth No Atten Simple Structured 2 7.6 87.4 99.2 3 4.1 49.6 87.0 4 2.8 23.3 64.5 5 2.1 15.0 30.8 6 1.5 8.5 18.2 model is partially reconstructing the arithmetic tree. Figure 3 shows the attention distribution for the simple/structured models on the same source sequence, which indicates that the structured model is able to learn boundaries (i.e. parentheses). 5Thus there are two attention mechanisms at work under this setup. First, structured attention over the source only to obtain soft-parents for each symbol (i.e. self-attention). Second, standard softmax alignment attention over the source representations during decoding.",
      "exclude": false
    },
    {
      "heading": "4.2 NEURAL MACHINE TRANSLATION",
      "text": "Our second set of experiments use a full neural machine translation model utilizing attention over subsequences. Here both the encoder/decoder are LSTMs, and we replace standard simple attention with a segmentation attention layer. We experiment with two settings: translating directly from unsegmented Japanese characters to English words (effectively using structured attention to perform soft word segmentation), and translating from segmented Japanese words to English words (which can be interpreted as doing phrase-based neural machine translation). Japanese word segmentation is done using the KyTea toolkit (Neubig et al., 2011). The data comes from the Workshop on Asian Translation (WAT) (Nakazawa et al., 2016). We randomly pick 500K sentences from the original training set (of 3M sentences) where the Japanese sentence was at most 50 characters and the English sentence was at most 50 words. We apply the same length filter on the provided validation/test sets for evaluation. The vocabulary consists of all tokens that occurred at least 10 times in the training corpus. The segmentation attention layer is a two-state CRF where the unary potentials at the j-th decoder step are parameterized as i(k) = hiWhj , k = 1 0, k = 0 Here [h1, . . . ,hn] are the encoder hidden states and hj is the j-th decoder hidden state (i.e. the query vector). The pairwise potentials are parameterized linearly with b, i.e. all together i,i+1(zi, zi+1) = i(zi) + i+1(zi+1) + bzi,zi+1 Therefore the segmentation attention layer requires just 4 additional parameters. Appendix A.3 describes the full model architecture. We experiment with three attention configurations: (a) standard simple attention, i.e. cj =n i=1 softmax(i)hi; (b) sigmoid attention: multiple selection with Bernoulli random variables, i.e. cj = n i=1 sigmoid(i)hi; (c) structured attention, encoded with normalized CRF marginals, cj = n i=1 p(zi = 1 |x, q) hi = 1 n i=1 p(zi = 1 |x, q) The normalization term is not ideal but we found it to be helpful for stable training.6 is a hyperparameter (we use = 2) and we further add an l2 penalty of 0.005 on the pairwise potentials b. These values were found via grid search on the validation set. Simple Sigmoid Structured CHAR 12.6 13.1 14.6 WORD 14.1 13.8 14.3 For further analysis, Figure 4 shows a visualization of the different attention mechanisms on the character-to-word setup. The simple model generally focuses attention heavily on a single character. In contrast, the sigmoid and structured models are able to spread their attention distribution on contiguous subsequences. The structured attention learns additional parameters (i.e. b) to smooth out this type of attention. 6With standard expectation (i.e. cj = n i=1 p(zi = 1 |x, q)hi) we empirically observed the marginals to quickly saturate. We tried various strategies to overcome this, such as putting an l2 penalty on the unary potentials and initializing with a pretrained sigmoid attention model, but simply normalizing the marginals proved to be the most effective. However, this changes the interpretation of the context vector as the expectation of an annotation function in this case.",
      "exclude": false
    },
    {
      "heading": "4.3 QUESTION ANSWERING",
      "text": "Our third experiment is on question answering (QA) with the linear-chain CRF attention layer for inference over multiple facts. We use the bAbI dataset (Weston et al., 2015), where the input is a set of sentences/facts paired with a question, and the answer is a single token. For many of the tasks the model has to attend to multiple supporting facts to arrive at the correct answer (see Figure 5 for an example), and existing approaches use multiple hops to greedily attend to different facts. We experiment with employing structured attention to perform inference in a non-greedy way. As the ground truth supporting facts are given in the dataset, we are able to assess the models inference accuracy. The baseline (simple) attention model is the End-To-End Memory Network (Sukhbaatar et al., 2015) (MemN2N), which we briefly describe here. See Appendix A.4 for full model details. Let x1, . . . ,xn be the input embedding vectors for the n sentences/facts and let q be the query embedding. In MemN2N, zk is the random variable for the sentence to select at the k-th inference step (i.e. k-th hop), and thus zk 1, . . . , n. The probability distribution over zk is given by p(zk = i |x, q) = softmax((xki )>qk), and the context vector is given by ck = n i=1 p(zk = i |x, q)oki , where xki ,o k i are the input and output embedding for the i-th sentence at the k-th hop, respectively. The k-th context vector is used to modify the query qk+1 = qk + ck, and this process repeats for k = 1, . . . ,K (for k = 1 we have xki = xi,q k = q, ck = 0). The K-th context and query vectors are used to obtain the final answer. The attention mechanism for a K-hop MemN2N network can therefore be interpreted as a greedy selection of a length-K sequence of facts (i.e. z1, . . . , zK). For structured attention, we use an n-state, K-step linear-chain CRF.7 We experiment with two different settings: (a) a unary CRF model with node potentials k(i) = (x k i ) >qk 7Note that this differs from the segmentation attention for the neural machine translation experiments described above, which was a K-state (with K = 2), n-step linear-chain CRF. and (b) a binary CRF model with pairwise potentials k,k+1(i, j) = (x k i ) >qk + (xki ) >xk+1j + (x k+1 j ) >qk+1 The binary CRF model is designed to test the models ability to perform sequential reasoning. For both (a) and (b), a single context vector is computed: c = z1,...,zK p(z1, . . . , zK |x, q)f(x, z) (unlike MemN2N which computes K context vectors). Evaluating c requires summing over all nK possible sequences of length K, which may not be practical for large values of K. However, if f(x, z) factors over the components of z (e.g. f(x, z) = K k=1 fk(x, zk)) then one can rewrite the above sum in terms of marginals: c = K k=1 n i=1 p(zk = i |x, q)fk(x, zk). In our experiments, we use fk(x, zk) = okzk . All three models are described in further detail in Appendix A.4. Results We use the version of the dataset with 1K questions for each task. Since all models reduce to the same network for tasks with 1 supporting fact, they are excluded from our experiments. The number of hops (i.e. K) is task-dependent, and the number of memories (i.e. n) is limited to be at most 25 (note that many question have less than 25 factse.g. the example in Figure 5 has 9 facts). Due to high variance in model performance, we train 20 models with different initializations for each task and report the test accuracy of the model that performed the best on a 10% held-out validation set (as is typically done for bAbI tasks). Results of the three different models are shown in Table 4. For correct answer seletion (Ans %), we find that MemN2N and the Binary CRF model perform similarly while the Unary CRF model does worse, indicating the importance of including pairwise potentials. We also assess each models ability to attend to the correct supporting facts in Table 4 (Fact %). Since ground truth supporting facts are provided for each query, we can check the sequence accuracy of supporting facts for each model (i.e. the rate of selecting the exact correct sequence of facts) by taking the highest probability sequence z = argmax p(z1, . . . , zK |x, q) from the model and checking against the ground truth. Overall the Binary CRF is able to recover supporting facts better than MemN2N. This improvement is significant and can be up to two-fold as seen for task 2, 11, 13 & 17. However we observed that on many tasks it is sufficient to select only the last (or first) fact correctly to predict the answer, and thus higher sequence selection accuracy does not necessarily imply better answer accuracy (and vice versa). For example, all three models get 100% answer accuracy on task 15 but have different supporting fact accuracies. Finally, in Figure 5 we visualize of the output edge marginals produced by the Binary CRF model for a single question in task 16. In this instance, the model is uncertain but ultimately able to select the right sequence of facts 5 6 8.",
      "exclude": false
    },
    {
      "heading": "4.4 NATURAL LANGUAGE INFERENCE",
      "text": "The final experiment looks at the task of natural language inference (NLI) with the syntactic attention layer. In NLI, the model is given two sentences (hypothesis/premise) and has to predict their relationship: entailment, contradiction, neutral. For this task, we use the Stanford NLI dataset (Bowman et al., 2015) and model our approach off of the decomposable attention model of Parikh et al. (2016). This model takes in the matrix of word embeddings as the input for each sentence and performs inter-sentence attention to predict the answer. Appendix A.5 describes the full model. As in the transduction task, we focus on modifying the input representation to take into account soft parents via self-attention (i.e. intra-sentence attention). In addition to the three baselines described for tree transduction (No Attention, Simple, Structured), we also explore two additional settings: (d) hard pipeline parent selection, i.e. xj = [xj ;xhead(j)], where head(j) is the index of xjs parent8; (e) pretrained structured attention: structured attention where the parsing layer is pretrained for one epoch on a parsed dataset (which was enough for convergence). Results Results of our models are shown in Table 5. Simple attention improves upon the no attention model, and this is consistent with improvements observed by Parikh et al. (2016) with their intra-sentence attention model. The pipelined model with hard parents also slightly improves upon the baseline. Structured attention outperforms both models, though surprisingly, pretraining the syntactic attention layer on the parse trees performs worse than training it from scratchit is possible that the pretrained attention is too strict for this task. We also obtain the hard parse for an example sentence by running the Viterbi algorithm on the syntactic attention layer with the non-pretrained model: $ The men are fighting outside a deli . 8The parents are obtained from running the dependency parser of Andor et al. (2016), available at https://github.com/tensorflow/models/tree/master/syntaxnet Despite being trained without ever being exposed to an explicit parse tree, the syntactic attention layer learns an almost plausible dependency structure. In the above example it is able to correctly identify the main verb fighting, but makes mistakes on determiners (e.g. head of The should be men). We generally observed this pattern across sentences, possibly because the verb structure is more important for the inference task.",
      "exclude": false
    },
    {
      "heading": "5 CONCLUSION",
      "text": "This work outlines structured attention networks, which incorporate graphical models to generalize simple attention, and describes the technical machinery and computational techniques for backpropagating through models of this form. We implement two classes of structured attention layers: a linear-chain CRF (for neural machine translation and question answering) and a more complicated first-order dependency parser (for tree transduction and natural language inference). Experiments show that this method can learn interesting structural properties and improve on top of standard models. Structured attention could also be a way of learning latent labelers or parsers through attention on other tasks. It should be noted that the additional complexity in computing the attention distribution increases run-timefor example, structured attention was approximately 5 slower to train than simple attention for the neural machine translation experiments, even though both attention layers have the same asymptotic run-time (i.e. O(n)). Embedding differentiable inference (and more generally, differentiable algorithms) into deep models is an exciting area of research. While we have focused on models that admit (tractable) exact inference, similar technique can be used to embed approximate inference methods. Many optimization algorithms (e.g. gradient descent, LBFGS) are also differentiable (Domke, 2012; Maclaurin et al., 2015), and have been used as output layers for structured prediction in energy-based models (Belanger & McCallum, 2016; Wang et al., 2016). Incorporating them as internal neural network layers is an interesting avenue for future work.",
      "exclude": true
    },
    {
      "heading": "ACKNOWLEDGMENTS",
      "text": "We thank Tao Lei, Ankur Parikh, Tim Vieira, Matt Gormley, Andre Martins, Jason Eisner, Yoav Goldberg, and the anonymous reviewers for helpful comments, discussion, notes, and code. We additionally thank Yasumasa Miyamoto for verifying Japanese-English translations.",
      "exclude": true
    },
    {
      "heading": "A MODEL DETAILS",
      "text": "A.1 SYNTACTIC ATTENTION The syntactic attention layer (for tree transduction and natural language inference) is similar to the first-order graph-based dependency parser of Kipperwasser & Goldberg (2016). Given an input sentence [x1, . . . , xn] and the corresponding word vectors [x1, . . . ,xn], we use a bidirectional LSTM to get the hidden states for each time step i [1, . . . , n], hfwdi = LSTM(xi,h fwd i1) h bwd i = LSTM(xi,h bwd i+1) hi = [h fwd i ;h bwd i ] where the forward and backward LSTMs have their own parameters. The score for xi xj (i.e. xi is the parent of xj), is given by an MLP ij = tanh(s > tanh(W1hi + W2hj + b)) These scores are used as input to the inside-outside algorithm (see Appendix B) to obtain the probability of each words parent p(zij = 1 |x), which is used to obtain the soft-parent cj for each word xj . In the non-structured case we simply have p(zij = 1 |x) = softmax(ij). A.2 TREE TRANSDUCTION Let [x1, . . . , xn], [y1, . . . , ym] be the sequence of source/target symbols, with the associated embeddings [x1, . . . ,xn], [y1, . . . ,ym] with xi,yj Rl. In the simplest baseline model we take the source representation to be the matrix of the symbol embeddings. The decoder is a one-layer LSTM which produces the hidden states hj = LSTM(yj ,h j1), with h j Rl. The hidden states are combined with the input representation via a bilinear map W Rll to produce the attention distribution used to obtain the vector mi, which is combined with the decoder hidden state as follows, i = expxiWh jn k=1 expxkWh j mi = n i=1 ixi hj = tanh(U[mi;h j ]) Here we have W Rll and U R2ll. Finally, hj is used to to obtain a distribution over the next symbol yj+1, p(yj+1 |x1, . . . , xn, y1, . . . , yj) = softmax(Vhj + b) For structured/simple models, the j-th source representation are respectively xi = [ xi; n k=1 p(zki = 1 |x)xk ] xi = [ xi; n k=1 softmax(ki)xk ] where ij comes from the bidirectional LSTM described in A.1. Then i and mi changed accordingly, i = exp xiWh jn k=1 exp xkWh j mi = n i=1 ixi Note that in this case we have W R2ll and U R3ll. We use l = 50 in all our experiments. The forward/backward LSTMs for the parsing LSTM are also 50-dimensional. Symbol embeddings are shared between the encoder and the parsing LSTMs. Additional training details include: batch size of 20; training for 13 epochs with a learning rate of 1.0, which starts decaying by half after epoch 9 (or the epoch at which performance does not improve on validation, whichever comes first); parameter initialization over a uniform distribution U [0.1, 0.1]; gradient normalization at 1 (i.e. renormalize the gradients to have norm 1 if the l2 norm exceeds 1). Decoding is done with beam search (beam size = 5). A.3 NEURAL MACHINE TRANSLATION The baseline NMT system is from Luong et al. (2015). Let [x1, . . . , xn], [y1, . . . , ym] be the source/target sentence, with the associated word embeddings [x1, . . . ,xn], [y1, . . . ,ym]. The encoder is an LSTM over the source sentence, which produces the hidden states [h1, . . . ,hn] where hi = LSTM(xi,hi1) and hi Rl. The decoder is another LSTM which produces the hidden states hj Rl. In the simple attention case with categorical attention, the hidden states are combined with the input representation via a bilinear map W Rll and this distribution is used to obtain the context vector at the j-th time step, i = hiWh j cj = n i=1 softmax(i)hi The Bernoulli attention network has the same i but instead uses a sigmoid to obtain the weights of the linear combination, i.e., cj = n i=1 sigmoid(i)hi And finally, the structured attention model uses a bilinear map to parameterize one of the unary potentials i(k) = hiWh j , k = 1 0, k = 0 i,i+1(zi, zi+1) = i(zi) + i+1(zi+1) + bzi,zi+1 where b are the pairwise potentials. These potentials are used as inputs to the forward-backward algorithm to obtain the marginals p(zi = 1 |x, q), which are further normalized to obtain the context vector cj = n i=1 p(zi = 1 |x, q) hi = 1 n i p(zi = 1 |x, q) We use = 2 and also add an l2 penalty of 0.005 on the pairwise potentials b. The context vector is then combined with the decoder hidden state hj = tanh(U[cj ;h j ]) and hj is used to obtain the distribution over the next target word yj+1 p(yj+1 |x1, . . . , xn, y1, . . . yj) = softmax(Vhj + b) The encoder/decoder LSTMs have 2 layers and 500 hidden units (i.e. l = 500). Additional training details include: batch size of 128; training for 30 epochs with a learning rate of 1.0, which starts decaying by half after the first epoch at which performance does not improve on validation; dropout with probability 0.3; parameter initialization over a uniform distribution U [0.1, 0.1]; gradient normalization at 1. We generate target translations with beam search (beam size = 5), and evaluate with multi-bleu.perl from Moses.9 A.4 QUESTION ANSWERING Our baseline model (MemN2N) is implemented following the same architecture as described in Sukhbaatar et al. (2015). In particular, let x = [x1, . . . , xn] represent the sequence of n facts with the associated embeddings [x1, . . . ,xn] and let q be the embedding of the query q. The embeddings 9https://github.com/moses-smt/mosesdecoder/blob/master/scripts/generic/ multi-bleu.perl are obtained by simply adding the word embeddings in each sentence or query. The full model with K hops is as follows: p(zk = i |x, q) = softmax((xki )>qk) ck = n i=1 p(zk = i |x, q)oki qk+1 = qk + ck p(y |x, q) = softmax(W(qK + cK)) where p(y |x, q) is the distribution over the answer vocabulary. At each layer, xki and oki are computed using embedding matrices Xk and Ok. We use the adjacent weight tying scheme from the paper so that Xk+1 = Ok,WT = OK . X1 is also used to compute the query embedding at the first hop. For k = 1 we have xki = xi,q k = q, ck = 0. For both the Unary and the Binary CRF models, the same input fact and query representations are computed (i.e. same embedding matrices with weight tying scheme). For the unary model, the potentials are parameterized as k(i) = (x k i ) >qk and for the binary model we compute pairwise potentials as k,k+1(i, j) = (x k i ) >qk + (xki ) >xk+1j + (x k+1 j ) >qk+1 The qks are updated simply with a linear mapping, i.e. qk+1 = Qqk In the case of the Binary CRF, to discourage the model from selecting the same fact again we additionally set k,k+1(i, i) = for all i 1, . . . , n. Given these potentials, we compute the marginals p(zk = i, zk+1 = j |x, q) using the forward-backward algorithm, which is then used to compute the context vector: c = z1,...,zK p(z1, . . . , zK |x, q)f(x, z) f(x, z) = K k=1 fk(x, zk) fk(x, zk) = o k zk Note that if f(x, z) factors over the components of z (as is the case above) then computing c only requires evaluating the marginals p(zk |x, q). Finally, given the context vector the prediction is made in a similar fashion to MemN2N: p(y |x, q) = softmax(W(qK + c)) Other training setup is similar to Sukhbaatar et al. (2015): we use stochastic gradient descent with learning rate 0.01, which is divided by 2 every 25 epochs until 100 epochs are reached. Capacity of the memory is limited to 25 sentences. The embedding vectors are of size 20 and gradients are renormalized if the norm exceeds 40. All models implement position encoding, temporal encoding, and linear start from the original paper. For linear start, the softmax() function in the attention layer is removed at the beginning and re-inserted after 20 epochs for MemN2N, while for the CRF models we apply a log(softmax()) layer on the qk after 20 epochs. Each model is trained separately for each task. A.5 NATURAL LANGUAGE INFERENCE Our baseline model/setup is essentially the same as that of Parikh et al. (2016). Let [x1, . . . , xn], [y1, . . . , ym] be the premise/hypothesis, with the corresponding input representations [x1, . . . ,xn], [y1, . . . ,ym]. The input representations are obtained by a linear transformation of the 300-dimensional pretrained GloVe embeddings (Pennington et al., 2014) after normalizing the GloVe embeddings to have unit norm.10 The pretrained embeddings remain fixed but the linear layer 10We use the GloVe embeddings pretrained over the 840 billion word Common Crawl, publicly available at http://nlp.stanford.edu/projects/glove/ (which is also 300-dimensional) is trained. Words not in the pretrained vocabulary are hashed to one of 100 Gaussian embeddings with mean 0 and standard deviation 1. We concatenate each input representation with a convex combination of the other sentences input representations (essentially performing inter-sentence attention), where the weights are determined through a dot product followed by a softmax, eij = f(xi) >f(yj) xi = xi; m j=1 exp eijm k=1 exp eik yj yj = [yj ; n i=1 exp eijn k=1 exp ekj xi ] Here f() is an MLP. The new representations are fed through another MLP g(), summed, combined with the final MLP h() and fed through a softmax layer to obtain a distribution over the labels l, x = n i=1 g(xi) y = m j=1 g(yj) p(l |x1, . . . , xn, y1, . . . , ym) = softmax(Vh([x; y]) + b) All the MLPs have 2-layers, 300 ReLU units, and dropout probability of 0.2. For structured/simple models, we first employ the bidirectional parsing LSTM (see A.1) to obtain the scores ij . In the structured case each word representation is simply concatenated with its soft-parent xi = [ xi; n k=1 p(zki = 1 |x)xk ] and xi (and analogously yj) is used as the input to the above model. In the simple case (which closely corresponds to the intra-sentence attention model of Parikh et al. (2016)), we have xi = [ xi; n k=1 exp kin l=1 exp li xk ] The word embeddings for the parsing LSTMs are also initialized with GloVe, and the parsing layer is shared between the two sentences. The forward/backward LSTMs for the parsing layer are 100- dimensional. Additional training details include: batch size of 32; training for 100 epochs with Adagrad (Duchi et al., 2011) where the global learning rate is 0.05 and sum of gradient squared is initialized to 0.1; parameter intialization over a Gaussian distribution with mean 0 and standard deviation 0.01; gradient normalization at 5. In the pretrained scenario, pretraining is done with Adam (Kingma & Ba, 2015) with learning rate equal to 0.01, and 1 = 0.9, 2 = 0.999.",
      "exclude": false
    },
    {
      "heading": "B FORWARD/BACKWARD THROUGH THE INSIDE-OUTSIDE ALGORITHM",
      "text": "Figure 6 shows the procedure for obtaining the parsing marginals from the input potentials. This corresponds to running the inside-outside version of Eisners algorithm (Eisner, 1996). The intermediate data structures used during the dynamic programming algorithm are the (log) inside tables , and the (log) outside tables . Both , are of size nn22, where n is the sentence length. First two dimensions encode the start/end index of the span (i.e. subtree). The third dimension encodes whether the root of the subtree is the left (L) or right (R) index of the span. The fourth dimension indicates if the span is complete (1) or incomplete (0). We can calculate the marginal distribution of each words parent (for all words) in O(n3) using this algorithm. Backward pass through the inside-outside algorithm is slightly more involved, but still takes O(n3) time. Figure 7 illustrates the backward procedure, which receives the gradient of the loss L with respect to the marginals, Lp , and computes the gradient of the loss with respect to the potentials L . The computations must be performed in the signed log-space semifield to handle log of negative values. See section 3.3 and Table 1 for more details.",
      "exclude": false
    }
  ],
  "fewShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": false,
        "confidence": 0.92,
        "primary_reason": "Novel integration of graphical model inference (CRFs, dependency parsing) as differentiable neural network layers. Strong methodological contribution with rigorous treatment of backpropagation through structured inference. Comprehensive experiments across diverse tasks (tree transduction, NMT, QA, NLI) demonstrating effectiveness and generalization of structured attention beyond standard soft-selection."
      },
      "token": {
        "prompt_tokens": 11169,
        "completion_tokens": 114,
        "total_tokens": 11283
      },
      "time": "2026-02-08T22:10:18.038524+00:00"
    }
  ],
  "test": false
}