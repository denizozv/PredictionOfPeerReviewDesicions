{
  "id": "471",
  "title": "Batch Policy Gradient  Methods for  Improving Neural Conversation Models",
  "abstract": "We study reinforcement learning of chat-bots with recurrent neural network architectures when the rewards are noisy and expensive to obtain. For instance, a chat-bot used in automated customer service support can be scored by quality assurance agents, but this process can be expensive, time consuming and noisy.  Previous reinforcement learning work for natural language uses on-policy updates and/or is designed for on-line learning settings. We demonstrate empirically that such strategies are not appropriate for this setting and develop an off-policy batch policy gradient method (\\bpg). We demonstrate the efficacy of our method via a series of synthetic experiments and an Amazon Mechanical Turk experiment on a restaurant recommendations dataset.",
  "accepted": true,
  "zeroShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": false,
        "confidence": 0.72,
        "primary_reason": "Novel off-policy batch policy gradient method for seq2seq models with noisy rewards; solid theoretical grounding and empirical validation on realistic chatbot task, though limited experimental scope and modest improvements on real data."
      },
      "token": {
        "prompt_tokens": 7319,
        "completion_tokens": 71,
        "total_tokens": 7390
      },
      "time": "2026-02-05T22:50:19.221809+00:00"
    }
  ],
  "article": [
    {
      "heading": "1 INTRODUCTION",
      "text": "Chatbots are one of the classical applications of artificial intelligence and are now ubiquitous in technology, business and everyday life. Many corporate entities are now increasingly using chatbots to either replace or assist humans in customer service contexts. For example, Microsoft is currently actively building a chat bot to optimise and streamline its technical support service. In these scenarios, there is usually an abundance of historical data since past conversations between customers and human customer service agents are usually recorded by organisations. An apparently straightforward solution would be to train chatbots to reproduce the responses by human agents using standard techniques such as maximum likelihood. While this seems natural, it is far from desirable for several reasons. It has been observed that such procedures have a tendency to produce very generic responses (Sordoni et al., 2015). For instance, when we trained chatbots via maximum likelihood on a restaurant recommendations dataset, they repeatedly output responses to the effect of How large is your group?, What is your budget? etc. Further, they also produce responses such as Let me look that up. or Give me a second. which, although permissible for a human agent to say, are not appropriate for a chatbot. Although there are ways to increase the diversity of responses (Li et al., 2015), our focus is on encouraging the bot to meaningfully advance the conversation. One way to address this problem is to provide some form of weak supervision for responses generated by a chatbot. For example, a human labeller, such as a quality assurance agent, could score each response generated by a chatbot in a conversation with a customer. This brings us to the reinforcement learning (RL) paradigm where these rewards (scores) are to be used to train a good chatbot. In this paper we will use the terms score, label, and reward interchangeably. Labelled data will mean conversations which have been assigned a reward of some form as explained above. Nonetheless, there are some important differences in the above scenario when compared to the more popular approaches for RL. Noisy and expensive rewards: Obtaining labels for each conversation can be time consuming and economically expensive. As a result, there is a limited amount of labelled data available. Moreover, labels produced by humans are invariably noisy due to human error and subjectivity. Off-line evaluations: Unlike conventional RL settings, such as games, where we try to find the optimal policy while interacting with the system, the rewards here are not immediately available. Previous conversations are collected, labelled by human experts, and then given to an algorithm which has to manage with the data it has. Unlabelled Data: While labelled data is limited, a large amount of unlabelled data is available. If labelled data is in short supply, reinforcement learning could be hopeless. However, if unlabelled data can be used to train a decent initial bot, say via maximum likelihood, we can use policy iteration techniques to refine this bot by making local improvements using the labelled data (Bellman, 1956). Besides chatbots, this framework also finds applications in tasks such as question answering (Ferrucci et al., 2010; Hermann et al., 2015; Sachan et al., 2016), generating image descriptions (Karpathy & Fei-Fei, 2015) and machine translation (Bahdanau et al., 2014) where a human labeller can provide weak supervision in the form of a score to a sentence generated by a bot. To contextualise the work in this paper, we make two important distinctions in policy iteration methods in reinforcement learning. The first is on-policy vs off-policy. In on-policy settings, the goal is to improve the current policy on the fly while exploring the space. On-policy methods are used in applications where it is necessary to be competitive (achieve high rewards) while simultaneously exploring the environment. In off-policy, the environment is explored using a behaviour policy, but the goal is to improve a different target policy. The second distinction is on-line vs batch (off-line). In on-line settings one can interact with the environment. In batch methods, which is the setting for this work, one is given past exploration data from possibly several behaviour policies and the goal is to improve a target policy using this data. On-line methods can be either on-policy or off-policy whereas batch methods are necessarily off-policy. In this paper, we study reinforcement learning in batch settings, for improving chat bots with Seq2Seq recurrent neural network (RNN) architectures. One of the challenges when compared to on-line learning is that we do not have interactive control over the environment. We can only hope to do as well as our data permits us to. On the other hand, the batch setting affords us some luxuries. We can reuse existing data and use standard techniques for hyper-parameter tuning based on cross validation. Further, in on-line policy updates, we have to be able to guess how an episode will play out, i.e. actions the behaviour/target policies would take in the future and corresponding rewards. However, in batch learning, the future actions and rewards are directly available in the data. This enables us to make more informed choices when updating our policy.",
      "exclude": true
    },
    {
      "heading": "RELATED WORK",
      "text": "Recently there has been a surge of interest in deep learning approaches to reinforcement learning, many of them adopting Q-learning, e.g. (He et al., 2015; Mnih et al., 2013; Narasimhan et al., 2015). In Q-learning, the goal is to estimate the optimal action value function Q. Then, when an agent is at a given state, it chooses the best greedy action according to Q. While Q-learning has been successful in several applications, it is challenging in the settings we consider since estimating Q over large action and state spaces will require a vast number of samples. In this context, policy iteration methods are more promising since we can start with an initial policy and make incremental local improvements using the data we have. This is especially true given that we can use maximum likelihood techniques to estimate a good initial bot using unlabelled data. Policy gradient methods, which fall within the paradigm of policy iteration, make changes to the parameters of a policy along the gradient of a desired objective (Sutton et al., 1999). Recently, the natural language processing (NLP) literature has turned its attention to policy gradient methods for improving language models. Ranzato et al. (2015) present a method based on the classical REINFORCE algorithm (Williams, 1992) for improving machine translation after preliminary training with maximum likelihood objectives. Bahdanau et al. (2016) present an actor-critic method also for machine translation. In both cases, as the reward, the authors use the BLEU (bilingual evaluation understudy) score of the output and the translation in the training dataset. This setting, where the rewards are deterministic and cheaply computable, does not reflect difficulties inherent to training chatbots where labels are noisy and expensive. Li et al. (2016) develop a policy gradient method bot for chatbots. However, they use user defined rewards (based on some simple rules) which, once again, are cheaply obtained and deterministic. Perhaps the closest to our work is that of Williams & Zweig (2016) who use a REINFORCE based method for chat bots. We discuss the differences of this and other methods in greater detail in Section 3. The crucial difference between all of the above efforts and ours is that they use on-policy and/or on-line updates in their methods. The remainder of this manuscript is organised as follows. In Section 2 we review Seq2Seq models and Markov decision processes (MDP) and describe our framework for batch reinforcement learning. Section 3 presents our method BPG and compares it with prior work in the RL and NLP literature. Section 4 presents experiments on a synthetic task and a customer service dataset for restaurant recommendations.",
      "exclude": true
    },
    {
      "heading": "2 PRELIMINARIES",
      "text": "",
      "exclude": false
    },
    {
      "heading": "2.1 A REVIEW OF SEQ2SEQ MODELS",
      "text": "The goal of a Seq2Seq model in natural language processing is to produce an output sequence y = [a1, a2, . . . , aT ] given an input sequence x (Cho et al., 2014; Kalchbrenner & Blunsom, 2013; Sutskever et al., 2014). Here ai A where A is a vocabulary of words. For example, in machine translation from French to English, x is the input sequence in French, and y is its translation in English. In customer service chatbots, x is the conversation history until the customers last query and y is the response by an agent/chatbot. In a Seq2Seq model, we use an encoder network to represent the input sequence as a euclidean vector and then a decoder network to convert this vector to an output sequence. Typically, both the encoder and decoder networks are recurrent neural networks (RNN) (Mikolov et al., 2010) where the recurrent unit processes each word in the input/output sequences one at a time. In this work, we will use the LSTM (long short term memory) (Hochreiter & Schmidhuber, 1997) as our recurrent unit due to its empirical success in several applications. In its most basic form, the decoder RNN can be interpreted as assigning a probability distribution over A given the current state. At time t, the state st is the input sequence x and the words yt1 = [a1, . . . , at1] produced by the decoder thus far, i.e. st = (x, yt1). We sample the next word at from this probability distribution (|st), then update our state st+1 = (x, yt) where yt = [yt1, at], and proceed in a similar fashion. The vocabulary A contains an end-of-statement token . If we sample at time T + 1, we terminate the sequence and output yT .",
      "exclude": false
    },
    {
      "heading": "2.2 A REVIEW OF MARKOV DECISION PROCESSES (MDP)",
      "text": "We present a formalism for MDPs simplified to our setting. In an MDP, an agent takes an action a in a state s and transitions to a state s. An episode refers to a sequence of transitions s1 a1 s2 a2 aT sT+1 until the agent reaches a terminal state sT+1. At a terminal state, the agent receives a reward. Formally, an MDP is the triplet (S,A, R). Here, S is a set of states andA is a set of actions. When we take an action a at state s we transition to a new state s = s(s, a) which, in this work, will be deterministic. A will be a finite but large discrete set and S will be discrete but potentially infinite. R : S R is the expected reward function such that when we receive a reward r at state s S, E[r] = R(s). Let S0 S be a set of terminal states. When we transition to any s S0, the episode ends. In this work, we will assume that the rewards are received only at a terminal state, i.e R(s) is nonzero only on S0. A policy is a rule to select an action at a given state. We will be focusing on stochastic policies : AS R+ where (a|s) denotes the probability an agent will execute action a at state s. We define the value function V : S R of policy , where V (s) is the expected reward at the end of the episode when we follow policy from state s. For any terminal state s S0, V (s) = R(s) regardless of . We will also find it useful to define the action-value function Q : S A : R, where Q(s, a) is the expected reward of taking action a at state s and then following policy . With deterministic state transitions this is simply Q(s, a) = V (s(s, a)). It can be verified that V (s) = Ea(|s) [Q(s, a)] (Sutton & Barto, 1998).",
      "exclude": false
    },
    {
      "heading": "2.3 SET UP",
      "text": "We now frame our learning from labels scenario for RNN chatbots as an MDP. The treatment has similarities to some recent RL work in the NLP literature discussed above. Let x be the input and yt1 = [a1, . . . , at1] be the words output by the decoder until time t. The state of our MDP at time t of the current episode will be st = (x, yt1). Therefore, the set of states S will be all possible pairs of inputs and partial output sequences. The actions A will be the vocabulary. The terminal states S0 will be (x, y) such that the last literal of y is . The stochastic policy will be a Seq2Seq RNN which produces a distribution overA given state st. When we wish to make the dependence of the policy on the RNN parameters explicit, we will write . When we sample an action at (|st), we deterministically transition to state (x, [yt1, at]). If we sample aT+1 = at time T + 1, the episode terminates and we observe a stochastic reward. We are given a dataset of input-output-reward triples (x(i), y(i), r(i))ni=1 where y(i) = (a (i) 1 , . . . , a (i) Ti , ) is the sequence of output words. This data was collected from possibly multiple behaviour policies which output y(i) for the given input x(i). In the above customer service example, the behaviour policies could be chatbots, or even humans, which were used for conversations with a customer. The rewards ri are scores assigned by a human quality assurance agent to each response of the chatbot. Our goal is to use this data to improve a given target policy . We will use q to denote the distribution of the data. q(s) is the distribution of the states in the dataset, q(a|s) is the conditional distribution of an action given a state, and q(s, a) = q(s)q(a|s) is the joint distribution over states and actions. q will be determined by the initial distribution of the inputs x(i) and the behaviour policies used to collect the training data. Our aim is to find a policy that does well with respect to q. Specifically, we wish to maximise the following objective, J() = sS q(s)V (s). (1) Here, the value function V is not available to us but has to be estimated from the data. This is similar to objectives used in on-line off-policy policy gradient literature where q is replaced by the limiting distribution of the behaviour policy (Degris et al., 2012). In the derivation of our algorithm, we will need to know q(a|s) to compute the gradient of our objective. In off-policy reinforcement learning settings this is given by the behaviour policy which is readily available. If the behaviour policy if available to us, then we can use this too. Otherwise, a simple alternative is to learn a behaviour policy. For example, in our experiments we used an RNN trained using the unlabelled data to obtain values for q(a|s). As long as this learned policy can capture the semantics of natural language (for example, the word apple is more likely than car when the current state is (x, I ate an)), then it can be expected to do reasonably well. In the following section, we will derive a stochastic gradient descent (SGD) procedure that will approximately minimise (1). Before we proceed, we note that it is customary in the RL literature to assume stochastic transitions between states and use rewards at all time steps instead of the terminal step. Further, the future rewards are usually discounted by a discount factor < 1. While we use the above formalism to simplify the exposition, the ideas presented here extend naturally to more conventional settings.",
      "exclude": false
    },
    {
      "heading": "3 BATCH POLICY GRADIENT",
      "text": "Our derivation follows the blueprint in Degris et al. (2012) who derive an off-policy on-line actor critic algorithm. Following standard policy gradient methods, we will aim to update the policy by taking steps along the gradient of the objectiveJ(). J() = Esq [ aA (a|s)Q (s, a) ] = Esq [ aA (a|s)Q (s, a) + (a|s)Q (s, a) ] . The latter term inside the above summation is difficult to work with, so the first step is to ignore it and work with the approximate gradient g() = Esq[ aA(a|s)Q (s, a)] J(). Degris et al. (2012) provide theoretical justification for this approximation in off policy settings by establishing that J() J( + g()) for all small enough . Expanding on g(), we obtain: g() = Esq [ aA (a|s) (a|s) (a|s) Q (s, a) ] = E sq aq(|s) [ (s, a)(a, s)Q (s, a) ] = E(st,at)q(,) [(st, at)(at, st)(Q (st, at) V (st))] . (2) Here (a, s) = (a|s)(a|s) = log (a|s) is the score function of the policy and (s, a) = (a|s)/q(a|s) is the importance sampling coefficient. In the last step, we have used the fact that E[(a|s)(a|s)h(s)] = 0 for any function h : S R of the current state (Szepesvari, 2010). The purpose of introducing the value function V is to reduce the variance of the SGD updates we want to assess how good/bad action at is relative to how well will do at state st in expectation. If at is a good action (Q (st, at) is large relative to V (st)), the coefficient of the score function is positive and it will change so as to assign a higher probability to action at at state st. The Q , V functions are not available to us so we will replace them with estimates. For V (st) we will use an estimate V (st) we will discuss choices for this shortly. However, the action value function is usually not estimated in RL policy gradient settings to avoid the high sample complexity. A sensible stochastic approximation for Q (st, at) is to use the sum of future rewards from the current state (Sutton & Barto, 1998)1. If we receive reward r at the end of the episode, we can then use Q (st, at) r for all time steps t in the episode. However, since q(at|st) is different from (at|st) we will need to re-weight future rewards via importance sampling r T i=t (si, ai). This is to account for the fact that an action a given s may have been more likely under the policy (|s) than it was under q(|s) or vice versa. Instead of directly using the re-weighted rewards, we will use the so called return which is a convex combination of the re-weighted rewards and the value function (Sutton, 1988; 1984). In our setting, they are defined recursively from the end of the episode t = T + 1 to t = 1 as follows. For (0, 1], rT+1 = r, r t = (1 )V (st+1) + (st, at)rt+1 for t = T, . . . , 1. (3) The purpose of introducing is to reduce the variance of using the future rewards alone as an estimate for Q (st, at). This is primarily useful when rewards are noisy. If the rewards are deterministic, = 1 which ignores the value function is the best choice. In noisy settings, it is recommended to use (s)) where is the logistic function and (s) Rd is a Euclidean representation of the state. For V (s) of the above form, the Hessian 2V (s) can be computed in O(d) time. To estimate this value function, we use the GTD() estimator from Maei (2011). As (s) we will be using the hidden state of the LSTM. The rationale for this is as follows. In an LSTM trained using maximum likelihood, the hidden state contains useful information about the objective. If there is overlap between the maximum likelihood and reinforcement learning objectives, we can expect the hidden state to also carry useful information about the RL objective. Therefore, we can use the hidden state to estimate the value function whose expectation is the RL objective. We have described our implementation of GTD() in Appendix A and specified some implementation details in Section 4. 1 Note Q (st, at) = V (st+1) for deterministic transitions. However, it is important not to interpret the term in (2) as the difference in the value function between successive states. Conditioned on the current time step, V (st) is deterministic, while V (st+1) is stochastic. In particular, while a crude estimate suffices for the former, the latter is critical and should reflect the rewards received during the remainder of the episode. Algorithm 1 Batch Policy Gradient (BPG) Given: Data (xi, yi, ri)ni=1, step size , return coefficient , initial 0. Set 0. For each epoch k = 1, 2, . . . I Set 0 I For each episode i = 1, . . . , n rT+1 ri t (a(i)t |s (i) t )/q(a (i) t |s (i) t ) for t = 1, . . . , T (i). For each time step in reverse t = T (i), . . . , 1 (i) rt (1 )V (s (i) t+1) + tr t+1 (ii) + 1 T (i) t(s (i) t , a (i) t )(r t V (s (i) t )) (iii) Compute updates for the value function estimate V . I Update the policy + I Update the value function estimate V .",
      "exclude": false
    },
    {
      "heading": "COMPARISON WITH OTHER RL APPROACHES IN NLP",
      "text": "Policy gradient methods have been studied extensively in on policy settings where the goal is to improve the current policy on the fly (Amari, 1998; Williams, 1992). To our knowledge, all RL approaches in Seq2Seq models have also adopted on-policy policy gradient updates (Bahdanau et al., 2016; Li et al., 2016; Ranzato et al., 2015; Williams & Zweig, 2016). However, on policy methods break down in off-policy settings, because any update must account for the probability of the action under the target policy. For example, suppose the behaviour policy took action a at state s and received a low reward. Then we should modify the target policy so as to reduce (a|s). However, if the target policy is already assigning low probability to a|s then we should not be as aggressive when making the updates. The re-weighting (s, a) via importance sampling does precisely this. A second difference is that we study batch RL. Standard on-line methods are designed for settings where we have to continually improve the target while exploring using the behaviour policy. Critical to such methods are the estimation of future rewards at the current state and the future actions that will be taken by both the behaviour and target policies. In order to tackle this, previous research either ignore future rewards altogether (Williams, 1992), resort to heuristics to distribute a delayed reward to previous time steps (Bahdanau et al., 2016; Williams & Zweig, 2016), or make additional assumptions about the distribution of the states such as stationarity of the Markov process (Degris et al., 2012; Maei, 2011). However, in batch settings, the -return from a given time step can be computed directly (3) since the future action and rewards are available in the dataset. Access to this information provides a crucial advantage over techniques designed for on-line settings.",
      "exclude": false
    },
    {
      "heading": "4 EXPERIMENTS",
      "text": "Implementation Details: We implement our methods using Chainer (Tokui et al., 2015), and group sentences of the same length together in the same batch to make use of GPU parallelisation. Since different batches could be of different length, we do not normalise the gradients by the batch size as we should take larger steps after seeing more data. However, we normalise by the length of the output sequence to allocate equal weight to all sentences. We truncate all output sequences to length 64 and use a maximum batch size of 32. We found it necessary to use a very small step size (105), otherwise the algorithm has a tendency to get stuck at bad parameter values. While importance reweighting is necessary in off-policy settings, it can increase the variance of the updates, especially when q(at|st) is very small. A common technique to alleviate this problem is to clip the (st, at) value (Swaminathan & Joachims, 2015). In addition to single (st, at) values, our procedure has a product of (st, at) values when computing the future rewards (3). The effect of large values is a large weight t(rt V (st)) for the score function in step (ii) of Algorithm 1. In our implementation, LSTM LSTM LSTM LSTM LSTM LSTM softmax softmax softmax LSTM LSTM LSTM LSTM Encoder Decoder we clip this weight at 5 which controls the variance of the updates and ensures that a single example does not disproportionately affect the gradient. RNN Design: In both experiments we use deep LSTMs with two layers for the encoder and decoder RNNs. The output of the bottom layer is fed to the top layer and in the decoder RNN, the output of the top layer is fed to a softmax layer of size |A|. When we implement GTD() to estimate V we use the hidden state of the bottom LSTM as (s). When performing our policy updates, we only change the parameters of the top LSTM and the softmax layer in our decoder RNN. If we were to change the bottom LSTM too, then the state representation (s) would also change as the policy changes. This violates the MDP framework. In other words, we treat the bottom layer as part of the environment in our MDP. To facilitate a fair comparison, we only modify the top LSTM and softmax layers in all methods. We have illustrated this set up in Fig. 1. We note that if one is content with using the constant estimator, then one can change all parameters of the RNN.",
      "exclude": false
    },
    {
      "heading": "4.1 SOME SYNTHETIC EXPERIMENTS ON THE EUROPARL DATASET",
      "text": "To convey the main intuitions of our method, we compare our methods against other baselines on a synthetic task on the European parliament proceedings corpus (Koehn, 2005). We describe the experimental set up briefly, deferring details to Appendix B.1. The input sequence to the RNN was each sentence in the dataset. Given an input, the goal was to reproduce the words in the input without repeating words in a list of forbidden words. The RL algorithm does not explicitly know either goal of the objective but has to infer it from the stochastic rewards assigned to input output sequences in the dataset. We used a training set of 500 input-output-reward triplets for the RL methods. We initialised all methods by maximum likelihood training on 6000 input output sequences where the output sequence was the reverse of the input sequence. The maximum likelihood objective captures part of the RL objective. This set up reflects naturally occurring practical scenarios for the algorithm where a large amount unlabelled data can be used to bootstrap a policy if the maximum likelihood and reinforcement learning objectives are at least partially aligned. We trained the RL algorithms for 200 epochs on the training set. At the end of each epoch, we generated outputs from the policy on test set of 500 inputs and scored them according to our criterion. We plot the test set error against the number of epochs for various methods in Fig. 2. Fig. 2(a) compares 3 methods: BPG with and without maximum likelihood initialisation and a version of BPG which does not use importance sampling. Clearly, bootstrapping an RL algorithm with ML can be advantageous especially if data is abundantly available for ML training. Further, without importance sampling, the algorithm is not as competitive for reasons described in Section 3. In all 3 cases, we used a constant estimator for V and = 0.5. The dashed line indicates the performance of ML training alone. BPG-NIS is similar to the algorithms of Ranzato et al. (2015); Williams & Zweig (2016) except that there, their methods implicitly use = 1. Fig. 2(b) compares 4 methods: BPG and its on-line version OPG with constant (CONST) and GTD() estimators for V . The on-line versions of the algorithms are a direct implementation of the method in Degris et al. (2012) which do not use the future rewards as we do. The first observation is that while GTD() is slightly better in the early iterations, it performs roughly the same as using a constant estimator in the long run. Next, BPG performs significantly better than OPG. We believe this is due to the following two reasons. First, the online updates assume stationarity of the MDP. When this does not hold, such as in limited data instances like ours, the SGD updates can be very noisy. Secondly, the value function estimate plays a critical role in the online version. While obtaining a reliable estimate V is reasonable in on-line settings where we can explore indefinitely to collect a large number of samples, it is difficult when one only has a limited number of labelled samples. Finally, we compare BPG with different choices for in Fig. 2(c). As noted previously, < 1 is useful with stochastic rewards, but choosing too small a value is detrimental. The optimal value may depend on the problem.",
      "exclude": false
    },
    {
      "heading": "4.2 RESTAURANT RECOMMENDATIONS",
      "text": "We use data from an on-line restaurant recommendation service. Customers log into the service and chat with a human agent asking recommendations for restaurants. The agents ask a series of questions such as food preferences, group size etc. before recommending a restaurant. The goal is to train a chatbot (policy) which can replace or assist the agent. For reasons explained in Section 1, maximum likelihood training alone will not be adequate. By obtaining reward labels for responses produced by various other bots, we hope to improve on a bot initialised using maximum likelihood. Data Collection: We collected data for RL as follows. We trained five different RNN chatbots with different LSTM parameters via maximum likelihood on a dataset of 6000 conversations from this dataset. The bots were trained to reproduce what the human agent said (output y) given the past conversation history (input x). While the dataset is relatively small, we can still expect our bots to do reasonably well since we work in a restricted domain. Next, we generated responses from these bots on 1216 separate conversations and had them scored by workers on Amazon Mechanical Turk (AMT). For each response by the bots in each conversation, the workers were shown the history before the particular response and asked to score (label) each response on a scale of 0 1 2. We collected scores from three different workers for each response and used the mean as the reward. Policies and RL Application: Next, we initialised 2 bots via maximum likelihood and then used BPG to improve them using the labels collected from AMT. For the 2 bots we used the following LSTM hidden state size H , word embedding size E and BPG parameters. These parameters were chosen arbitrarily and are different from those of the bots used in data collection described above. Bot-1: H = 512, E = 256. BPG: = 0.5, GTD() estimator for V . Bot-2: H = 400, E = 400. BPG: = 0.5, constant estimator for V . Testing: We used a separate test set of 500 conversations which had a total of more than 3500 inputoutput (conversation history - response) pairs. For each Bot-1 and Bot-2 we generated responses before and after applying BPG, totalling 4 responses per input. We then had them scored by workers on AMT using the same set up described above. The same worker labels the before-BPG and afterBPG responses from the same bot. This controls spurious noise effects and allows us to conduct a paired test. We collected 16, 808 before and after label pairs each for Bot-1 and Bot-2 and compare them using a paired t-test and a Wilcoxon signed rank test. Results: The results are shown in Table 1. The improvements on Bot-2 are statistically significant at the 10% level on both tests, while Bot-1 is significant on the Wilcoxon test. The large p-values for Bot-1 are due to the noisy nature of AMT experiments and we believe that we can attain significance if we collect more labels which will reduce the standard error in both tests. In Appendix B.2 we present some examples of conversation histories and the responses generated by the bots before and after applying BPG. We qualitatively discuss specific kinds of issues that we were able to overcome via reinforcement learning.",
      "exclude": false
    },
    {
      "heading": "5 CONCLUSION",
      "text": "We presented a policy gradient method for batch reinforcement learning to train chatbots. The data to this algorithm are input-output sequences generated using other chatbots/humans and stochastic rewards for each output in the dataset. This setting arises in many applications, such as customer service systems, where there is usually an abundance of unlabelled data, but labels (rewards) are expensive to obtain and can be noisy. Our algorithm is able to efficiently use minimal labelled data to improve chatbots previously trained through maximum likelihood on unlabelled data. While our method draws its ideas from previous policy gradient work in the RL and NLP literature, there are some important distinctions that contribute to its success in the settings of interest for this work. Via importance sampling we ensure that the probability of an action is properly accounted for in off-policy updates. By explicitly working in the batch setting, we are able to use knowledge of future actions and rewards to converge faster to the optimum. Further, we use the unlabelled data to initialise our method and also learn a reasonable behaviour policy. Our method outperforms baselines on a series of synthetic and real experiments. The ideas presented in this work extend beyond chatbots. They can be used in applications such as question answering, generating image descriptions and machine translation where an output sentence generated by a policy is scored by a human labeller to provide a weak supervision signal.",
      "exclude": true
    },
    {
      "heading": "ACKNOWLEDGEMENTS",
      "text": "We would like to thank Christoph Dann for the helpful conversations and Michael Armstrong for helping us with the Amazon Mechanical Turk experiments.",
      "exclude": false
    },
    {
      "heading": "APPENDIX",
      "text": "A IMPLEMENTATION OF GTD() We present the details of the GTD() algorithm (Maei, 2011) to estimate a value function in Algorithm 2. However, while Maei (2011) give an on-line version we present the batch version here where the future rewards of an episode are known. We use a parametrisation of the form V (s) = V(s) = ( >(s)) where Rd is the parameter to be estimated. (z) = 1/(1 + ez) is the logistic function. The algorithm requires two step sizes , below for the updates to and the ancillary parameter w. Following the recommendations in Borkar (1997), we use . In our implementations, we used = 105 and = 106. When we run BPG, we perform steps (a)-(f) of Algorithm 2 in step (iii) of Algorithm 1 and the last two update steps of Algorithm 2 in the last update step of Algorithm 1. The gradient and Hessian of V have the following forms, V(s) = V(s)(1 V(s))(s), 2V(s) = V(s)(1 V(s))(1 2V(s))(s)(s)>. The Hessian product in step (d) of Algorithm 2 can be computed in O(d) time via, 2V(s) w = [ V(s)(1 V(s))(1 2V(s))((s)>w) ] (s). Algorithm 2 GTD() Given: Data (xi, yi, ri)ni=1, step sizes , , return coefficient , initial 0. Set 0, w 0. For each epoch k = 1, 2, . . . I Set 0, w 0. I For each episode i = 1, . . . , n Set rT+1 ri, gT+1 0, qT+1 0 t (a(i)t |s (i) t )/q(a (i) t |s (i) t ) for t = 1, . . . , T (i). For each time step in reverse t = T (i), . . . , 1: (a) gt t ( (1 )V(s(i)t+1) + trt+1 ) (b) qt t ( (1 )V(s(i)t+1) + qt+1 ) (c) t gt V(s (i) t ) (d) ht ( t w>V(s(i)t ) ) 2V(s (i) t ) w (e) w w + 1 T (i) ( t w>V(s(i)t ) ) V(s(i)t ) (f) + 1 T (i) ( tV(s(i)t ) qt w>V(s (i) t ) ht ) I w w + w. I + .",
      "exclude": true
    },
    {
      "heading": "B ADDENDUM TO EXPERIMENTS",
      "text": "",
      "exclude": false
    },
    {
      "heading": "B.1 DETAILS OF THE SYNTHETIC EXPERIMENT SET UP",
      "text": "Given an input and output sequence, we used the average of five Bernoulli rewards Bern(r), where the parameter r was r = 0.75 rr + 0.25 rf. Here rr was the fraction of common words in the input and output sequences while rf = 0.01pf where pf is the fraction of forbidden words in the dataset. As the forbidden words, we used the 50 most common words in the dataset. So if an input had 10 words of which 2 were forbidden, an output sequence repeating 7 of the allowed words and 1 forbidden word would receive an expected score of 0.75 (8/10) + 0.25 0.01(1/8) = 0.7406. The training and testing set for reinforcement learning were obtained as follows. We trained 4 bots using maximum likelihood on 6000 input output sequences as indicated in Section 4.1. The LSTM hidden state size H and word embedding size E for the 4 bots were, (H,E) = (256, 128), (128, 64), (64, 32), (32, 16). The vocabulary size was |A| = 12000. We used these bots to generate outputs for 500 different input sequences each. This collection of input and output pairs was scored stochastically as described above to produce a pool of 2000 input-output-score triplets. From this pool we use a fixed set of 500 triplets for testing across all our experiments. From the remaining 1500 data points, we randomly select 500 for training for each execution of an algorithm. For all RL algorithms, we used an LSTM with 16 layers and 16 dimensional word embeddings.",
      "exclude": false
    },
    {
      "heading": "B.2 ADDENDUM TO THE AMT RESTAURANT RECOMMENDATIONS EXPERIMENT",
      "text": "",
      "exclude": false
    },
    {
      "heading": "MORE DETAILS ON THE EXPERIMENTAL SET UP",
      "text": "We collected the initial batch of training data for RL as follows: We trained, via maximum likelihood on 6000 conversations, five RNN bots whose LSTM hidden sizeH and word embedding sizeE were (H,E) = (512, 512), (256, 256), (128, 128), (512, 256), (256, 64). The inputs x were all words from the history of the conversation truncated at length 64, i.e. the most recent 64 words in the conversation history. The outputs were the actual responses of the agent which were truncated to length 64. As the vocabulary we use the |A| = 4000 most commonly occurring words in the dataset and replace the rest with an token. Using the bots trained this way we generate responses on 1216 separate conversations. This data was sent to AMT workers who were asked to label the conversations on the following scale. 2: The response is coherent and appropriate given the history and advances the conversation forward. 1: The response has some minor flaws but is discernible and appropriate. 0: The response is either completely incoherent or inappropriate and fails to advance the conversation forward.",
      "exclude": false
    },
    {
      "heading": "SOME QUALITATIVE RESULTS",
      "text": "In Tables 2 and 3 we have presented some examples. The text in black/grey shows the conversation history, the response in blue is by the bot trained via maximum likelihood (ML) alone and in red is the bot after improvement using our BPG reinforcement learning algorithm. The first two examples of Table 2 present examples where the ML algorithm repeated generic questions (on budget, group size etc.) even though they had already been answered previously. After applying BPG, we are able to correct such issues, even though there are some grammatical errors. In the second, third and fourth example, we see that the ML+BPG bot is able to take context into consideration well when responding. For example, the customer asks for oriental/Mexican/Italian food. While the ML bot doesnt take this into consideration, the ML+BPG bot is able to provide relevant answers. However, in the third example, the name of the restaurant suggests that the food might be Indian and not Mexican. In the final example of Table 2 the customer asks a direct question about smoking. The ML bot provides an irrelevant answer where as the ML+BPG bot directly responds to the question. In some examples, the ML bot had a tendency to produce sentences that were grammatically correct but nonsensical, sensible but grammatically incorrect, or just complete gibberish. We were able to correct such issues via RL. The first three examples of Table 3 present such cases. Occasionally the opposite happened. The last example of Table 3 is one such instance.",
      "exclude": false
    }
  ]
}