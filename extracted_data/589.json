{
  "id": "589",
  "title": "Structured Sequence Modeling with Graph Convolutional Recurrent Networks",
  "abstract": "This paper introduces Graph Convolutional Recurrent Network (GCRN), a deep learning model able to predict structured sequences of data. Precisely, GCRN is a generalization of classical recurrent neural networks (RNN) to data structured by any arbitrary graph. Such structured sequences can be series of frames in videos, spatio-temporal measurements on a network of sensors, or random walks on a vocabulary graph for natural language modeling.The proposed model combines convolutional neural networks (CNN) on graphs to identify spatial structures and RNN to find dynamic patterns. We study two possible architectures of GCRN, and apply the models to two practical problems: predicting moving MNIST data, and modeling natural language with the Penn Treebank dataset. Experiments show that exploiting simultaneously graph spatial and dynamic information about data can improve both precision and learning speed.",
  "accepted": false,
  "zeroShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": true,
        "confidence": 0.72,
        "primary_reason": "Limited experimental validation and inconsistent results. Penn Treebank experiments show the method underperforms baseline LSTM without dropout and requires dropout to marginally improve performance, suggesting the graph structure may not be genuinely beneficial. Moving MNIST is a synthetic toy problem. Missing comparisons with other structured sequence models. The contribution, while conceptually sound, lacks convincing empirical evidence of practical utility."
      },
      "token": {
        "prompt_tokens": 5015,
        "completion_tokens": 109,
        "total_tokens": 5124
      },
      "time": "2026-02-05T23:02:12.007549+00:00"
    }
  ],
  "article": [
    {
      "heading": "1 INTRODUCTION",
      "text": "Many real-world data can be cast as structured sequences, with spatio-temporal sequences being a special case. A well-studied example of spatio-temporal data are videos, where succeeding frames share temporal and spatial structures. Many works, such as Donahue et al. (2015); Karpathy & FeiFei (2015); Vinyals et al. (2015), leveraged a combination of CNN and RNN to exploit such spatial and temporal regularities. Their models are able to process possibly time-varying visual inputs for variable-length prediction. These neural network architectures consist of combining a CNN for visual feature extraction followed by a RNN for sequence learning. Such architectures have been successfully used for video activity recognition, image captioning and video description. More recently, interest has grown in properly fusing the CNN and RNN models for spatio-temporal sequence modeling. Inspired by language modeling, Ranzato et al. (2014) proposed a model to represent complex deformations and motion patterns by discovering both spatial and temporal correlations. They showed that prediction of the next video frame and interpolation of intermediate frames can be achieved by building a RNN-based language model on the visual words obtained by quantizing the image patches. Their highest-performing model, recursive CNN (rCNN), uses convolutions for both inputs and states. Shi et al. (2015) then proposed the convolutional LSTM network (convLSTM), a recurrent model for spatio-temporal sequence modeling which uses 2D-grid convolution to leverage the spatial correlations in input data. They successfully applied their model to the prediction of the evolution of radar echo maps for precipitation nowcasting. The spatial structure of many important problems may however not be as simple as regular grids. For instance, the data measured from meteorological stations lie on a irregular grid, i.e. a network of heterogeneous spatial distribution of stations. More challenging, the spatial structure of data may not even be spatial, as it is the case for social or biological networks. Eventually, the interpretation that sentences can be regarded as random walks on vocabulary graphs, a view popularized by Mikolov et al. (2013), allows us to cast language analysis problems as graph-structured sequence models. This work leverages on the recent models of Defferrard et al. (2016); Ranzato et al. (2014); Shi et al. (2015) to design the GCRN model for modeling and predicting time-varying graph-based data. The core idea is to merge CNN for graph-structured data and RNN to identify simultaneously meaningful spatial structures and dynamic patterns. A generic illustration of the proposed GCRN architecture is given by Figure 1.",
      "exclude": true
    },
    {
      "heading": "2 PRELIMINARIES",
      "text": "",
      "exclude": false
    },
    {
      "heading": "2.1 STRUCTURED SEQUENCE MODELING",
      "text": "Sequence modeling is the problem of predicting the most likely future length-K sequence given the previous J observations: xt+1, . . . , xt+K = arg max xt+1,...,xt+K P (xt+1, . . . , xt+K |xtJ+1, . . . , xt), (1) where xt D is an observation at time t and D denotes the domain of the observed features. The archetypal application being the n-gram language model (with n = J + 1), where P (xt+1|xtJ+1, . . . , xt) models the probability of word xt+1 to appear conditioned on the past J words in the sentence (Graves, 2013). In this paper, we are interested in special structured sequences, i.e. sequences where features of the observations xt are not independent but linked by pairwise relationships. Such relationships are universally modeled by weighted graphs. Data xt can be viewed as a graph signal, i.e. a signal defined on an undirected and weighted graph G = (V, E , A), where V is a finite set of |V| = n vertices, E is a set of edges and A Rnn is a weighted adjacency matrix encoding the connection weight between two vertices. A signal xt : V Rdx defined on the nodes of the graph may be regarded as a matrix xt Rndx whose column i is the dx-dimensional value of xt at the ith node. While the number of free variables in a structured sequence of length K is in principle O(nKdxK), we seek to exploit the structure of the space of possible predictions to reduce the dimensionality and hence make those problems more tractable.",
      "exclude": false
    },
    {
      "heading": "2.2 LONG SHORT-TERM MEMORY",
      "text": "A special class of recurrent neural networks (RNN) that prevents the gradient from vanishing too quickly is the popular long short-term memory (LSTM) introduced by Hochreiter & Schmidhuber (1997). This architecture has proven stable and powerful for modeling long-range dependencies in various general-purpose sequence modeling tasks (Graves, 2013; Srivastava et al., 2015; Sutskever et al., 2014). A fully-connected LSTM (FC-LSTM) may be seen as a multivariate version of LSTM where the input xt Rdx , cell output ht [1, 1]dh and states ct Rdh are all vectors. In this paper, we follow the FC-LSTM formulation of Graves (2013), that is: i = (Wxixt +Whiht1 + wci ct1 + bi), f = (Wxfxt +Whfht1 + wcf ct1 + bf ), ct = ft ct1 + it tanh(Wxcxt +Whcht1 + bc), o = (Wxoxt +Whoht1 + wco ct + bo), ht = o tanh(ct), (2) where denotes the Hadamard product, () the sigmoid function (x) = 1/(1 + ex) and i, f, o [0, 1]dh are the input, forget and output gates. The weights Wx Rdhdx , Wh Rdhdh , wc Rdh and biases bi, bf , bc, bo Rdh are the model parameters.1 Such a model is called fullyconnected because the dense matricesWx andWh linearly combine all the components of x and h. The optional peephole connections wc ct, introduced by Gers & Schmidhuber (2000), have been found to improve performance on certain tasks.",
      "exclude": false
    },
    {
      "heading": "2.3 CONVOLUTIONAL NEURAL NETWORKS ON GRAPHS",
      "text": "Generalizing convolutional neural networks (CNNs) to arbitrary graphs is a recent area of interest. Two approaches have been explored in the literature: (i) a generalization of the spatial definition of a convolution (Masci et al., 2015; Niepert et al., 2016) and (ii), a multiplication in the graph Fourier domain by the way of the convolution theorem (Bruna et al., 2014; Defferrard et al., 2016). Masci et al. (2015) introduced a spatial generalization of CNNs to 3D meshes. The authors used geodesic polar coordinates to define convolution operations on mesh patches, and formulated a deep learning architecture which allows comparison across different meshes. Hence, this method is tailored to manifolds and is not directly generalizable to arbitrary graphs. Niepert et al. (2016) proposed a spatial approach which may be decomposed in three steps: (i) select a node, (ii) construct its neighborhood and (iii) normalize the selected sub-graph, i.e. order the neighboring nodes. The extracted patches are then fed into a conventional 1D Euclidean CNN. As graphs generally do not possess a natural ordering (temporal, spatial or otherwise), a labeling procedure should be used to impose it. Bruna et al. (2014) were the first to introduce the spectral framework described below in the context of graph CNNs. The major drawback of this method is itsO(n2) complexity, which was overcome with the technique of Defferrard et al. (2016), which offers a linear complexity O(|E|) and provides strictly localized filters. Kipf & Welling (2016) took a first-order approximation of the spectral filters proposed by Defferrard et al. (2016) and successfully used it for semi-supervised classification of nodes. While we focus on the framework introduced by Defferrard et al. (2016), the proposed model is agnostic to the choice of the graph convolution operator G . As it is difficult to express a meaningful translation operator in the vertex domain (Bruna et al., 2014; Niepert et al., 2016), Defferrard et al. (2016) chose a spectral formulation for the convolution operator on graph G . By this definition, a graph signal x Rndx is filtered by a non-parametric kernel g() = diag(), where Rn is a vector of Fourier coefficients, as y = g G x = g(L)x = g(UUT )x = Ug()UTx Rndx , (3) where U Rnn is the matrix of eigenvectors and Rnn the diagonal matrix of eigenvalues of the normalized graph Laplacian L = In D1/2AD1/2 = UUT Rnn, where In is the identity matrix and D Rnn is the diagonal degree matrix with Dii = j Aij (Chung, 1997). Note that the signal x is filtered by g with an element-wise multiplication of its graph Fourier transform UTx with g (Shuman et al., 2013). Evaluating (3) is however expensive, as the multiplication with U is O(n2). Furthermore, computing the eigendecomposition of L might 1A practical trick is to initialize the biases bi, bf and bo to one such that the gates are initially open. be prohibitively expensive for large graphs. To circumvent this problem, Defferrard et al. (2016) parametrizes g as a truncated expansion, up to order K 1, of Chebyshev polynomials Tk such that g() = K1 k=0 kTk(), (4) where the parameter RK is a vector of Chebyshev coefficients and Tk() Rnn is the Chebyshev polynomial of order k evaluated at = 2/max In. The graph filtering operation can then be written as y = g G x = g(L)x = K1 k=0 kTk(L)x, (5) where Tk(L) Rnn is the Chebyshev polynomial of order k evaluated at the scaled Laplacian L = 2L/max In. Using the stable recurrence relation Tk(x) = 2xTk1(x) Tk2(x) with T0 = 1 and T1 = x, one can evaluate (5) in O(K|E|) operations, i.e. linearly with the number of edges. Note that as the filtering operation (5) is an order K polynomial of the Laplacian, it is K-localized and depends only on nodes that are at maximum K hops away from the central node, the K-neighborhood. The reader is referred to Defferrard et al. (2016) for details and an in-depth discussion.",
      "exclude": false
    },
    {
      "heading": "3 RELATED WORKS",
      "text": "Shi et al. (2015) introduced a model for regular grid-structured sequences, which can be seen as a special case of the proposed model where the graph is an image grid where the nodes are well ordered. Their model is essentially the classical FC-LSTM (2) where the multiplications by dense matrices W have been replaced by convolutions with kernels W : i = (Wxi xt +Whi ht1 + wci ct1 + bi), f = (Wxf xt +Whf ht1 + wcf ct1 + bf ), ct = ft ct1 + it tanh(Wxc xt +Whc ht1 + bc), o = (Wxo xt +Who ht1 + wco ct + bo), ht = o tanh(ct), (6) where denotes the 2D convolution by a set of kernels. In their setting, the input tensor xt Rnrncdx is the observation of dx measurements at time t of a dynamical system over a spatial region represented by a grid of nr rows and nc columns. The model holds spatially distributed hidden and cell states of size dh given by the tensors ct, ht Rnrncdh . The size m of the convolutional kernels Wh Rmmdhdh and Wx Rmmdhdx determines the number of parameters, which is independent of the grid size nr nc. Earlier, Ranzato et al. (2014) proposed a similar RNN variation which uses convolutional layers instead of fully connected layers. The hidden state at time t is given by ht = tanh((Wx2 (Wx1 xt)) + (Wh ht1)), (7) where the convolutional kernels Wh Rdhdh are restricted to filters of size 1x1 (effectively a fully connected layer shared across all spatial locations). Observing that natural language exhibits syntactic properties that naturally combine words into phrases, Tai et al. (2015) proposed a model for tree-structured topologies, where each LSTM has access to the states of its children. They obtained state-of-the-art results on semantic relatedness and sentiment classification. Liang et al. (2016) followed up and proposed a variant on graphs. Their sophisticated network architecture obtained state-of-the-art results for semantic object parsing on four datasets. In those models, the states are gathered from the neighborhood by way of a weighted sum with trainable weight matrices. Those weights are however not shared across the graph, which would otherwise have required some ordering of the nodes, alike any other spatial definition of graph convolution. Moreover, their formulations are limited to the one-neighborhood of the current node, with equal weight given to each neighbor. Motivated by spatio-temporal problems like modeling human motion and object interactions, Jain et al. (2016) developed a method to cast a spatio-temporal graph as a rich RNN mixture which essentially associates a RNN to each node and edge. Again, the communication is limited to directly connected nodes and edges. The closest model to our work is probably the one proposed by Li et al. (2015), which showed stat-of-the-art performance on a problem from program verification. Whereas they use the iterative procedure of the Graph Neural Networks (GNNs) model introduced by Scarselli et al. (2009) to propagate node representations until convergence, we instead use the graph CNN introduced by Defferrard et al. (2016) to diffuse information across the nodes. While their motivations are quite different, those models are related by the fact that a spectral filter defined as a polynomial of order K can be implemented as a K-layer GNN.2",
      "exclude": true
    },
    {
      "heading": "4 PROPOSED GCRN MODELS",
      "text": "We propose two GCRN architectures that are quite natural, and investigate their performances in real-world applications in Section 5. Model 1. The most straightforward definition is to stack a graph CNN, defined as (5), for feature extraction and an LSTM, defined as (2), for sequence learning: xCNNt = CNNG(xt) i = (Wxix CNN t +Whiht1 + wci ct1 + bi), f = (Wxfx CNN t +Whfht1 + wcf ct1 + bf ), ct = ft ct1 + it tanh(WxcxCNNt +Whcht1 + bc), o = (Wxox CNN t +Whoht1 + wco ct + bo), ht = o tanh(ct). (8) In that setting, the input matrix xt Rndx may represent the observation of dx measurements at time t of a dynamical system over a network whose organization is given by a graph G. xCNNt is the output of the graph CNN gate. For a proof of concept, we simply choose here xCNNt = W CNN G xt, where WCNN RKdxdx are the Chebyshev coefficients for the graph convolutional kernels of support K. The model also holds spatially distributed hidden and cell states of size dh given by the matrices ct, ht Rndh . Peepholes are controlled by wc Rndh . The weights Wh Rdhdh and Wx Rdhdx are the parameters of the fully connected layers. An architecture such as (8) may be enough to capture the data distribution by exploiting local stationarity and compositionality properties as well as the dynamic properties. Model 2. To generalize the convLSTM model (6) to graphs we replace the Euclidean 2D convolution by the graph convolution G : i = (Wxi G xt +Whi G ht1 + wci ct1 + bi), f = (Wxf G xt +Whf G ht1 + wcf ct1 + bf ), ct = ft ct1 + it tanh(Wxc G xt +Whc G ht1 + bc), o = (Wxo G xt +Who G ht1 + wco ct + bo), ht = o tanh(ct). (9) In that setting, the support K of the graph convolutional kernels defined by the Chebyshev coefficients Wh RKdhdh and Wx RKdhdx determines the number of parameters, which is independent of the number of nodes n. To keep the notation simple, we write Wxi G xt to mean a graph convolution of xt with dhdx filters which are functions of the graph Laplacian L parametrized by K Chebyshev coefficients, as noted in (4) and (5). In a distributed computing setting, K controls the communication overhead, i.e. the number of nodes any given node i should exchange with in order to compute its local states. The proposed blend of RNNs and graph CNNs is not limited to LSTMs and is straightforward to apply to any kind of recursive networks. For example, a vanilla RNN ht = tanh(Wxxt +Whht1) 2The basic idea is to set the transition function as a diffusion and the output function such as to realize the polynomial recurrence, then stack K of those. See Defferrard et al. (2016) for details. would be modified as ht = tanh(Wx G xt +Wh G ht1), (10) and a Gated Recurrent Unit (GRU) (Cho et al., 2014) as z = (Wxz G xt +Whz G ht1), r = (Wxr G xt +Whr G ht1), h = tanh(Wxh G xt +Whh G (r ht1)), ht = z ht1 + (1 z) h. (11) As demonstrated by Shi et al. (2015), structure-aware LSTM cells can be stacked and used as sequence-to-sequence models using an architecture composed of an encoder, which processes the input sequence, and a decoder, which generates an output sequence. A standard practice for machine translation using RNNs (Cho et al., 2014; Sutskever et al., 2014).",
      "exclude": false
    },
    {
      "heading": "5 EXPERIMENTS",
      "text": "",
      "exclude": false
    },
    {
      "heading": "5.1 SPATIO-TEMPORAL SEQUENCE MODELING ON MOVING-MNIST",
      "text": "For this synthetic experiment, we use the moving-MNIST dataset generated by Shi et al. (2015). All sequences are 20 frames long (10 frames as input and 10 frames for prediction) and contain two handwritten digits bouncing inside a 64 64 patch. Following their experimental setup, all models are trained by minimizing the binary cross-entropy loss using back-propagation through time (BPTT) and RMSProp with a learning rate of 103 and a decay rate of 0.9. We choose the best model with early-stopping on validation set. All implementations are based on their Theano code and dataset.3 The adjacency matrix A is constructed as a k-nearest-neighbor (knn) graph with Euclidean distance and Gaussian kernel between pixel locations. For a fair comparison with Shi et al. (2015) defined in (6), all GCRN experiments are conducted with Model 2 defined in (9), which is the same architecture with the 2D convolution replaced by a graph convolution G . To further explore the impact of the isotropic property of our filters, we generated a variant of the moving MNIST dataset where digits are also rotating (see Figure 4). Table 1 shows the performance of various models: (i) the baseline FC-LSTM from Shi et al. (2015), (ii) the 1-layer LSTM+CNN from Shi et al. (2015) with different filter sizes, and (iii) the proposed LSTM+graph CNN(GCNN) defined in (9) with different supports K. These results show the ability of the proposed method to capture spatio-temporal structures. Perhaps surprisingly, GCNNs can offer better performance than regular CNNs, even when the domain is a 2D grid and the data is images, the problem CNNs were initially developed for. The explanation is to be found in the differences between 2D filters and spectral graph filters. While a spectral filter of support K = 3 corresponds to the reach of a patch of size 55 (see Figure 2), the difference resides in the isotropic nature of the former and the number of parameters: K = 3 for the former and 52 = 25 for the later. 3http://www.wanghao.in/code/SPARNN-release.zip Table 1 indeed shows that LSTM+CNN(5 5) rivals LSTM+GCNN with K = 3. However, when increasing the filter size to 9 9 or K = 5, the GCNN variant clearly outperforms the CNN variant. This experiment demonstrates that graph spectral filters can obtain superior performance on regular domains with much less parameters thanks to their isotropic nature, a controversial property. Indeed, as the nodes are not ordered, there is no notion of an edge going up, down, on the right or on the left. All edges are treated equally, inducing some sort of rotation invariance. Additionally, Table 1 shows that the computational complexity of each model is linear with the filter size, and Figure 3 shows the learning dynamic of some of the models.",
      "exclude": false
    },
    {
      "heading": "5.2 NATURAL LANGUAGE MODELING ON PENN TREEBANK",
      "text": "The Penn Treebank dataset has 1,036,580 words. It was pre-processed in Zaremba et al. (2014) and split4 into a training set of 929k words, a validation set of 73k words, and a test set of 82k words. The size of the vocabulary of this corpus is 10,000. We use the gensim library5 to compute a word2vec model (Mikolov et al., 2013) for embedding the words of the dictionary in a 200-dimensional space. Then we build the adjacency matrix of the word embedding using a 4-nearest neighbor graph with cosine distance. Figure 6 presents the computed adjacency matrix, and its 3D visualization. We used the hyperparameters of the small configuration given by the code6 based on Zaremba et al. (2014): the size of the data mini-batch is 20, the number of temporal steps to unroll is 20, the dimension of the hidden state is 200. The global learning rate is 1.0 and the norm of the gradient is bounded by 5. The learning decay function is selected to be 0.5max(0,#epoch4). All experiments have 13 epochs, and dropout value is 0.75. For Zaremba et al. (2014), the input representation xt can be either the 200-dim embedding vector of the word, or the 10,000-dim one-hot representation of the word. For 4https://github.com/wojzaremba/lstm 5https://radimrehurek.com/gensim/models/word2vec.html our models, the input representation is a one-hot representation of the word. This choice allows us to use the graph structure of the words. Table 2 reports the final train and test perplexity values for each investigated model and Figure 5 plots the perplexity value vs. the number of epochs for the train and test sets with and without dropout regularization. Numerical experiments show: 1. Given the same experimental conditions in terms of architecture and no dropout regularization, the standalone model of LSTM is more accurate than LSTM using the spatial graph information (120.16 vs. 177.14), extracted by graph CNN with the GCRN architecture of Model 1, Eq. (8). 2. However, using dropout regularization, the graph LSTM model overcomes the standalone LSTM with perplexity values 98.67 vs. 112.98. 3. The use of spatial graph information found by graph CNN speeds up the learning process, and overfits the training dataset in the absence of dropout regularization. The graph structure likely acts a constraint on the learning system that is forced to move in the space of language topics. 4. We performed the same experiments with LSTM and Model 2 defined in (9). Model 1 significantly outperformed Model 2, and Model 2 did worse than standalone LSTM. This bad performance may be the result of the large increase of dimensionality in Model 2, as the dimension of the hidden and cell states changes from 200 to 10,000, the size of the vocabulary. A solution would be to downsize the data dimensionality, as done in Shi et al. (2015) in the case of image data. 6https://github.com/tensorflow/tensorflow/blob/master/tensorflow/ models/rnn/ptb/ptb_word_lm.py",
      "exclude": false
    },
    {
      "heading": "6 CONCLUSION AND FUTURE WORK",
      "text": "This work aims at learning spatio-temporal structures from graph-structured and time-varying data. In this context, the main challenge is to identify the best possible architecture that combines simultaneously recurrent neural networks like vanilla RNN, LSTM or GRU with convolutional neural networks for graph-structured data. We have investigated here two architectures, one using a stack of CNN and RNN (Model 1), and one using convLSTM that considers convolutions instead of fully connected operations in the RNN definition (Model 2). We have then considered two applications: video prediction and natural language modeling. Model 2 has shown good performances in the case of video prediction, by improving the results of Shi et al. (2015). Model 1 has also provided promising performances in the case of language modeling, particularly in terms of learning speed. It has been shown that (i) isotropic filters, maybe surprisingly, can outperform classical 2D filters on images while requiring much less parameters, and (ii) that graphs coupled with graph CNN and RNN are a versatile way of introducing and exploiting side-information, e.g. the semantic of words, by structuring a data matrix. Future work will investigate applications to data naturally structured as dynamic graph signals, for instance fMRI and sensor networks. The graph CNN model we have used is rotationally-invariant and such spatial property seems quite attractive in real situations where motion is beyond translation. We will also investigate how to benefit of the fast learning property of our system to speed up language modeling models. Eventually, it will be interesting to analyze the underlying dynamical property of generic RNN architectures in the case of graphs. Graph structures may introduce stability to RNN systems, and prevent them to express unstable dynamic behaviors.",
      "exclude": true
    },
    {
      "heading": "ACKNOWLEDGMENT",
      "text": "This research was supported in part by the European Unions H2020 Framework Programme (H2020-MSCA-ITN-2014) under grant No. 642685 MacSeNet, and Nvidia equipment grant.",
      "exclude": true
    }
  ]
}