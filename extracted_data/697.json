{
  "id": "697",
  "title": "Riemannian Optimization for Skip-Gram Negative Sampling",
  "abstract": "Skip-Gram Negative Sampling (SGNS) word embedding model, well known by its implementation in \"word2vec\" software, is usually optimized by stochastic gradient descent. It can be shown that optimizing for SGNS objective can be viewed as an optimization problem of searching for a good matrix with the low-rank constraint. The most standard way to solve this type of problems is to apply Riemannian optimization framework to optimize the SGNS objective over the manifold of required low-rank matrices. In this paper, we propose an algorithm that optimizes SGNS objective using Riemannian optimization and demonstrates its superiority over popular competitors, such as the original method to train SGNS and SVD over SPPMI matrix.",
  "accepted": false,
  "zeroShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": true,
        "confidence": 0.75,
        "primary_reason": "Limited novelty and weak empirical validation. The paper applies existing Riemannian optimization techniques to SGNS without significant methodological innovation. Experimental evaluation is narrow (single corpus, limited baselines, mixed results on linguistic tasks) and lacks statistical significance testing. The practical improvements over baselines are marginal and inconsistent across datasets."
      },
      "token": {
        "prompt_tokens": 5442,
        "completion_tokens": 98,
        "total_tokens": 5540
      },
      "time": "2026-02-05T23:12:08.720769+00:00"
    },
    {
      "model": "gpt-5.2",
      "decision": {
        "rejection": true,
        "confidence": 0.78,
        "primary_reason": "Incremental/insufficiently validated contribution: reformulating SGNS as low-rank matrix optimization is known, the proposed Riemannian method is not rigorously developed (unclear correctness/convergence, questionable complexity claims), and experiments are limited (single corpus, narrow evaluation, no strong modern baselines or ablations)."
      },
      "token": {
        "prompt_tokens": 4791,
        "completion_tokens": 84,
        "total_tokens": 4875
      },
      "time": "2026-02-09T21:41:21.041092+00:00"
    }
  ],
  "article": [
    {
      "heading": "1 INTRODUCTION",
      "text": "In this paper, we consider the problem of embedding words into a low-dimensional space in order to measure the semantic similarity between them. As an example, how to find whether the word table is semantically more similar to the word stool than to the word sky? That is achieved by constructing a low-dimensional vector representation for each word and measuring similarity between the words as the similarity between the corresponding vectors. One of the most popular word embedding models by Mikolov et al. (2013) is a discriminative neural network that optimizes Skip-Gram Negative Sampling (SGNS) objective (see Equation 3). It aims at predicting whether two words can be found close to each other within a text. As shown in Section 2, the process of word embeddings training using SGNS can be divided into two general steps with clear objectives: Step 1. Search for a low-rank matrix X that provides a good SGNS objective value; Step 2. Search for a good low-rank representation X = WC in terms of linguistic metrics, where W is a matrix of word embeddings and C is a matrix of so-called context embeddings. Unfortunately, most previous approaches mixed these two steps into a single one, what entails a not completely correct formulation of the optimization problem. For example, popular approaches to train embeddings (including the original word2vec implementation) do not take into account that the objective from Step 1 depends only on the product X = WC: instead of straightforward computing of the derivative w.r.t. X , these methods are explicitly based on the derivatives w.r.t. W and C, what complicates the optimization procedure. Moreover, such approaches do not take into account that parametrization WC of matrix X is non-unique and Step 2 is required. Indeed, for any invertible matrix S, we have X = W1C1 = W1SS 1C1 = W2C 2 , therefore, solutions W1C1 and W2C2 are equally good in terms of the SGNS objective but entail different cosine similarities between embeddings and, as a result, different performance in terms of linguistic metrics (see Section 4.2 for details). A successful attempt to follow the above described steps, which outperforms the original SGNS optimization approach in terms of various linguistic tasks, was proposed by Levy & Goldberg (2014). In order to obtain a low-rank matrix X on Step 1, the method reduces the dimensionality of Shifted Positive Pointwise Mutual Information (SPPMI) matrix via Singular Value Decomposition (SVD). On Step 2, it computes embeddings W and C via a simple formula that depends on the factors obtained by SVD. However, this method has one important limitation: SVD provides a solution to a surrogate optimization problem, which has no direct relation to the SGNS objective. In fact, SVD minimizes the Mean Squared Error (MSE) between X and SPPMI matrix, what does not lead to minimization of SGNS objective in general (see Section 6.1 and Section 4.2 in Levy & Goldberg (2014) for details). These issues bring us to the main idea of our paper: while keeping the low-rank matrix search setup on Step 1, optimize the original SGNS objective directly. This leads to an optimization problem over matrixX with the low-rank constraint, which is often (Mishra et al. (2014)) solved by applying Riemannian optimization framework (Udriste (1994)). In our paper, we use the projector-splitting algorithm (Lubich & Oseledets (2014)), which is easy to implement and has low computational complexity. Of course, Step 2 may be improved as well, but we regard this as a direction of future work. As a result, our approach achieves the significant improvement in terms of SGNS optimization on Step 1 and, moreover, the improvement on Step 1 entails the improvement on Step 2 in terms of linguistic metrics. That is why, the proposed two-step decomposition of the problem makes sense, what, most importantly, opens the way to applying even more advanced approaches based on it (e.g., more advanced Riemannian optimization techniques for Step 1 or a more sophisticated treatment of Step 2). To summarize, the main contributions of our paper are: We reformulated the problem of SGNS word embedding learning as a two-step procedure with clear objectives; For Step 1, we developed an algorithm based on Riemannian optimization framework that optimizes SGNS objective over low-rank matrix X directly; Our algorithm outperforms state-of-the-art competitors in terms of SGNS objective and the semantic similarity linguistic metric (Levy & Goldberg (2014); Mikolov et al. (2013); Schnabel et al. (2015)).",
      "exclude": true
    },
    {
      "heading": "2 PROBLEM SETTING",
      "text": "",
      "exclude": false
    },
    {
      "heading": "2.1 SKIP-GRAM NEGATIVE SAMPLING",
      "text": "In this paper, we consider the Skip-Gram Negative Sampling (SGNS) word embedding model (Mikolov et al. (2013)), which is a probabilistic discriminative model. Assume we have a text corpus given as a sequence of words w1, . . . , wn, where n may be larger than 1012 and wi VW belongs to a vocabulary of words VW . A context c VC of the word wi is a word from set wiL, ..., wi1, wi+1, ..., wi+L for some fixed window size L. Letw, c Rd be the word embeddings of word w and context c, respectively. Assume they are specified by the following mappings: W : VW Rd, C : VC Rd. The ultimate goal of SGNS word embedding training is to fit good mappingsW and C. In the SGNS model, the probability that pair (w, c) is observed in the corpus is modeled as a following function: P ((w, c) D|w, c) = (w, c) = 1 1 + exp(w, c) , (1) where D is the multiset of all word-context pairs (w, c) observed in the corpus and x,y is the scalar product of vectors x and y. Number d is a hyperparameter that adjusts the flexibility of the model. It usually takes values from tens to hundreds. In order to collect a training set, we take all pairs (w, c) fromD as positive examples and k randomly generated pairs (w, c) as negative ones. Let #(w, c) be the number of times the pair (w, c) appears in D. Thereby the number of times the word w and the context c appear in D can be computed as #(w) = cVc #(w, c) and #(c) = wVw #(w, c) accordingly. Then negative examples are generated from the distribution defined by #(c) counters: PD(c) = #(c) |D| . In this way, we have a model maximizing the following logarithmic likelihood objective for each word pair (w, c): #(w, c)(log (w, c) + k EcPD log (w, c)). (2) In order to maximize the objective over all observations for each pair (w, c), we arrive at the following SGNS optimization problem over all possible mappingsW and C: l = wVW cVC #(w, c)(log (w, c) + k EcPD log (w, c)) maxW, . (3) Usually, this optimization is done via the stochastic gradient descent procedure that is performed during passing through the corpus (Mikolov et al. (2013); Rong (2014)).",
      "exclude": false
    },
    {
      "heading": "2.2 OPTIMIZATION OVER LOW-RANK MATRICES",
      "text": "Relying on the prospect proposed by Levy & Goldberg (2014), let us show that the optimization problem given by (3) can be considered as a problem of searching for a matrix that maximizes a certain objective function and has the rank-d constraint (Step 1 in the scheme described in Section 1).",
      "exclude": false
    },
    {
      "heading": "2.2.1 SGNS LOSS FUNCTION",
      "text": "As shown by Levy & Goldberg (2014), the logarithmic likelihood (3) can be represented as the sum of lw,c(w, c) over all pairs (w, c), where lw,c(w, c) has the following form: lw,c(w, c) =#(w, c) log (w, c) + k #(w)#(c) |D| log (w, c). (4) A crucial observation is that this loss function depends only on the scalar product w, c but not on embeddings w and c separately: lw,c(w, c) = fw,c(xw,c), fw,c(xw,c) = aw,c log (xw,c) + bw,c log (xw,c), where xw,c is the scalar product w, c and aw,c = #(w, c), bw,c = k#(w)#(c)|D| are constants.",
      "exclude": false
    },
    {
      "heading": "2.2.2 MATRIX NOTATION",
      "text": "Denote |VW | as n and |VC | as m. Let W Rnd and C Rmd be matrices, where each row w Rd of matrix W is the word embedding of the corresponding word w and each row c Rd of matrix C is the context embedding of the corresponding context c. Then the elements of the product of these matrices X = WC are the scalar products xw,c of all pairs (w, c): X = (xw,c), w VW , c VC . Note that this matrix has rank d, becauseX equals to the product of two matrices with sizes (n d) and (dm). Now we can write SGNS objective given by (3) as a function of X: F (X) = wVW cVC fw,c(xw,c), F : Rnm R. (5) This arrives us at the following proposition: Proposition 1 SGNS optimization problem given by (3) can be rewritten in the following constrained form: maximize XRnm F (X), subject to X Md, (6) whereMd is the manifold (Udriste (1994)) of all matrices in Rnm with rank d: Md = X Rnm : rank(X) = d. The key idea of this paper is to solve the optimization problem given by (6) via the framework of Riemannian optimization, which we introduce in Section 3. Important to note that this prospect does not suppose the optimization over parameters W and C directly. This entails the optimization in the space with ((n + m d) d) degrees of freedom (Mukherjee et al. (2015)) instead of ((n + m) d), what simplifies the optimization process (see Section 5 for the experimental results).",
      "exclude": false
    },
    {
      "heading": "2.3 COMPUTING EMBEDDINGS FROM A LOW-RANK SOLUTION",
      "text": "OnceX is found, we need to recoverW andC such thatX = WC (Step 2 in the scheme described in Section 1). This problem does not have a unique solution, since if (W,C) satisfy this equation, thenWS1 and CS satisfy it as well for any non-singular matrix S. Moreover, different solutions may achieve different values of the linguistic metrics (see Section 4.2 for details). While our paper focuses on Step 1, we use, for Step 2, a heuristic approach that was proposed by Levy et al. (2015) and it shows good results in practice. We compute SVD of X in the form X = UV , where U and V have orthonormal columns, and is the diagonal matrix, and use W = U , C = V as matrices of embeddings. A simple justification of this solution is the following: we need to map words into vectors in a way that similar words would have similar embeddings in terms of cosine similarities: cos(w1,w2) = w1,w2 w1 w2 . It is reasonable to assume that two words are similar, if they share contexts. Therefore, we can estimate the similarity of two words w1, w2 as s(w1, w2) = cVC xw1,c xw2,c, what is the element of the matrix XX with indices (w1, w2). Note that XX = UV V U = U2U. If we choose W = U, we exactly obtain w1,w2 = s(w1, w2), since WW = XX in this case. That is, the cosine similarity of the embeddingsw1,w2 coincides with the intuitive similarity s(w1, w2). However, scaling by instead of was shown by Levy et al. (2015) to be a better solution in experiments.",
      "exclude": false
    },
    {
      "heading": "3 PROPOSED METHOD",
      "text": "",
      "exclude": false
    },
    {
      "heading": "3.1 RIEMANNIAN OPTIMIZATION",
      "text": "",
      "exclude": false
    },
    {
      "heading": "3.1.1 GENERAL SCHEME",
      "text": "The main idea of Riemannian optimization (Udriste (1994)) is to consider (6) as a constrained optimization problem. Assume we have an approximated solution Xi on a current step of the optimization process, where i is the step number. In order to improve Xi, the next step of the standard gradient ascent outputs Xi + F (Xi), where F (Xi) is the gradient of objective F at the point Xi. Note that the gradient F (Xi) can be naturally considered as a matrix in Rnm. Point Xi + F (Xi) leaves the manifold Md, because its rank is generally greater than d. That is why Riemannian optimization methods map point Xi + F (Xi) back to manifold Md. The standard Riemannian gradient method first projects the gradient step onto the tangent space at the current point Xi and then retracts it back to the manifold: Xi+1 = R (PTM (Xi +F (Xi))), where R is the retraction operator, and PTM is the projection onto the tangent space.",
      "exclude": false
    },
    {
      "heading": "3.1.2 PROJECTOR-SPLITTING ALGORITHM",
      "text": "In our paper, we use a much simpler version of such approach that retracts point Xi + F (Xi) directly to the manifold, as illustrated on Figure 1: Xi+1 = R(Xi +F (Xi)). Under review as a conference paper at ICLR 2017 Fine-tuning word embeddings xxxxx xxxxx xxxxx xxxx xxxx xxxx xxx xxxxx xxxx xxxxx ABSTRACT Blah-blah Keywords word embeddings, SGNS, word2vec, GLOVE 1. INTRODUCTION sdfdsf 2. CONCLUSIONS 3. RELATED WORK Mikolov main [?] Levi main [?] rFi Xi = UiSiV T i Xi+1 = Ui+1Si+1V T i+1 retraction 4. CONCLUSIONS Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. WOODSTOCK 97 El Paso, Texas USA Copyright 20XX ACM X-XXXXX-XX-X/XX/XX ... 15.00. Fine-tuning word embeddings xxxxx xxxxx xxxxx xxxx xxxx xxxx xxx xxxxx xxxx xxxxx ABSTRACT Blah-blah Keywords word embeddings, SGNS, word2vec, GLOVE 1. INTRODUCTION sdfdsf 2. CONCLUSIONS 3. RELATED WORK Mikolov main [?] Levi main [?] rF (Xi) Xi +rF (Xi) Xi = UiSiV T i Xi Xi+1 Xi+1 = Ui+1Si+1V T i+1 retraction Md 4. CONCLUSIONS Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. WOODSTOCK 97 El Paso, Texas USA Copyright 20XX ACM X-XXXXX-XX-X/XX/XX ...$15.00. Fine-tuning word embeddings xxxxx xxxxx xxxxx xxx xxxx xxxx xxx xxxxx xxxx xxxxx ABSTRACT Blah-blah Keywords word embeddings, SGNS, word2vec, GLOVE",
      "exclude": false
    },
    {
      "heading": "1. INTRODUCTION",
      "text": "sdfdsf 2. CONCLUSIONS 3. RELATED WORK Mikolov main [?] Levi main [?] rF (Xi) Xi +rF (Xi) Xi = UiSiV T i Xi Xi+1 Xi+1 = Ui+1Si+1V T i+1 retraction Md 4. CONCLUSIONS Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. WOODSTOCK 97 El Paso, Texas USA Copyright 20XX ACM X-XXXXX-XX-X/XX/XX ... 15.00. Fine-tuning word embeddings xxxxx xx xxxxx xxxx xxxx xxxx xxx xxxxx xxxx xxxxx ABSTRACT Blah-blah Keywords word embeddings, SGNS, word2vec, GLOVE 1. INT ODUCTION sdfdsf 2. CONCLUSIONS 3. RELATED WORK Mikolov main [?] Levi main [?] rF (Xi) Xi +rF (Xi) Xi = UiSiV T i Xi Xi+1 Xi+1 = Ui+1Si+1V T i+1 retraction Md 4. CONCLUSIONS Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. WOODSTOCK 97 El Paso, Texas USA Copyright 20XX ACM X-XXXXX-XX-X/XX/XX ...$15.00. Figure 1: Geometric interpretation of one step of projector-splitting optimization procedure: the gradient step an the retraction of the high-rank atr x Xi + F (Xi) to the manifold of low-rank matrices Md. Intuitively, retractor R finds rank-d matrix on t e manifold Md tha is similar to high-rank matrixXi+F (Xi) in terms o Frobeniu orm. How can e do it? The most straightforward way to reduce the rank ofXi +F (Xi) is to perform the SVD, which keeps d largest singular values of it: 1: Ui+1, Si+1, V i+1 SVD(Xi +F (Xi)), 2: Xi+1 Ui+1Si+1V i+1. (7) However, it is computationally expensive. Instead of this approach, we use the projector-splitting method (Lubich & Oseledets (2014)), which is a second-order retraction onto the manifold (for details, see the review by Absil & Oseledets (2015)). Its practical implementation is also quite intuitive: instead of computing the full SVD of Xi +F (Xi) according to the gradient projection method, we use just one step of the block power numerical method (Bentbib & Kanber (2015)) which computes the SVD, what reduces the computational complexity. Let us keep the current point in the following factorized form: Xi = UiSiV i , (8) where matrices Ui Rnd and Vi Rmd have d orthonormal columns and Si Rdd. Then we need to perform two QR-decompositions to retract point Xi +F (Xi) back to the manifold: 1: Ui+1, Si+1 QR ((Xi +F (Xi))Vi) , 2: Vi+1, Si+1 QR ( (Xi +F (Xi))Ui+1 ) , 3: Xi+1 Ui+1Si+1V i+1. In this way, we always keep the solution Xi+1 = Ui+1Si+1V i+1 on the manifold Md and in the form (8). What is important, we only need to compute F (Xi), so the gradients with respect to U , S and V are never computed explicitly, thus avoiding the subtle case where S is close to singular (so-called singular (critical) point on the manifold). Indeed, the gradient with respect to U (while keeping the orthogonality constraints) can be written (Koch & Lubich (2007)) as: F U = F X V S1, which means that the gradient will be large if S is close to singular. The projector-splitting scheme is free from this problem.",
      "exclude": true
    },
    {
      "heading": "3.2 ALGORITHM",
      "text": "In case of SGNS objective given by (5), an element of gradient F has the form: (F (X))w,c = fw,c(xw,c) xw,c = #(w, c) (xw,c) k #(w)#(c) |D| (xw,c) . To make the method more flexible in terms of convergence properties, we additionally use R, which is a step size parameter. In this case, retractor R returns Xi + F (Xi) instead of Xi +F (Xi) onto the manifold. The whole optimization procedure is summarized in Algorithm 1. Algorithm 1 Riemannian Optimization for SGNS Require: Dimentionality d, initializationW0 and C0, step size , gradient functionF : Rnm Rnm, number of iterationsK Ensure: FactorW Rnd 1: X0 W0C0 # get an initial point at the manifold 2: U0, S0, V 0 SVD(X0) # compute the first point satisfying the low-rank constraint 3: i 0 4: while i < K do 5: Ui+1, Si+1 QR ((Xi + F (Xi))Vi) # perform one step of the block power method with two QR-decompositions 6: Vi+1, Si+1 QR ( (Xi + F (Xi))Ui+1 ) 7: Xi+1 Ui+1Si+1V i+1 # update the point at the manifold 8: i i+ 1 9: end while 10: U,, V SVD(XK) 11: W U # compute word embeddings 12: return W",
      "exclude": false
    },
    {
      "heading": "4 EXPERIMENTAL SETUP",
      "text": "",
      "exclude": false
    },
    {
      "heading": "4.1 TRAINING MODELS",
      "text": "We compare our method (RO-SGNS in the tables) performance to two baselines: SGNS embeddings optimized via Stochastic Gradient Descent, implemented in the original word2vec, (SGDSGNS in the tables) by Mikolov et al. (2013) and embeddings obtained by SVD over SPPMI matrix (SVD-SPPMI in the tables) by Levy & Goldberg (2014). We have also experimented with the blockwise alternating optimization over factors W and C, but the results are almost the same to SGD results, that is why we do not to include them into the paper. The source code of our experiments is available online1. The models were trained on English Wikipedia enwik9 corpus2, which was previously used in most papers on this topic. Like in previous studies, we counted only the words which occur more than 200 times in the training corpus (Levy & Goldberg (2014); Mikolov et al. (2013)). As a result, we obtained a vocabulary of 24292 unique tokens (set of words VW and set of contexts VC are equal). The size of the context window was set to 5 for all experiments, as it was done by Levy & Goldberg (2014); Mikolov et al. (2013). We conduct two series of experiments: for dimensionality d = 100 and d = 200. Optimization step size is chosen to be small enough to avoid huge gradient values. However, thorough choice of does not result in a significant difference in performance (this parameter was tuned on the training data only, the exact values used in experiments are reported below).",
      "exclude": false
    },
    {
      "heading": "4.2 EVALUATION",
      "text": "We evaluate word embeddings via the word similarity task. We use the following popular datasets for this purpose: wordsim-353 (Finkelstein et al. (2001); 3 datasets), simlex-999 (Hill et al. (2016)) and men (Bruni et al. (2014)). Original wordsim-353 dataset is a mixture of the word pairs for both word similarity and word relatedness tasks. This dataset was split (Agirre et al. (2009)) into two intersecting parts: wordsim-sim (ws-sim in the tables) and wordsim-rel (ws-rel in the tables) to separate the words from different tasks. In our experiments, we use both of them on a par with the full version of wordsim-353 (ws-full in the tables). Each dataset contains word pairs together with assessor-assigned similarity scores for each pair. As a quality measure, we use Spearmans correlation between these human ratings and cosine similarities for each pair. We call this quality metric linguistic in our paper. 1https://github.com/newozz/riemannian_sgns 2Enwik9 corpus can be found here: http://mattmahoney.net/dc/textdata",
      "exclude": false
    },
    {
      "heading": "5 RESULTS OF EXPERIMENTS",
      "text": "First of all, we compare the value of SGNS objective obtained by the methods. The comparison is demonstrated in Table 1. We see that SGD-SGNS and SVD-SPPMI methods provide quite similar results, however, the proposed method obtains significantly better SGNS values, what proves the feasibility of using Riemannian optimization framework in SGNS optimization problem. It is interesting to note that SVDSPPMI method, which does not optimize SGNS objective directly, obtains better results than SGDSGNS method, which aims at optimizing SGNS. This fact additionally confirms the idea described in Section 2.2.2 that the independent optimization over parameters W and C may decrease the performance. However, the target performance measure of embedding models is the correlation between semantic similarity and human assessment (Section 4.2). Table 2 presents the comparison of the methods in terms of it. We see that our method outperforms the competitors on all datasets except for men dataset where it obtains slightly worse results. Moreover, it is important that the higher dimension entails higher performance gain of our method in comparison to the competitors. In order to understand how exactly our model improves or degrades the performance in comparison to the baseline, we found several words, whose neighbors in terms of cosine distance change significantly. Table 3 demonstrates neighbors of words five, he and main in terms of our model and its nearest competitor according to the similarity task SVD-SPPMI. These words were chosen as representative examples whose neighborhoods in terms of SVD-SPPMI and RO-SGNS models are strikingly different. A neighbour of a source word is bold if we suppose that it has a similar semantic meaning to the source word. First of all, we notice that our model produces much better neighbors of the words describing digits or numbers (see word five as an example). The similar situation happens for many other words, e.g. in case of word main the nearest neighbors contain 4 similar words in case of our model instead of 2 in case of SVD-SPPMI. The neighbourhood of word he contains less semantically similar words in case of our model. However, it filters out completely irrelevant words, such as promptly and dumbledore. Talking about the optimal number K of iterations in the optimization procedure and step size , we found that they depend on the particular value of dimensionality d. For d = 100, we have K = 25, 5 105, and for d = 200, we have K = 13, = 104. Moreover, it is interesting that the best results were obtained when SVD-SPPMI embeddings were used as an initialization of Riemannian optimization process.",
      "exclude": false
    },
    {
      "heading": "6 RELATED WORK",
      "text": "",
      "exclude": true
    },
    {
      "heading": "6.1 WORD EMBEDDINGS",
      "text": "Skip-Gram Negative Sampling was introduced by Mikolov et al. (2013). The negative sampling approach was thoroughly described by Goldberg & Levy (2014), and the learning method is ex- plained by Rong (2014). There are several open-source implementations of SGNS neural network, which is widely known as word2vec 34. As shown in Section 2.2, Skip-Gram Negative Sampling optimization can be reformulated as a problem of searching for a low-rank matrix. In order to be able to use out-of-the-box SVD for this task, Levy & Goldberg (2014) used the surrogate version of SGNS as the objective function. There are two general assumptions made in their algorithm that distinguish it from the SGNS optimization: 1. SVD optimizes Mean Squared Error (MSE) objective instead of SGNS loss function. 2. In order to avoid infinite elements in SPMI matrix, it is transformed in ad-hoc manner (SPPMI matrix) before applying SVD. This makes the objective not interpretable in terms of the original task (3). As mentioned by Levy & Goldberg (2014), SGNS objective weighs different (w, c) pairs differently, unlike the SVD, which works with the same weight for all pairs, what may entail the performance fall. The comprehensive explanation of the relation between SGNS, SPPMI, SVD-over-SPPMI methods is provided by Keerthi et al. (2015). Lai et al. (2015); Levy et al. (2015) give a good overview of highly practical methods to improve these word embedding models.",
      "exclude": false
    },
    {
      "heading": "6.2 RIEMANNIAN OPTIMIZATION",
      "text": "An introduction to optimization over Riemannian manifolds can be found in the paper of Udriste (1994). The overview of retractions of high rank matrices to low-rank manifolds is provided by Absil & Oseledets (2015). The projector-splitting algorithm was introduced by Lubich & Oseledets (2014), and also was mentioned by Absil & Oseledets (2015) as Lie-Trotter retraction. Riemannian optimization is succesfully applied to various data science problems: for example, matrix completion (Vandereycken (2013)), large-scale recommender systems (Tan et al. (2014)), and tensor completion (Kressner et al. (2014)).",
      "exclude": false
    },
    {
      "heading": "7 CONCLUSIONS AND FUTURE WORK",
      "text": "In our paper, we proposed the general two-step scheme of training SGNS word embedding model and introduced the algorithm that performs the search of a solution in the low-rank form via Riemannian optimization framework. We also demonstrated the superiority of the proposed method, by providing the experimental comparison to the existing state-of-the-art approaches. It seems to be an interesting direction of future work to apply more advanced optimization techniques to Step 1 of the scheme proposed in Section 1 and to explore the Step 2 obtaining embeddings with a given low-rank matrix. 3Original Google word2vec: https://code.google.com/archive/p/word2vec/ 4Gensim word2vec: https://radimrehurek.com/gensim/models/word2vec.html",
      "exclude": true
    }
  ],
  "fewShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": true,
        "confidence": 0.75,
        "primary_reason": "Limited novelty in methodology (standard Riemannian optimization applied to known SGNS problem), narrow experimental scope (only word similarity tasks on single corpus), marginal improvements over baselines, and lack of broader impact demonstration."
      },
      "token": {
        "prompt_tokens": 5604,
        "completion_tokens": 83,
        "total_tokens": 5687
      },
      "time": "2026-02-08T22:43:05.395402+00:00"
    },
    {
      "model": "gpt-5.2",
      "decision": {
        "rejection": true,
        "confidence": 0.78,
        "primary_reason": "Incremental/underdeveloped contribution: reframes SGNS as low-rank matrix optimization and applies a known Riemannian retraction (projector-splitting) with limited novelty, unclear scalability to realistic vocab sizes (explicit X is nÃ—m), and evaluation is narrow (only word similarity on enwik9) with weak/dated baselines and insufficient analysis/ablations to justify superiority over strong SGNS/GloVe variants."
      },
      "token": {
        "prompt_tokens": 7425,
        "completion_tokens": 117,
        "total_tokens": 7542
      },
      "time": "2026-02-09T20:45:31.432161+00:00"
    }
  ],
  "test": true
}