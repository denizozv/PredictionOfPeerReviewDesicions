{
  "id": "515",
  "title": "Exponential Machines",
  "abstract": "Modeling interactions between features improves the performance of machine learning solutions in many domains (e.g. recommender systems or sentiment analysis). In this paper, we introduce Exponential Machines (ExM), a predictor that models all interactions of every order. The key idea is to represent an exponentially large tensor of parameters in a factorized format called Tensor Train (TT). The Tensor Train format regularizes the model and lets you control the number of underlying parameters. To train the model, we develop a stochastic Riemannian optimization procedure, which allows us to fit tensors with 2^160 entries. We show that the model achieves state-of-the-art performance on synthetic data with high-order interactions and that it works on par with high-order factorization machines on a recommender system dataset MovieLens 100K.",
  "accepted": false,
  "zeroShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": false,
        "confidence": 0.82,
        "primary_reason": "Novel approach to modeling high-order feature interactions using Tensor Train decomposition with Riemannian optimization. Strong theoretical contributions (Theorems 1-2) and solid experimental validation, though limited dataset scale and modest empirical improvements over baselines are minor concerns."
      },
      "token": {
        "prompt_tokens": 7373,
        "completion_tokens": 84,
        "total_tokens": 7457
      },
      "time": "2026-02-05T22:55:07.790403+00:00"
    }
  ],
  "article": [
    {
      "heading": "1 INTRODUCTION",
      "text": "Machine learning problems with categorical data require modeling interactions between the features to solve them. As an example, consider a sentiment analysis problem detecting whether a review is positive or negative and the following dataset: I liked it, I did not like it, Im not sure. Judging by the presence of the word like or the word not alone, it is hard to understand the tone of the review. But the presence of the pair of words not and like strongly indicates a negative opinion. If the dictionary has d words, modeling pairwise interactions requires O(d2) parameters and will probably overfit to the data. Taking into account all interactions (all pairs, triplets, etc. of words) requires impractical 2d parameters. In this paper, we show a scalable way to account for all interactions. Our contributions are: We propose a predictor that models all 2d interactions of d-dimensional data by representing the exponentially large tensor of parameters in a compact multilinear format Tensor Train (TT-format) (Sec. 3). Factorizing the parameters into the TT-format leads to a better generalization, a linear with respect to d number of underlying parameters and inference time (Sec. 5). The TT-format lets you control the number of underlying parameters through the TT-rank a generalization of the matrix rank to tensors. We develop a stochastic Riemannian optimization learning algorithm (Sec. 6.1). In our experiments, it outperformed the stochastic gradient descent baseline (Sec. 8.2) that is often used for models parametrized by a tensor decomposition (see related works, Sec. 9). We show that the linear model (e.g. logistic regression) is a special case of our model with the TT-rank equal 2 (Sec. 8.3). We extend the model to handle interactions between functions of the features, not just between the features themselves (Sec. 7).",
      "exclude": true
    },
    {
      "heading": "2 LINEAR MODEL",
      "text": "In this section, we describe a generalization of a class of machine learning algorithms the linear model. Let us fix a training dataset of pairs (x(f), y(f))Nf=1, where x(f) is a d-dimensional feature vector of f -th object, and y(f) is the corresponding target variable. Also fix a loss function `(y, y) : R2 R, which takes as input the predicted value y and the ground truth value y. We call a model linear, if the prediction of the model depends on the features x only via the dot product between the features x and the d-dimensional vector of parameters w: ylinear(x) = x,w+ b, (1) where b R is the bias parameter. One of the approaches to learn the parameters w and b of the model is to minimize the following loss N f=1 ` ( x(f),w+ b, y(f) ) + 2 w22 , (2) where is the regularization parameter. For the linear model we can choose any regularization term instead of L2, but later the choice of the regularization term will become important (see Sec. 6.1). Several machine learning algorithms can be viewed as a special case of the linear model with an appropriate choice of the loss function `(y, y): least squares regression (squared loss), Support Vector Machine (hinge loss), and logistic regression (logistic loss).",
      "exclude": false
    },
    {
      "heading": "3 OUR MODEL",
      "text": "Before introducing our model equation in the general case, consider a 3-dimensional example. The equation includes one term per each subset of features (each interaction) y(x) =W000 +W100 x1 +W010 x2 +W001x3 +W110 x1x2 +W101 x1x3 +W011 x2x3 +W111 x1x2x3. (3) Note that all permutations of features in a term (e.g. x1x2 and x2x1) correspond to a single term and have exactly one associated weight (e.g. W110). In the general case, we enumerate the subsets of features with a binary vector (i1, . . . , id), where ik = 1 if the k-th feature belongs to the subset. The model equation looks as follows y(x) = 1 i1=0 . . . 1 id=0 Wi1...id d k=1 xikk . (4) Here we assume that 00 = 1. The model is parametrized by a d-dimensional tensor W , which consist of 2d elements. The model equation (4) is linear with respect to the weight tensor W . To emphasize this fact and simplify the notation we rewrite the model equation (4) as a tensor dot product y(x) = X ,W, where the tensor X is defined as follows Xi1...id = d k=1 xikk . (5) Note that there is no need in a separate bias term, since it is already included in the model as the weight tensor elementW0...0 (see the model equation example (3)). The key idea of our method is to compactly represent the exponentially large tensor of parameters W in the Tensor Train format (Oseledets, 2011).",
      "exclude": false
    },
    {
      "heading": "4 TENSOR TRAIN",
      "text": "A d-dimensional tensor A is said to be represented in the Tensor Train (TT) format (Oseledets, 2011), if each of its elements can be computed as the following product of d 2 matrices and 2 vectors Ai1...id = G1[i1] . . . Gd[id], (6) where for any k = 2, . . . , d 1 and for any value of ik, Gk[ik] is an r r matrix, G1[i1] is a 1 r vector and Gd[id] is an r 1 vector (see Fig. 1). We refer to the collection of matrices Gk corresponding to the same dimension k (technically, a 3-dimensional array) as the k-th TT-core, where k = 1, . . . , d. The size r of the slices Gk[ik] controls the trade-off between the representational power of the TT-format and computational efficiency of working with the tensor. We call r the TT-rank of the tensor A. An attractive property of the TT-format is the ability to perform algebraic operations on tensors without materializing them, i.e. by working with the TT-cores instead of the tensors themselves. The TT-format supports computing the norm of a tensor and the dot product between tensors; element-wise sum and element-wise product of two tensors (the result is a tensor in the TT-format with increased TT-rank), and some other operations (Oseledets, 2011).",
      "exclude": false
    },
    {
      "heading": "5 INFERENCE",
      "text": "In this section, we return to the model proposed in Sec. 3 and show how to compute the model equation (4) in linear time. To avoid the exponential complexity, we represent the weight tensor W and the data tensor X (5) in the TT-format. The TT-ranks of these tensors determine the efficiency of the scheme. During the learning, we initialize and optimize the tensor W in the TT-format and explicitly control its TT-rank. The TT-rank of the tensor X always equals 1. Indeed, the following TT-cores give the exact representation of the tensor X Gk[ik] = x ik k R 11, k = 1, . . . , d. The k-th core Gk[ik] is a 1 1 matrix for any value of ik 0, 1, hence the TT-rank of the tensor X equals 1. Now that we have a TT-representations of tensors W and X , we can compute the model response y(x) = X ,W in the linear time with respect to the number of features d. Theorem 1. The model response y(x) can be computed in O(r2d), where r is the TT-rank of the weight tensor W . We refer the reader to Appendix A where we propose an inference algorithm with O(r2d) complexity and thus prove Theorem 1. The TT-rank of the weight tensor W is a hyper-parameter of our method and it controls the efficiency vs. flexibility trade-off. A small TT-rank regularizes the model and yields fast learning and inference but restricts the possible values of the tensor W . A large TT-rank allows any value of the tensor W and effectively leaves us with the full polynomial model without any advantages of the TT-format.",
      "exclude": false
    },
    {
      "heading": "6 LEARNING",
      "text": "Learning the parameters of the proposed model corresponds to minimizing the loss under the TT-rank constraint: minimize W L(W), subject to TT-rank(W) = r0, (7) where the loss is defined as follows L(W) = N f=1 ` ( X (f),W, y(f) ) + 2 W2F , W 2 F = 1 i1=0 . . . 1 id=0 W2i1...id . (8) We consider two approaches to solving problem (7). In a baseline approach, we optimize the objective L(W) with stochastic gradient descent applied to the underlying parameters of the TT-format of the tensor W . A simple alternative to the baseline is to perform gradient descent with respect to the tensor W , that is subtract the gradient from the current estimate of W on each iteration. The TT-format indeed allows to subtract tensors, but this operation increases the TT-rank on each iteration, making this approach impractical. To improve upon the baseline and avoid the TT-rank growth, we exploit the geometry of the set of tensors that satisfy the TT-rank constraint (7) to build a Riemannian optimization procedure (Sec. 6.1). We experimentally show the advantage of this approach over the baseline in Sec. 8.2.",
      "exclude": false
    },
    {
      "heading": "6.1 RIEMANNIAN OPTIMIZATION",
      "text": "The set of all d-dimensional tensors with fixed TT-rank r Mr = W R2...2 : TT-rank(W) = r forms a Riemannian manifold (Holtz et al., 2012). This observation allows us to use Riemannian optimization to solve problem (7). Riemannian gradient descent consists of the following steps which are repeated until convergence (see Fig. 2 for an illustration): 1. Project the gradient LW on the tangent space ofMr taken at the point W . We denote the tangent space as TWMr and the projection as G = PTWMr ( LW ). 2. Follow along G with some step (this operation increases the TT-rank). 3. Retract the new point W G back to the manifoldMr, that is decrease its TT-rank to r. We now describe how to implement each of the steps outlined above. Lubich et al. (2015) proposed an algorithm to project a TT-tensor Z on the tangent space of Mr at a point W which consists of two steps: preprocess W in O(dr3) and project Z in O(dr2 TT-rank(Z)2). Lubich et al. (2015) also showed that the TT-rank of the projection is bounded by a constant that is independent of the TT-rank of the tensor Z: TT-rank(PTWMr (Z)) 2TT-rank(W) = 2r. Let us consider the gradient of the loss function (8) L W = N f=1 ` y X (f) + W . (9) Using the fact that PTWMr (W) = W and that the projection is a linear operator we get PTWMr ( L W ) = N f=1 ` y PTWMr (X (f)) + W . (10) Since the resulting expression is a weighted sum of projections of individual data tensors X (f), we can project them in parallel. Since the TT-rank of each of them equals 1 (see Sec. 5), allN projections cost O(dr2(r +N)) in total. The TT-rank of the projected gradient is less or equal to 2r regardless of the dataset size N . Note that here we used the particular choice of the regularization term. For terms other than L2 (e.g. L1), the gradient may have arbitrary large TT-rank. As a retraction a way to return back to the manifoldMr we use the TT-rounding procedure (Oseledets, 2011). For a given tensor W and rank r the TT-rounding procedure returns a tensor W = TT-round(W , r) such that its TT-rank equals r and the Frobenius norm of the residual WWF is as small as possible. The computational complexity of the TT-rounding procedure is O(dr3). Since we aim for big datasets, we use a stochastic version of the Riemannian gradient descent: on each iteration we sample a random mini-batch of objects from the dataset, compute the stochastic gradient for this mini-batch, make a step along the projection of the stochastic gradient, and retract back to the manifold (Alg. 1). An iteration of the stochastic Riemannian gradient descent consists of inferenceO(dr2M), projection O(dr2(r+M)), and retractionO(dr3), which yieldsO(dr2(r+M)) total computational complexity. Algorithm 1 Riemannian optimization Input: Dataset (x(f), y(f))Nf=1, desired TT-rank r0, number of iterations T , mini-batch size M , learning rate , regularization strength Output: W that approximately minimizes (7) Train linear model (2) to get the parameters w and b Initialize the tensor W0 from w and b with the TT-rank equal r0 for t := 1 to T do Sample M indices h1, . . . , hM U(1, . . . , N) Dt := M j=1 ` yX (hj) + Wt1 Gt := PTWt1Mr (Dt) (10) Wt := TT-round(Wt1 Gt, r0) end for",
      "exclude": false
    },
    {
      "heading": "6.2 INITIALIZATION",
      "text": "We found that a random initialization for the TT-tensor W sometimes freezes the convergence of optimization method (Sec. 8.3). We propose to initialize the optimization from the solution of the corresponding linear model (1). The following theorem shows how to initialize the weight tensor W from a linear model. Theorem 2. For any d-dimensional vector w and a bias term b there exist a tensor W of TT-rank 2, such that for any d-dimensional vector x and the corresponding object-tensor X the dot products x,w and X ,W coincide. The proof is provided in Appendix B.",
      "exclude": false
    },
    {
      "heading": "7 EXTENDING THE MODEL",
      "text": "In this section, we extend the proposed model to handle polynomials of any functions of the features. As an example, consider the logarithms of the features in the 2-dimensional case: y log(x) =W00 +W01x1 +W10x2 +W11x1x2 +W20 log(x1) +W02 log(x2) +W12 x1 log(x2) +W21 x2 log(x1) +W22 log(x1) log(x2). In the general case, to model interactions between ng functions g1, . . . , gng of the features we redefine the object-tensor as follows: Xi1...id = d k=1 c(xk, ik), where c(xk, ik) = 1, if ik = 0, g1(xk), if ik = 1, . . . gng (xk), if ik = ng, The weight tensor W and the object-tensor X are now consist of (ng + 1)d elements. After this change to the object-tensor X , learning and inference algorithms will stay unchanged compared to the original model (4). Categorical features. Our basic model handles categorical features xk 1, . . . ,K by converting them into one-hot vectors xk,1, . . . , xk,K . The downside of this approach is that it wastes the model capacity on modeling non-existing interactions between the one-hot vector elements xk,1, . . . , xk,K which correspond to the same categorical feature. Instead, we propose to use one TT-core per categorical feature and use the model extension technique with the following function c(xk, ik) = 1, if xk = ik or ik = 0, 0, otherwise. This allows us to cut the number of parameters per categorical feature from 2Kr2 to (K + 1)r2 without losing any representational power.",
      "exclude": false
    },
    {
      "heading": "8 EXPERIMENTS",
      "text": "We release a Python implementation of the proposed algorithm and the code to reproduce the experiments1. For the operations related to the TT-format, we used the TT-Toolbox2.",
      "exclude": false
    },
    {
      "heading": "8.1 DATASETS",
      "text": "The datasets used in the experiments (see details in Appendix C) 1. UCI (Lichman, 2013) Car dataset is a classification problem with 1728 objects and 21 binary features (after one-hot encoding). We randomly splitted the data into 1382 training and 346 test objects and binarized the labels for simplicity. 2. UCI HIV dataset is a binary classification problem with 1625 objects and 160 features, which we randomly splitted into 1300 training and 325 test objects. 3. Synthetic data. We generated 100 000 train and 100 000 test objects with 30 features and set the ground truth target variable to a 6-degree polynomial of the features. 4. MovieLens 100K is a recommender system dataset with 943 users and 1682 movies (Harper & Konstan, 2015). We followed Blondel et al. (2016a) in preparing 2703 one-hot features and in turning the problem into binary classification.",
      "exclude": false
    },
    {
      "heading": "8.2 RIEMANNIAN OPTIMIZATION",
      "text": "In this experiment, we compared two approaches to training the model: Riemannian optimization (Sec. 6.1) vs. the baseline (Sec. 6). In this and later experiments we tuned the learning rate of both Riemannian and SGD optimizers with respect to the training loss after 100 iterations by the grid search with logarithmic grid. On the Car and HIV datasets we turned off the regularization ( = 0) and used rank r = 4. We report that on the Car dataset Riemannian optimization (learning rate = 40) converges faster and achieves better final point than the baseline (learning rate = 0.03) both in terms of the training and test losses (Fig. 3a, 5a). On the HIV dataset Riemannian optimization (learning rate = 800) converges to the value 104 around 20 times faster than the baseline (learning rate = 0.001, see Fig. 3b), but the model overfitts to the data (Fig. 5b). The results on the synthetic dataset with high-order interactions confirm the superiority of the Riemannian approach over SGD we failed to train the model at all with SGD (Fig. 6). On the MovieLens 100K dataset, we have only used SGD-type algorithms, because using the one-hot feature encoding is much slower than using the categorical version (see Sec. 7), and we have yet to implement the support for categorical features for the Riemannian optimizer. On the bright side, prototyping the categorical version of ExM in TensorFlow allowed us to use a GPU accelerator.",
      "exclude": false
    },
    {
      "heading": "8.3 INITIALIZATION",
      "text": "In this experiment, we compared random initialization with the initialization from the solution of the corresponding linear problem (Sec. 6.2). We explored two ways to randomly initialize a TT-tensor: 1) filling its TT-cores with independent Gaussian noise; 2) initializing W to represent a linear model with random coefficients (sampled from a standard Gaussian). We report that on the Car dataset type-1 random initialization slowed the convergence compared to initialization from the linear model solution (Fig. 3a), while on the HIV dataset the convergence was completely frozen (Fig. 3b). Two possible reasons for this effect are: a) the vanishing and exploding gradients problem (Bengio et al., 1994) that arises when dealing with a product of a large number of factors (160 in the case of the HIV dataset); b) initializing the model in such a way that high-order terms dominate we may force the gradient-based optimization to focus on high-order terms, while it may be more stable to start with low-order terms instead. Type-2 initialization (a random linear model) indeed worked on par with the best linear initialization on the Car, HIV, and synthetic datasets (Fig. 3b, 6). 1https://github.com/Bihaqo/exp-machines 2https://github.com/oseledets/ttpy",
      "exclude": false
    },
    {
      "heading": "8.4 COMPARISON TO OTHER APPROACHES",
      "text": "On the synthetic dataset with high-order interactions we campared Exponential Machines (the proposed method) with scikit-learn implementation (Pedregosa et al., 2011) of logistic regression, random forest, and kernel SVM; FastFM implementation (Bayer, 2015) of 2-nd order Factorization Machines; our implementation of high-order Factorization Machines3; and a feed-forward neural network implemented in TensorFlow (Abadi et al., 2015). We used 6-th order FM with the Adam optimizer (Kingma & Ba, 2014) for which wed chosen the best rank (20) and learning rate (0.003) based on the training loss after the first 50 iterations. We tried several feed-forward neural networks with ReLU activations and up to 4 fully-connected layers and 128 hidden units. We compared the models based on the Area Under the Curve (AUC) metric since it is applicable to all methods and is robust to unbalanced labels (Tbl. 1). On the MovieLens 100K dataset we used the categorical features representation described in Sec. 7. Our model obtained 0.784 test AUC with the TT-rank equal 10 in 273 seconds on a Tesla K40 GPU (the inference time is 0.3 seconds per 78800 test objects); our implentation of 3-rd order FM obtained 0.782; logistic regression obtained 0.782; and Blondel et al. (2016a) reported 0.786 with 3-rd order FM on the same data. 3https://github.com/geffy/tffm",
      "exclude": false
    },
    {
      "heading": "8.5 TT-RANK",
      "text": "The TT-rank is one of the main hyperparameters of the proposed model. Two possible strategies can be used to choose it: grid-search or DMRG-like algorithms (see Sec. 9). In our experiments we opted for the former and observed that the model is fairly robust to the choice of the TT-rank (see Fig. 4), but a too small TT-rank can hurt the accuracy (see Tbl. 1).",
      "exclude": false
    },
    {
      "heading": "9 RELATED WORK",
      "text": "Kernel SVM is a flexible non-linear predictor and, in particular, it can model interactions when used with the polynomial kernel (Boser et al., 1992). As a downside, it scales at least quadratically with the dataset size (Bordes et al., 2005) and overfits on highly sparse data. With this in mind, Rendle (2010) developed Factorization Machine (FM), a general predictor that models pairwise interactions. To overcome the problems of polynomial SVM, FM restricts the rank of the weight matrix, which leads to a linear number of parameters and generalizes better on sparse data. FM running time is linear with respect to the number of nonzero elements in the data, which allows scaling to billions of training entries on sparse problems. For high-order interactions FM uses CP-format (Caroll & Chang, 1970; Harshman, 1970) to represent the tensor of parameters. The choice of the tensor factorization is the main difference between the high-order FM and Exponential Machines. The TT-format comes with two advantages over the CP-format: first, the TT-format allows for Riemannian optimization; second, the problem of finding the best TT-rank r approximation to a given tensor always has a solution and can be solved in polynomial time. We found Riemannian optimization superior to the SGD baseline (Sec. 6) that was used in several other models parametrized by a tensor factorization (Rendle, 2010; Lebedev et al., 2014; Novikov et al., 2015). Note that CP-format also allows for Riemannian optimization, but only for 2-order tensors (and thereafter 2-order FM). A number of works used full-batch or stochastic Riemannian optimization for data processing tasks (Meyer et al., 2011; Tan et al., 2014; Xu & Ke, 2016; Zhang et al., 2016). The last work (Zhang et al., 2016) is especially interesting in the context of our method, since it improves the convergence rate of stochastic Riemannian gradient descent and is directly applicable to our learning procedure. In a concurrent work, Stoudenmire & Schwab (2016) proposed a model that is similar to ours but relies on the trigonometric basis (cos(2x), sin( 2x)) in contrast to polynomials (1, x) used in Exponential Machines (see Sec. 7 for an explanation on how to change the basis). They also proposed a different learning procedure inspired by the DMRG algorithm (Schollwock, 2011), which allows to automatically choose the ranks of the model, but is hard to adapt to the stochastic regime. One of the possible ways to combine strengths of the DMRG and Riemannian approaches is to do a full DMRG sweep once in a few epochs of the stochastic Riemannian gradient descent to adjust the ranks. Other relevant works include the model that approximates the decision function with a multidimensional Fourier series whose coefficients lie in the TT-format (Wahls et al., 2014); and models that are similar to FM but include squares and other powers of the features: Tensor Machines (Yang & Gittens, 2015) and Polynomial Networks (Livni et al., 2014). Tensor Machines also enjoy a theoretical generalization bound. In another relevant work, Blondel et al. (2016b) boosted the efficiency of FM and Polynomial Networks by casting their training as a low-rank tensor estimation problem, thus making it multi-convex and allowing for efficient use of Alternative Least Squares types of algorithms. Note that Exponential Machines are inherently multi-convex.",
      "exclude": true
    },
    {
      "heading": "10 DISCUSSION",
      "text": "We presented a predictor that models all interactions of every order. To regularize the model and to make the learning and inference feasible, we represented the exponentially large tensor of parameters in the Tensor Train format. To train the model, we used Riemannian optimization in the stochastic regime and report that it outperforms a popular baseline based on the stochastic gradient descent. However, the Riemannian learning algorithm does not support sparse data, so for dataset with hundreds of thousands of features we are forced to fall back on the baseline learning method. We found that training process is sensitive to initialization and proposed an initialization strategy based on the solution of the corresponding linear problem. The solutions developed in this paper for the stochastic Riemannian optimization may suit other machine learning models parametrized by tensors in the TT-format.",
      "exclude": true
    },
    {
      "heading": "A PROOF OF THEOREM 1",
      "text": "Theorem 1 states that the inference complexity of the proposed algorithm is O(r2d), where r is the TT-rank of the weight tensor W . In this section, we propose an algorithm that achieve the stated complexity and thus prove the theorem. Proof. Let us rewrite the definition of the model response (4) assuming that the weight tensor W is represented in the TT-format (6) y(x) = i1,...,id Wi1...id ( d k=1 xikk ) = i1,...,id G1[i1] . . . Gd[id] ( d k=1 xikk ) . Let us group the factors that depend on the variable ik, k = 1, . . . , d y(x) = i1,...,id xi11 G1[i1] . . . x id d Gd[id] = ( 1 i1=0 xi11 G1[i1] ) . . . ( 1 id=0 xidd Gd[id] ) = A1}{{} 1r A2}{{} rr . . . Ad}{{} r1 , where the matrices Ak for k = 1, . . . , d are defined as follows Ak = 1 ik=0 xikk Gk[ik] = Gk[0] + xkGk[1]. The final value y(x) can be computed from the matricesAk via d1 matrix-by-vector multiplications and 1 vector-by-vector multiplication, which yields O(r2d) complexity. Note that the proof is constructive and corresponds to an implementation of the inference algorithm.",
      "exclude": false
    },
    {
      "heading": "B PROOF OF THEOREM 2",
      "text": "Theorem 2 states that it is possible to initialize the weight tensor W of the proposed model from the weights w of the linear model. Theorem. For any d-dimensional vector w and a bias term b there exist a tensor W of TT-rank 2, such that for any d-dimensional vector x and the corresponding object-tensor X the dot products x,w and X ,W coincide. To proof the theorem, in the rest of this section we show that the tensor W from Theorem 2 is representable in the TT-format with the following TT-cores G1[0] = [ 1 0 ] , G1[1] = [ 0 w1 ] , Gd[0] = [ b 1 ] , Gd[1] = [ wd 0 ] , 2 k d 1 Gk[0] = [ 1 0 0 1 ] , Gk[1] = [ 0 wk 0 0 ] , (11) and thus the TT-rank of the tensor W equals 2. We start the proof with the following lemma: Lemma 1. For the TT-cores (11) and any p = 1, . . . , d 1 the following invariance holds: G1[i1] . . . Gp[ip] = [ 1 0 ] , if p q=1 iq = 0, [ 0 0 ] , if p q=1 iq 2, [ 0 wk ] , if p q=1 iq = 1, and ik = 1. Proof. We prove the lemma by induction. Indeed, for p = 1 the statement of the lemma becomes G1[i1] = [ 1 0 ] , if i1 = 0, [ 0 w1 ] , if i1 = 1, which holds by definition of the first TT-core G1[i1]. Now suppose that the statement of Lemma 1 is true for some p 1 1. If ip = 0, then Gp[ip] is an identity matrix and G1[i1] . . . Gp[ip] = G1[i1] . . . Gp1[ip1]. Also, p q=1 iq = p1 q=1 iq , so the statement of the lemma stays the same. If ip = 1, then there are 3 options: If p1 q=1 iq = 0, then p q=1 iq = 1 and G1[i1] . . . Gp[ip] = [ 1 0 ]Gp[1] = [ 0 wp ] . If p1 q=1 iq 2, then p q=1 iq 2 and G1[i1] . . . Gp[ip] = [ 0 0 ]Gp[1] = [ 0 0 ] . If p1 q=1 iq = 1 with ik = 1, then p q=1 iq 2 and G1[i1] . . . Gp[ip] = [ 0 wk ]Gp[1] = [ 0 0 ] . Which is exactly the statement of Lemma 1. Proof of Theorem 2. The product of all TT-cores can be represented as a product of the first p = d1 cores times the last core Gd[id] and by using Lemma 1 we get Wi1...id = G1[i1] . . . Gd1[id1]Gd[id] = b, if d q=1 iq = 0, 0, if d q=1 iq 2, wk, if d q=1 iq = 1, and ik = 1. The elements of the obtained tensor W that correspond to interactions of order 2 equal to zero; the weight that corresponds to xk equals to wk; and the bias termW0...0 = b. The TT-rank of the obtained tensor equal 2 since its TT-cores are of size 2 2.",
      "exclude": false
    },
    {
      "heading": "C DETAILED DESCRIPTION OF THE DATASETS",
      "text": "We used the following datasets for the experimental evaluation 1. UCI (Lichman, 2013) Car dataset is a classification problem with 1728 objects and 21 binary features (after one-hot encoding). We randomly splitted the data into 1382 training and 346 test objects. For simplicity, we binarized the labels: we picked the first class (unacc) and made a one-versus-rest binary classification problem from the original Car dataset. 2. UCI (Lichman, 2013) HIV dataset is a binary classification problem with 1625 objects and 160 features, which we randomly splitted into 1300 training and 325 test objects. 3. Synthetic data. We generated 100 000 train and 100 000 test objects with 30 features. Each entry of the data matrix X was independently sampled from 1,+1 with equal probabilities 0.5. We also uniformly sampled 20 subsets of features (interactions) of order 6: j11 , . . . , j 1 6 , . . . , j 20 1 , . . . , j 20 6 U1, . . . , 30. We set the ground truth target variable to a deterministic function of the input: y(x) = 20 z=1 z 6 h=1 xjzh , and sampled the weights of the interactions from the uniform distribution: 1, . . . , 20 U(1, 1). 4. MovieLens 100K. MovieLens 100K is a recommender system dataset with 943 users and 1682 movies (Harper & Konstan, 2015). We followed Blondel et al. (2016a) in preparing the features and in turning the problem into binary classification. For users, we converted age (rounded to decades), living area (the first digit of the zipcode), gender and occupation into a binary indicator vector using one-hot encoding. For movies, we used the release year (rounded to decades) and genres, also encoded. This process yielded 49+29 = 78 additional one-hot features for each user-movie pair (943 + 1682 + 78 features in total). Original ratings were binarized using 5 as a threshold. This results in 21200 positive samples, half of which were used for traininig (with equal amount of sampled negative examples) and the rest were used for testing.",
      "exclude": false
    }
  ],
  "fewShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": false,
        "confidence": 0.85,
        "primary_reason": "Novel tensor factorization approach with principled Riemannian optimization for modeling all-order feature interactions. Strong theoretical contributions (Theorems 1-2), practical algorithmic innovations, and solid experimental validation on synthetic and real datasets."
      },
      "token": {
        "prompt_tokens": 7535,
        "completion_tokens": 86,
        "total_tokens": 7621
      },
      "time": "2026-02-08T22:25:03.913296+00:00"
    },
    {
      "model": "gpt-5.2",
      "decision": {
        "rejection": false,
        "confidence": 0.72,
        "primary_reason": "Strong, nontrivial modeling contribution: representing the full exponential-order interaction tensor via Tensor Train yields a scalable, regularized alternative to high-order polynomial/FMs, paired with a principled stochastic Riemannian optimization method and solid empirical evidence (notably on synthetic high-order interactions) plus competitive results on MovieLens; while some gains on real benchmarks are modest and evaluation breadth is limited, the combination of novelty + scalability + optimization technique is likely above the ICML/ICLR/NeurIPS bar."
      },
      "token": {
        "prompt_tokens": 9109,
        "completion_tokens": 129,
        "total_tokens": 9238
      },
      "time": "2026-02-09T20:26:33.123018+00:00"
    }
  ],
  "test": false
}