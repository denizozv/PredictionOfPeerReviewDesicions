{
  "id": "453",
  "title": "Loss-aware Binarization of Deep Networks",
  "abstract": "Deep neural network models, though very powerful and highly successful, are computationally expensive in terms of space and time. Recently, there have been a number of attempts on binarizing the network weights and activations. This greatly reduces the network size, and replaces the underlying multiplications to additions or even XNOR bit operations. However, existing binarization schemes are based on simple matrix approximations and ignore the effect of binarization on the loss. In this paper, we propose a proximal Newton algorithm with diagonal Hessian approximation that directly minimizes the loss w.r.t. the binarized weights. The underlying proximal step has an efficient closed-form solution, and the second-order information can be efficiently obtained from the second moments already computed by the Adam optimizer. Experiments on both feedforward and recurrent networks show that the proposed loss-aware binarization algorithm outperforms existing binarization schemes, and is also more robust for wide and deep networks.",
  "accepted": true,
  "zeroShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": false,
        "confidence": 0.72,
        "primary_reason": "Novel loss-aware binarization approach using proximal Newton with diagonal Hessian approximation shows consistent improvements over existing methods (BinaryConnect, BWN) across feedforward and recurrent networks. Solid theoretical foundation with convergence analysis and practical algorithm. However, limited experimental scope (only MNIST, CIFAR-10, SVHN, and 2 language modeling datasets) and modest improvements on CIFAR-10 are concerns. The work makes a meaningful contribution to neural network compression but lacks the breadth of evaluation or significant performance gains expected for top-tier venues."
      },
      "token": {
        "prompt_tokens": 6854,
        "completion_tokens": 151,
        "total_tokens": 7005
      },
      "time": "2026-02-05T22:48:15.170072+00:00"
    }
  ],
  "article": [
    {
      "heading": "1 INTRODUCTION",
      "text": "Recently, deep neural networks have achieved state-of-the-art performance in various tasks such as speech recognition, visual object recognition, and image classification (LeCun et al., 2015). Though powerful, the large number of network weights leads to space and time inefficiencies in both training and storage. For instance, the popular AlexNet, VGG-16 and Resnet-18 all require hundred of megabytes to store, and billions of high-precision operations on classification. This limits its use in embedded systems, smart phones and other portable devices that are now everywhere. To alleviate this problem, a number of approaches have been recently proposed. One attempt first trains a neural network and then compresses it (Han et al., 2016; Kim et al., 2016). Instead of this two-step approach, it is more desirable to train and compress the network simultaneously. Example approaches include tensorizing (Novikov et al., 2015), parameter quantization (Gong et al., 2014), and binarization (Courbariaux et al., 2015; Hubara et al., 2016; Rastegari et al., 2016). In particular, binarization only requires one bit for each weight value. This can significantly reduce storage, and also eliminates most multiplications during the forward pass. Courbariaux et al. (2015) pioneered neural network binarization with the BinaryConnect algorithm, which achieves state-of-the-art results on many classification tasks. Besides binarizing the weights, Hubara et al. (2016) further binarized the activations. Rastegari et al. (2016) also learned to scale the binarized weights, and obtained better results. Besides, they proposed the XNOR-network with both weights and activations binarized as in (Hubara et al., 2016). Instead of binarization, ternary-connect quantizes each weight to 1, 0, 1 (Lin et al., 2016). Similarly, the ternary weight network (Li & Liu, 2016) and DoReFa-net (Zhou et al., 2016) quantize weights to three levels or more. However, though using more bits allows more accurate weight approximations, specialized hardwares are needed for the underlying non-binary operations. Besides the huge amount of computation and storage involved, deep networks are difficult to train because of the highly nonconvex objective and inhomogeneous curvature. To alleviate this problem, Hessian-free methods (Martens & Sutskever, 2012) use the second-order information by conjugate gradient. A related method is natural gradient descent (Pascanu & Bengio, 2014), which utilizes ge- ometry of the underlying parameter manifold. Another approach uses element-wise adaptive learning rate, as in Adagrad (Duchi et al., 2011), Adadelta (Zeiler, 2012), RMSprop (Tieleman & Hinton, 2012), and Adam Kingma & Ba (2015). This can also be considered as preconditioning that rescales the gradient so that all dimensions have similar curvatures. In this paper, instead of directly approximating the weights, we propose to consider the effect of binarization on the loss during binarization. We formulate this as an optimization problem using the proximal Newton algorithm (Lee et al., 2014) with a diagonal Hessian. The crux of proximal algorithms is the proximal step. We show that this step has a closed-form solution, whose form is similar to the use of element-wise adaptive learning rate. The proposed method also reduces to BinaryConnect (Courbariaux et al., 2015) and the Binary-Weight-Network (Hubara et al., 2016) when curvature information is dropped. Experiments on both feedforward and recurrent neural network models show that it outperforms existing binarization algorithms. In particular, BinaryConnect fails on deep recurrent networks because of the exploding gradient problem, while the proposed method still demonstrates robust performance. Notations: For a vector x, x denotes the element-wise square root, |x| denotes the element-wise absolute value, xp = ( i |xi|p) 1 p is the p-norm of x, x 0 denotes that all entries of x are positive, sign(x) is the vector with [sign(x)]i = 1 if xi 0 and 1 otherwise, and Diag(x) returns a diagonal matrix with x on the diagonal. For two vectors x and y, x y denotes the elementwise multiplication and x y denotes the element-wise division. For a matrix X, vec(X) returns the vector obtained by stacking the columns of X, and diag(X) returns a diagonal matrix whose diagonal elements are extracted from diagonal of X.",
      "exclude": true
    },
    {
      "heading": "2 RELATED WORK",
      "text": "",
      "exclude": true
    },
    {
      "heading": "2.1 WEIGHT BINARIZATION IN DEEP NETWORKS",
      "text": "In a feedforward neural network with L layers, let the weight matrix (or tensor in the case of a convolutional layer) at layer l be Wl. We combine the (full-precision) weights from all layers as w = [w>1 ,w > 2 , . . . ,w > L ] >, where wl = vec(Wl). Analogously, the binarized weights are denoted as w = [w>1 , w > 2 , . . . , w > L ] >. As it is essential to use full-precision weights during updates (Courbariaux et al., 2015), typically binarized weights are only used during the forward and backward propagations, but not on parameter update. At the tth iteration, the (full-precision) weight wtl is updated by using the backpropagated gradientl`(wt1) (where ` is the loss andl`(wt1) is the partial derivative of ` w.r.t. the weights of the lth layer). In the next forward propagation, it is then binarized as wtl = Binarize(w t l), where Binarize() is some binarization scheme. The two most popular binarization schemes are BinaryConnect (Courbariaux et al., 2015) and Binary-Weight-Network (BWN) (Rastegari et al., 2016). In BinaryConnect, binarization is performed by transforming each element of wtl to 1 or +1 using the sign function:1 Binarize(wtl) = sign(w t l). (1) Besides the binarized weight matrix, a scaling parameter is also learned in BWN. In other words, Binarize(wtl) = t lb t l , where t l > 0 and b t l is binary. They are obtained by minimizing the difference between wtl and t lb t l , and have a simple closed-form solution: tl = wtl1 nl , btl = sign(w t l), (2) where nl is the number of weights in layer l. Hubara et al. (2016) further binarized the activations as xtl = sign(x t l), where x t l is the activation of the lth layer at iteration t.",
      "exclude": false
    },
    {
      "heading": "2.2 PROXIMAL NEWTON ALGORITHM",
      "text": "The proximal Newton algorithm (Lee et al., 2014) has been popularly used for solving composite optimization problems of the form min x f(x) + g(x), 1A stochastic binarization scheme is also proposed in (Courbariaux et al., 2015). However, it is much more computational expensive than (1) and so will not be considered here. where f is convex and smooth, and g is convex but possibly nonsmooth. At iteration t, it generates the next iterate as xt+1 = argmin x f(xt)>(x xt) + (x xt)>H(x xt) + g(x), where H is an approximate Hessian matrix of f at xt. With the use of second-order information, the proximal Newton algorithm converges faster than the proximal gradient algorithm (Lee et al., 2014). Recently, by assuming that f and g have difference-of-convex decompositions (Yuille & Rangarajan, 2002), the proximal Newton algorithm is also extended to the case where g is nonconvex (Rakotomamonjy et al., 2016).",
      "exclude": false
    },
    {
      "heading": "3 LOSS-AWARE BINARIZATION",
      "text": "As can be seen, existing weight binarization methods (Courbariaux et al., 2015; Rastegari et al., 2016) simply find the closest binary approximation of w, and ignore its effects to the loss. In this paper, we consider the loss directly during binarization. As in (Rastegari et al., 2016), we also binarize the weight wl in each layer as wl = lbl, where l > 0 and bl is binary. In the following, we make the following assumptions on `. (A1) ` is continuously differentiable with Lipschitz-continuous gradient, i.e., there exists > 0 such that `(u)`(v)2 u v2 for any u,v; (A2) ` is bounded from below.",
      "exclude": false
    },
    {
      "heading": "3.1 BINARIZATION USING PROXIMAL NEWTON ALGORITHM",
      "text": "We formulate weight binarization as the following optimization problem: minw `(w) (3) s.t. wl = lbl, l > 0, bl 1nl , l = 1, . . . , L, (4) where ` is the loss. Let C be the feasible region in (4), and define its indicator function: IC(w) = 0 if w C, and otherwise. Problem (3) can then be rewritten as min w `(w) + IC(w). (5) We solve (5) using the proximal Newton method (Section 2.2). At iteration t, the smooth term `(wt) is replaced by the second-order expansion `(wt1) +`(wt1)>(wt wt1) + 1 2 (wt wt1)>Ht1(wt wt1), where Ht1 is an estimate of the Hessian of ` at wt1. Note that using the Hessian to capture second-order information is essential for efficient neural network training, as ` is often flat in some directions but highly curved in others. By rescaling the gradient, the loss has similar curvatures along all directions. This is also called preconditioning in the literature (Dauphin et al., 2015a). For neural networks, the exact Hessian is rarely positive semi-definite. This can be problematic as the nonconvex objective leads to indefinite quadratic optimization. Moreover, computing the exact Hessian is both time- and space-inefficient on large networks. To alleviate these problems, a popular approach is to approximate the Hessian by a diagonal positive definite matrix D. One popular choice is the efficient Jacobi preconditioner. Though an efficient approximation of the Hessian under certain conditions, it is not competitive for indefinite matrices (Dauphin et al., 2015a). More recently, it is shown that equilibration provides a more robust preconditioner in the presence of saddle points (Dauphin et al., 2015a). This is also adopted by popular stochastic optimization algorithms such as RMSprop (Tieleman & Hinton, 2012) and Adam (Kingma & Ba, 2015). Specifically, the second moment v in these algorithms is an estimator of diag(H2) (Dauphin et al., 2015b). Here, we use the square root of this v, which is readily available in Adam, to construct D = Diag([diag(D1)>, . . . , diag(DL)>]>), where Dl is the approximate diagonal Hessian at layer l. In general, other estimators of diag(H) can also be used. At the tth iteration of the proximal Newton algorithm, the following subproblem is solved: minwt `(wt1)>(wt wt1) + 1 2 (wt wt1)>Dt1(wt wt1) (6) s.t. wtl = t lb t l , t l > 0, b t l 1nl , l = 1, . . . , L. Proposition 3.1 Let dt1l diag(D t1 l ), and wtl wt1l l`(w t1) dt1l . (7) The optimal solution of (6) can be obtained in closed-form as tl = dt1l wtl1 dt1l 1 , btl = sign(w t l). (8) Theorem 3.1 Assume that [dtl ]k > l, k, t, the objective of (5) produced by the proximal Newton algorithm (with closed-form update of wt in Proposition 3.1) converges. Note that both the loss ` and indicator function IC() in (5) are not convex. Hence, convergence analysis of the proximal Newton algorithm in (Lee et al., 2014), which is only for convex problems, cannot be applied. Recently, Rakotomamonjy et al. (2016) proposed a nonconvex proximal Newton extension. However, it assumes a difference-of-convex decomposition which does not hold here. Remark 3.1 When Dt1l = I, i.e., the curvature is the same for all dimensions in the lth layer, (8) then reduces to the BWN solution in (2) In other words, BWN corresponds to using the proximal gradient algorithm, while the proposed method corresponds to the proximal Newton algorithm with diagonal Hessian. In composite optimization, it is known that the proximal Newton method is more efficient than the proximal gradient algorithm (Lee et al., 2014; Rakotomamonjy et al., 2016). Remark 3.2 When tl = 1, (8) reduces to sign(wtl), which is the BinaryConnect solution in (1). From (7) and (8), each iteration first performs gradient descent along l`(wt1) with an adaptive learning rate 1 dt1l , and then projects it to a binary solution. As discussed in (Courbariaux et al., 2015), it is important to keep a full-precision weight during training. Hence, we replace (7) by wtl w t1 l l`(wt1) d t1 l . The whole procedure, which will be called Loss-Aware Binarization (LAB), is shown in Algorithm 1. In steps 5 and 6, following (Li & Liu, 2016), we first rescale input xt1l to the lth layer with l, so that multiplications in dot products and convolutions become additions. While binarizing weights changes most multiplications to additions, binarizing both weights and activations saves even more computations as additions are further changed to XNOR bit operations (Hubara et al., 2016). Our Algorithm 1 can also be easily extended by binarizing the activations with the simple sign function.",
      "exclude": false
    },
    {
      "heading": "3.2 EXTENSION TO RECURRENT NEURAL NETWORKS",
      "text": "The proposed method can be easily extended to recurrent neural networks. Let xl and hl be the input and hidden states, respectively, at time step (or depth) l. A typical recurrent neural network has a recurrence of the form hl = Wxxl +Wh(hl1) + b (equivalent to the more widely known hl = (Wxxl+Whhl1+b) (Pascanu et al., 2013) ). We binarize both the input-to-hidden weight Wx and hidden-to-hidden weight Wh. Since weights are shared across time in a recurrent network, we only need to binarize Wx and Wh once in each forward propagation. Besides weights, one can also binarize the activations (of the inputs and hidden states) as in the previous section. In deep networks, the backpropagated gradient takes the form of a product of Jacobian matrices (Pascanu et al., 2013). In a vanilla recurrent neural network,2 for activations hp and hq at depths p and q, respectively (where p > q), hphq = q h diag( (hl1)). The necessary condition for exploding gradients is that the largest singular value 1(Wh) of Wh is larger than some given constant (Pascanu et al., 2013). The following Proposition shows that for any binary Wh, its largest singular value is lower-bounded by the square root of its dimension. Proposition 3.2 For any W 1,+1mn (m n), 1(W) n. 2Here, we consider the vanilla recurrent neural network for simplicity. It can be shown that a similar behavior holds for the more commonly used LSTM. Algorithm 1 Loss-Aware Binarization (LAB) for training a feedforward neural network. Input: Minibatch (xt0,yt), current full-precision weights wtl, first moment m t1 l , second moment vt1l , and learning rate t. 1: Forward Propagation 2: for l = 1 to L do 3: tl = dt1l w t l1 dt1l 1 ; 4: btl = sign(w t l); 5: rescale the layer-l input: xtl1 = t lx t l1; 6: compute ztl with input x t l1 and binary weight b t l ; 7: apply batch-normalization and nonlinear activation to ztl to obtain x t l ; 8: end for 9: compute the loss ` using xtL and y t; 10: Backward Propagation 11: initialize output layers activations gradient ` xtL ; 12: for l = L to 2 do 13: compute ` xtl1 using ` xtl , tl and b t l ; 14: end for 15: Update parameters using Adam 16: for l = 1 to L do 17: compute gradientsl`(wt) using `xtl and x t l1; 18: update first moment mtl = 1m t1 l + (1 1)l`(wt); 19: update second moment vtl = 2v t1 l + (1 2)(l`(wt) l`(wt)); 20: compute unbiased first moment mtl = m t l/(1 t1); 21: compute unbiased second moment vtl = v t l/(1 t2); 22: compute current curvature matrix dtl = 1 t ( 1+ vtl ) ; 23: update full-precision weights wt+1l = w t l mtl dtl ; 24: update learning rate t+1 = UpdateRule(t, t+ 1); 25: end for Thus, with weight binarization as in BinaryConnect, the exploding gradient problem becomes more severe as the weight matrices are often large. On the other hand, recall that 1(cWh) = c1(Wh) for any non-negative c. The proposed method alleviates this exploding gradient problem by adaptively learning the scaling parameter h.",
      "exclude": false
    },
    {
      "heading": "4 EXPERIMENTS",
      "text": "In this section, we perform experiments on the proposed binarization scheme with both feedforward networks (Sections 4.1 and 4.2) and recurrent neural networks (Sections 4.3 and 4.4).",
      "exclude": false
    },
    {
      "heading": "4.1 FEEDFORWARD NEURAL NETWORKS",
      "text": "We compare the original full-precision network (without binarization) with the following weightbinarized networks: (i) BinaryConnect; (ii) Binary-Weight-Network (BWN); and (iii) the proposed Loss-Aware Binarized network (LAB). We also compare with networks having both weights and activations binarized:3 (i) BinaryNeuralNetwork (BNN) (Hubara et al., 2016), the weight-andactivation binarized counterpart of BinaryConnect; (ii) XNOR-Network (XNOR) (Rastegari et al., 2016), the counterpart of BWN; (iii) LAB2, the counterpart of the proposed method, which binarizes weights using proximal Newton method and binarizes activations using a simple sign function. The setup is similar to that in Courbariaux et al. (2015). We do not perform data augmentation or unsupervised pretraining. Experiments are performed on three commonly used data sets: 3We use the straight-through-estimator (Hubara et al., 2016) to compute the gradient involving the sign function. 1. MNIST: This contains 28 28 gray images from ten digit classes. We use 50000 images for training, another 10000 for validation, and the remaining 10000 for testing. We use the 4-layer model: 784FC 2048FC 2048FC 2048FC 10SVM, where FC is a fully-connected layer, and SVM is a L2-SVM output layer using the square hinge loss. Batch normalization, with a minibatch size 100, is used to accelerate learning. The maximum number of epochs is 50. The learning rate for the weight-binarized (resp. weight-and-activation-binarized) network starts at 0.01 (resp. 0.005), and decays by a factor of 0.1 at epochs 15 and 25. 2. CIFAR-10: This contains 32 32 color images from ten object classes. We use 45000 images for training, another 5000 for validation, and the remaining 10000 for testing. The images are preprocessed with global contrast normalization and ZCA whitening. We use the VGG-like architecture: (2128C3)MP2(2256C3)MP2(2512C3)MP2(21024FC)10SVM, where C3 is a 33 ReLU convolution layer, andMP2 is a 22 max-pooling layer. Batch normalization, with a minibatch size of 50, is used. The maximum number of epochs is 200. The learning rate for the weight-binarized (resp. weight-and-activation-binarized) network starts at 0.03 (resp. 0.02), and decays by a factor of 0.5 after every 15 epochs. 3. SVHN: This contains 32 32 color images from ten digit classes. We use 598388 images for training, another 6000 for validation, and the remaining 26032 for testing. The images are preprocessed with global and local contrast normalization. The model used is: (264C3)MP2(2128C3)MP2(2256C3)MP2(21024FC)10SVM. Batch normalization, with a minibatch size of 50, is used. The maximum number of epochs is 50. The learning rate for the weight-binarized (resp. weight-and-activation-binarized) network starts at 0.001 (resp. 0.0005), and decays by a factor of 0.1 at epochs 15 and 25. Since binarization is a form of regularization (Courbariaux et al., 2015), we do not use other regularization methods (like Dropout). All the weights are initialized as in (Glorot & Bengio, 2010). Adam (Kingma & Ba, 2015) is used as the optimization solver. Table 1 shows the test classification error rates, and Figure 1 shows the convergence of LAB. As can be seen, the proposed LAB achieves the lowest error on MNIST and SVHN. It even outperforms the full-precision network on MNIST, as weight binarization serves as a regularizer. With the use of curvature information, LAB outperforms BinaryConnect and BWN. On CIFAR-10, LAB is slightly outperformed by BinaryConnect, but is still better than the full-precision network. Among the schemes that binarize both weights and activations, LAB2 also outperforms BNN and the XNOR-Network.",
      "exclude": false
    },
    {
      "heading": "4.2 VARYING THE NUMBER OF FILTERS IN CNN",
      "text": "As in Zhou et al. (2016), we study sensitivity to network width by varying the number of filters K on the SVHN data set. As in Section 4.1, we use the model (2 KC3)MP2 (2 2KC3)MP2 (2 4KC3)MP2 (2 1024FC) 10SVM. Results are shown in Table 2. Again, the proposed LAB has the best performance. Moreover, as the number of filters increases, degradation due to binarization becomes less severe. This suggests that more powerful models (e.g., CNN with more filters, standard feedforward networks with more hidden units) are less susceptible to performance degradation due to binarization. We speculate that this is because large networks often have larger-than-needed capacities, and so are less affected by the limited expressiveness of binary weights. Another related reason is that binarization acts as regularization, and so contributes positively to the performance.",
      "exclude": false
    },
    {
      "heading": "4.3 RECURRENT NEURAL NETWORKS",
      "text": "In this section, we perform experiments on the popular long short-term memory (LSTM) (Hochreiter & Schmidhuber, 1997). Performance is evaluated in the context of character-level language modeling. The LSTM takes as input a sequence of characters, and predicts the next character at each time step. The training objective is the cross-entropy loss over all target sequences. Following Karpathy et al. (2016), we use two data sets (with the same training/validation/test set splitting): (i) Leo Tolstoys War and Peace, which consists of 3258246 characters of almost entirely English text with minimal markup and has a vocabulary size of 87; and (ii) the source code of the Linux Kernel, which consists of 6206996 characters and has a vocabulary size of 101. We use a one-layer LSTM with 512 cells. The maximum number of epochs is 200, and the number of time steps is 100. The initial learning rate is 0.002. After 10 epochs, it is decayed by a factor of 0.98 after each epoch. The weights are initialized uniformly in [0.08, 0.08]. After each iteration, the gradients are clipped to the range [5, 5], and all the updated weights are clipped to [1, 1]. For the weight-and-activation-binarized networks, we do not binarize the inputs, as they are one-hot vectors in this language modeling task. Table 3 shows the testing cross-entropy values. As in Section 4.1, the proposed LAB outperforms other weight binarization schemes, and is even better than the full-precision network on the Linux Kernel data set. BinaryConnect does not work well here because of the problem of exploding gradients (see Section 3.2 and more results in Section 4.4). On the other hand, BWN and the proposed LAB scale the binary weight matrix and perform better. LAB also performs better than BWN as curvature information is considered. Similarly, among schemes that binarize both weights and activations, the proposed LAB2 also outperforms BNN and XNOR-Network.",
      "exclude": false
    },
    {
      "heading": "4.4 VARYING THE NUMBER OF TIME STEPS IN LSTM",
      "text": "In this experiment, we study the sensitivity of the binarization schemes with varying numbers of unrolled time steps (TS) in LSTM. Results are shown in Table 4. Again, the proposed LAB has the best performance. When TS = 10, the LSTM is relatively shallow, and all binarization schemes have similar performance as the full-precision network. When TS 50, BinaryConnect fails, while BWN and the proposed LAB perform better (as discussed in Section 3.2). Figure 2 shows the distributions of the hidden-to-hidden weight gradients for TS = 10 and 100. As can be seen, while all models have similar gradient distributions at TS = 10, the gradient values in BinaryConnect are much higher than those of the other algorithms for the deeper network (TS = 100). Note from Table 4 that as the time step increases, all except BinaryConnect show better performance. However, degradation due to binarization also becomes more severe. This is because the weights are shared across time steps. Hence, error due to binarization also propagates across time.",
      "exclude": false
    },
    {
      "heading": "5 CONCLUSION",
      "text": "In this paper, we propose a binarization algorithm that directly considers its effect on the loss during binarization. The binarized weights are obtained using proximal Newton algorithm with diagonal Hessian approximation. The proximal step has an efficient closed-form solution, and the secondorder information in the Hessian can be readily obtained from the Adam optimizer. Experiments show that the proposed algorithm outperforms existing binarization schemes, has comparable performance as the original full-precision network, and is also robust for wide and deep networks.",
      "exclude": true
    },
    {
      "heading": "ACKNOWLEDGMENTS",
      "text": "This research was supported in part by the Research Grants Council of the Hong Kong Special Administrative Region (Grant 614513). We thank Yongqi Zhang for helping with the experiments, and developers of Theano (Theano Development Team, 2016), Pylearn2 (Goodfellow et al., 2013) and Lasagne. We also thank NVIDIA for the support of Titan X GPU.",
      "exclude": true
    },
    {
      "heading": "A PROOF OF PROPOSITION 3.1",
      "text": "`(wt1)>(wt wt1) + 1 2 (wt wt1)>Dt1(wt wt1) = 1 2 L l=1 ( (dt1l ) > ( wtl (wt1l l`(w t1) dt1l ) ))2 + c1 = 1 2 L l=1 ( (dt1l ) >(wtl wtl) )2 + c1 = 1 2 L l=1 ( (dt1l ) >(tlb t l wtl) )2 + c1, where c1 = 12 ( (dt1l ) >(l`(wt1) dt1l ) )2 . Since tl > 0,d t l 0,l = 1, 2, . . . , L, we have btl = sign(w t l). Moreover, 1 2 L l=1 ( (dt1l ) >(tlb t l wtl))2 + c1 = 1 2 L l=1 ( (dt1l ) >( tl1 |wtl |))2 + c1 = L l=1 1 2 dt1l 1( t l) 2 dt1l w t l1tl + c2, where c2 = c1 12 dt1l w t l 2 1 dt1l 1 . Thus, the optimal tl is dt1l w t l1 dt1l 1 .",
      "exclude": false
    },
    {
      "heading": "B PROOF OF THEOREM 3.1",
      "text": "Let = [t1 . . . , t L] >, and denote the objective in (3) by F (w,). As wt is the minimizer in (6), we have `(wt1) +`(wt1)>(wt wt1) + 1 2 (wt wt1)>Dt1(wt wt1) `(wt1). (9) From Assumption A1, we have `(wt) `(wt1) +`(wt1)>(wt wt1) + 2 wt wt12 2 . (10) Using (9) and (10), we obtain `(wt) `(wt1) 1 2 (wt wt1)>(Dt1 I)(wt wt1) `(wt1) mink,l([d t1 l ]k ) 2 wt wt12 2 . Let c3 = mink,l,t([dt1l ]k ) > 0. Then, `(wt) `(wt1) c3 2 wt wt12 2 . (11) From Assumption A2, ` is bounded from below. Together with the fact that `(wt) is monotonically decreasing from (11), the sequence `(wt) converges, thus the sequence F (wt,t) also converges.",
      "exclude": false
    },
    {
      "heading": "C PROOF OF PROPOSITION 3.2",
      "text": "Let the singulars values of W be 1(W) 2(W) m(W). 21(W) 1 m m i=1 2i (W) = 1 m W2F = 1 m mn = n. Thus, 1(W) n.",
      "exclude": false
    }
  ]
}