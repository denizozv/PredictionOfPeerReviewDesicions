{
  "id": "363",
  "title": "A Compare-Aggregate Model for Matching Text Sequences",
  "abstract": "Many NLP tasks including machine comprehension, answer selection and text entailment require the comparison between sequences. Matching the important units between sequences is a key to solve these problems. In this paper, we present a general \"compare-aggregate\" framework that performs word-level matching followed by aggregation using Convolutional Neural Networks. We particularly focus on the different comparison functions we can use to match two vectors. We use four different datasets to evaluate the model. We find that some simple comparison functions based on element-wise operations can work better than standard neural network and neural tensor network.",
  "accepted": true,
  "zeroShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": false,
        "confidence": 0.72,
        "primary_reason": "Solid empirical work on sequence matching with systematic comparison of matching functions across multiple datasets. Good experimental validation and practical contributions, though limited novelty in individual components. Suitable for ICLR/NeurIPS but borderline for top-tier venues due to incremental nature of combining existing techniques."
      },
      "token": {
        "prompt_tokens": 4666,
        "completion_tokens": 91,
        "total_tokens": 4757
      },
      "time": "2026-02-05T22:38:11.509857+00:00"
    }
  ],
  "article": [
    {
      "heading": "1 INTRODUCTION",
      "text": "Many natural language processing problems involve matching two or more sequences to make a decision. For example, in textual entailment, one needs to determine whether a hypothesis sentence can be inferred from a premise sentence (Bowman et al., 2015). In machine comprehension, given a passage, a question needs to be matched against it in order to find the correct answer (Richardson et al., 2013; Tapaswi et al., 2016). Table 1 gives two example sequence matching problems. In the first example, a passage, a question and four candidate answers are given. We can see that to get the correct answer, we need to match the question against the passage and identify the last sentence to be the answer-bearing sentence. In the second example, given a question and a set of candidate answers, we need to find the answer that best matches the question. Because of the fundamental importance of comparing two sequences of text to judge their semantic similarity or relatedness, sequence matching has been well studied in natural language processing. With recent advances of neural network models in natural language processing, a standard practice for sequence modeling now is to encode a sequence of text as an embedding vector using models such as RNN and CNN. To match two sequences, a straightforward approach is to encode each sequence as a vector and then to combine the two vectors to make a decision (Bowman et al., 2015; Feng et al., 2015). However, it has been found that using a single vector to encode an entire sequence is not sufficient to capture all the important information from the sequence, and therefore advanced techniques such as attention mechanisms and memory networks have been applied to sequence matching problems (Hermann et al., 2015; Hill et al., 2016; Rocktaschel et al., 2015). A common trait of a number of these recent studies on sequence matching problems is the use of a compare-aggregate framework (Wang & Jiang, 2016b; He & Lin, 2016; Parikh et al., 2016). In such a framework, comparison of two sequences is not done by comparing two vectors each representing an entire sequence. Instead, these models first compare vector representations of smaller units such as words from these sequences and then aggregate these comparison results to make the final decision. For example, the match-LSTM model proposed by Wang & Jiang (2016b) for textual entailment first compares each word in the hypothesis with an attention-weighted version of the premise. The comparison results are then aggregated through an LSTM. He & Lin (2016) proposed a pairwise word interaction model that first takes each pair of words from two sequences and applies a comparison unit on the two words. It then combines the results of these word interactions using a similarity focus layer followed by a multi-layer CNN. Parikh et al. (2016) proposed a decomposable attention model for textual entailment, in which words from each sequence are compared with an attention-weighted version of the other sequence to produce a series of comparison vectors. The comparison vectors are then aggregated and fed into a feed forward network for final classification. Although these studies have shown the effectiveness of such a compare-aggregate framework for sequence matching, there are at least two limitations with these previous studies: (1) Each of the models proposed in these studies is tested on one or two tasks only, but we hypothesize that this general framework is effective on many sequence matching problems. There has not been any study that empirically verifies this. (2) More importantly, these studies did not pay much attention to the comparison function that is used to compare two small textual units. Usually a standard feedforward network is used (Hu et al., 2014; Wang & Jiang, 2016b) to combine two vectors representing two units that need to be compared, e.g., two words. However, based on the nature of these sequence matching problems, we essentially need to measure how semantically similar the two sequences are. Presumably, this property of these sequence matching problems should guide us in choosing more appropriate comparison functions. Indeed He & Lin (2016) used cosine similarity, Euclidean distance and dot product to define the comparison function, which seem to be better justifiable. But they did not systematically evaluate these similarity or distance functions or compare them with a standard feedforward network. In this paper, we argue that the general compare-aggregate framework is effective for a wide range of sequence matching problems. We present a model that follows this general framework and test it on four different datasets, namely, MovieQA, InsuranceQA, WikiQA and SNLI. The first three datasets are for Question Answering, but the setups of the tasks are quite different. The last dataset is for textual entailment. More importantly, we systematically present and test six different comparison functions. We find that overall a comparison function based on element-wise subtraction and multiplication works the best on the four datasets. The contributions of this work are twofold: (1) Using four different datasets, we show that our model following the compare-aggregate framework is very effective when compared with the state-ofthe-art performance on these datasets. (2) We conduct systematic evaluation of different comparison functions and show that a comparison function based on element-wise operations, which is not widely used for word-level matching, works the best across the different datasets. We believe that these findings will be useful for future research on sequence matching problems. We have also made our code available online.1",
      "exclude": true
    },
    {
      "heading": "2 METHOD",
      "text": "In this section, we propose a general model following the compare-aggregate framework for matching two sequences. This general model can be applied to different tasks. We focus our discussion on six different comparison functions that can be plugged into this general compare-aggregate model. In particular, we hypothesize that two comparison functions based on element-wise operations, SUB and MULT, are good middle ground between highly flexible functions using standard neural network models and highly restrictive functions based on cosine similarity and/or Euclidean 1https://github.com/shuohangwang/SeqMatchSeq distance. As we will show in the experiment section, these comparison functions based on elementwise operations can indeed perform very well on a number of sequence matching problems.",
      "exclude": false
    },
    {
      "heading": "2.1 PROBLEM DEFINITION AND MODEL OVERVIEW",
      "text": "The general setup of the sequence matching problem we consider is the following. We assume there are two sequences to be matched. We use two matrices Q RdQ and A RdA to represent the word embeddings of the two sequences, where Q and A are the lengths of the two sequences, respectively, and d is the dimensionality of the word embeddings. In other words, each column vector of Q or A is an embedding vector representing a single word. Given a pair of Q and A, the goal is to predict a label y. For example, in textual entailment, Q may represent a premise and A a hypothesis, and y indicates whether Q entails A or contradicts A. In question answering, Q may be a question and A a candidate answer, and y indicates whether A is the correct answer to Q. We treat the problem as a supervised learning task. We assume that a set of training examples in the form of (Q,A, y) is given and we aim to learn a model that maps any pair of (Q,A) to a y. An overview of our model is shown in Figure 1. The model can be divided into the following four layers: 1. Preprocessing: We use a preprocessing layer (not shown in the figure) to process Q and A to obtain two new matrices Q RlQ and A RlA. The purpose here is to use some gate values to control the importance of different words in making the predictions on the sequence pair. For example, qi Rl, which is the ith column vector of Q, encodes the ith word in Q. 2. Attention: We apply a standard attention mechanism on Q and A to obtain attention weights over the column vectors in Q for each column vector in A. With these attention weights, for each column vector aj in A, we obtain a corresponding vector hj , which is an attention-weighted sum of the column vectors of Q. 3. Comparison: We use a comparison function f to combine each pair of aj and hj into a vector tj . 4. Aggregation: We use a CNN layer to aggregate the sequence of vectors tj for the final classification. Although this model follows more or less the same framework as the model proposed by Parikh et al. (2016), our work has some notable differences. First, we will pay much attention to the comparison function f and compare a number of options, including some uncommon ones based on elementwise operations. Second, we apply our model to four different datasets representing four different tasks to evaluate its general effectiveness for sequence matching problems. There are also some other differences from the work by Parikh et al. (2016). For example, we use a CNN layer instead of summation and concatenation for aggregation. Our attention mechanism is one-directional instead of two-directional. In the rest of this section we will present the model in detail. We will focus mostly on the comparison functions we consider.",
      "exclude": false
    },
    {
      "heading": "2.2 PREPROCESSING AND ATTENTION",
      "text": "Inspired by the use of gates in LSTM and GRU, we preprocess Q and A with the following formulas: Q = (WiQ+ bi eQ) tanh(WuQ+ bu eQ), A = (WiA+ bi eA) tanh(WuA+ bu eA), (1) where is element-wise multiplication, and Wi,Wu Rld and bi,bu Rl are parameters to be learned. The outer product ( eX) produces a matrix or row vector by repeating the vector or scalar on the left for X times. Here (WiQ + bi eQ) and (WiA + bi eA) act as gate values to control the degree to which the original values of Q and A are preserved in Q and A. For example, for stop words, their gate values would likely be low for tasks where stop words make little difference to the final predictions. In this preprocessing step, the word order does not matter. Although a better way would be to use RNN such as LSTM and GRU to chain up the words such that we can capture some contextual information, this could be computationally expensive for long sequences. In our experiments, we only incorporated LSTM into the formulas above for the SNLI task. The general attention (Luong et al., 2015) layer is built on top of the resulting Q and A as follows: G = softmax ( (WgQ+ bg eQ)TA ) , H = QG, (2) where Wg Rll and bg Rl are parameters to be learned, G RQA is the attention weight matrix, and H RlA are the attention-weighted vectors. Specifically, hj , which is the jth column vector of H, is a weighted sum of the column vectors of Q and represents the part of Q that best matches the jth word in A. Next we will combine hj and aj using a comparison function.",
      "exclude": false
    },
    {
      "heading": "2.3 COMPARISON",
      "text": "The goal of the comparison layer is to match each aj , which represents the jth word and its context in A, with hj , which represents a weighted version of Q that best matches aj . Let f denote a comparison function that transforms aj and hj into a vector tj to represent the comparison result. A natural choice of f is a standard neural network layer that consists of a linear transformation followed by a non-linear activation function. For example, we can consider the following choice: NEURALNET (NN): tj = f(aj ,hj) = ReLU(W [ aj hj ] + b), (3) where matrix W Rl2l and vector b Rl are parameters to be learned. Alternatively, another natural choice is a neural tensor network (Socher et al., 2013) as follows: NEURALTENSORNET (NTN): tj = f(aj ,hj) = ReLU(aTjT [1...l]hj + b), (4) where tensor T[1...l] Rlll and vector b Rl are parameters to be learned. However, we note that for many sequence matching problems, we intend to measure the semantic similarity or relatedness of the two sequences. So at the word level, we also intend to check how similar or related aj is to hj . For this reason, a more natural choice used in some previous work is Euclidean distance or cosine similarity between aj and hj . We therefore consider the following definition of f : EUCLIDEAN+COSINE (EUCCOS): tj = f(aj ,hj) = [ aj hj2 cos(aj ,hj) ] . (5) Note that with EUCCOS, the resulting vector tj is only a 2-dimensional vector. Although EUCCOS is a well-justified comparison function, we suspect that it may lose some useful information from the original vectors aj and hj . On the other hand, NN and NTN are too general and thus do not capture the intuition that we care mostly about the similarity between aj and hj . To use something that is a good compromise between the two extreme cases, we consider the following two new comparison functions, which operate on the two vectors in an element-wise manner. These functions have been used previously by Mou et al. (2016). SUBTRACTION (SUB): tj = f(aj ,hj) = (aj hj) (aj hj), (6) MULTIPLICATION (MULT): tj = f(aj ,hj) = aj hj . (7) Note that the operator is element-wise multiplication. For both comparison functions, the resulting vector tj has the same dimensionality as aj and hj . We can see that SUB is closely related to Euclidean distance in that Euclidean distance is the sum of all the entries of the vector tj produced by SUB. But by not summing up these entries, SUB preserves some information about the different dimensions of the original two vectors. Similarly, MULT is closely related to cosine similarity but preserves some information about the original two vectors. Finally, we consider combining SUB and MULT followed by an NN layer as follows: SUBMULT+NN: tj = f(aj ,hj) = ReLU(W [ (aj hj) (aj hj) aj hj ] + b). (8) In summary, we consider six different comparison functions: NN, NTN, EUCCOS, SUB, MULT and SUBMULT+NN. Among these functions, the last three (SUB, MULT and SUBMULT+NN) have not been widely used in previous work for word-level matching.",
      "exclude": false
    },
    {
      "heading": "2.4 AGGREGATION",
      "text": "After we apply the comparison function to each pair of aj and hj to obtain a series of vectors tj , finally we aggregate these vectors using a one-layer CNN (Kim, 2014): r = CNN([t1, . . . , tA]). (9) r Rnl is then used for the final classification, where n is the number of windows in CNN.",
      "exclude": false
    },
    {
      "heading": "3 EXPERIMENTS",
      "text": "In this section, we evaluate our model on four different datasets representing different tasks. The first three datasets are question answering tasks while the last one is on textual entailment. The statistics of the four datasets are shown in Table 2. We will fist introduce the task settings and the way we customize the compare-aggregate structure to each task. Then we will show the baselines for the different datasets. Finally, we discuss the experiment results shown in Table 3 and the ablation study shown in Table 4.",
      "exclude": false
    },
    {
      "heading": "3.1 TASK-SPECIFIC MODEL STRUCTURES",
      "text": "In all these tasks, we use matrix Q RdQ to represent the question or premise and matrix Ak RdAk (k [1,K]) to represent the kth answer or the hypothesis. For the machine comprehension task MovieQA (Tapaswi et al., 2016), there is also a matrix P RdP that represents the plot of a movie. Here Q is the length of the question or premise, Ak the length of the kth answer, and P the length of the plot. For the SNLI (Bowman et al., 2015) dataset, the task is text entailment, which identifies the relationship (entailment, contradiction or neutral) between a premise sentence and a hypothesis sentence. Here K = 1, and there are exactly two sequences to match. The actual model structure is what we have described before. For the InsuranceQA (Feng et al., 2015) dataset, the task is an answer selection task which needs to select the correct answer for a question from a candidate pool. For the WikiQA (Yang et al., 2015) datasets, we need to rank the candidate answers according to a question. For both tasks, there are K candidate answers for each question. Let us use rk to represent the resulting vector produced by Eqn. 9 for the kth answer. In order to select one of the K answers, we first define R = [r1, r2, . . . , rK ]. We then compute the probability of the kth answer to be the correct one as follows: p(k|R) = softmax(wT tanh(WsR+ bs eK) + b eK), (10) where Ws Rlnl, w Rl, bs Rl, b R are parameters to be learned. For the machine comprehension task MovieQA, each question is related to Plot Synopses written by fans after watching the movie and each question has five candidate answers. So for each candidate answer there are three sequences to be matched: the plot P, the question Q and the answer Ak. For each k, we first match Q and P and refer to the matching result at position j as tqj , as generated by one of the comparison functions f . Similarly, we also match Ak with P and refer to the matching result at position j as tak,j . We then define tk,j = [ tqj tak,j ] , and rk = CNN([tk,1, . . . , tk,P ]). To select an answer from the K candidate answers, again we use Eqn. 10 to compute the probabilities. The implementation details of the modes are as follows. The word embeddings are initialized from GloVe (Pennington et al., 2014). During training, they are not updated. The word embeddings not found in GloVe are initialized with zero. The dimensionality l of the hidden layers is set to be 150. We use ADAMAX (Kingma & Ba, 2015) with the coefficients 1 = 0.9 and 2 = 0.999 to optimize the model. We do not use L2regularization. The main parameter we tuned is the dropout on the embedding layer. For WikiQA, which is a relatively small dataset, we also tune the learning rate and the batch size. For the others, we set the batch size to be 30 and the learning rate 0.002.",
      "exclude": false
    },
    {
      "heading": "3.2 BASELINES",
      "text": "Here, we will introduce the baselines for each dataset. We did not re-implement these models but simply took the reported performance for the purpose of comparison. SNLI: W-by-W Attention: The model by Rocktaschel et al. (2015), who first introduced attention mechanism into text entailment. match-LSTM: The model by Wang & Jiang (2016b), which concatenates the matched words as the inputs of an LSTM. LSTMN: Long short-term memorynetworks proposed by Cheng et al. (2016). Decomp Attention: Another compare-aggregate model proposed by Parikh et al. (2016). EBIM+TreeLSTM: The state-of-the-art model proposed by Chen et al. (2016) on the SNLI dataset. InsuranceQA: IR model: This model by Bendersky et al. (2010) learns the concept information to help rank the candidates. CNN with GESD: This model by Feng et al. (2015) uses Euclidean distance and dot product between sequence representations built through convolutional neural networks to select the answer. Attentive LSTM: Tan et al. (2016) used soft-attention mechanism to select the most important information from the candidates according to the representation of the questions. IARNN-Occam: This model by Wang et al. (2016) adds regularization on the attention weights. IARNN-Gate: This model by Wang et al. (2016) uses the representation of the question to build the GRU gates for each candidate answer. WikiQA: IARNN-Occam and IARNN-Gate as introduced before. CNN-Cnt: This model by Yang et al. (2015) combines sentence representations built by a convolutional neural network with logistic regression. ABCNN: This model is Attention-Based Convolutional Neural Network proposed by Yin et al. (2015). CubeCNN proposed by He & Lin (2016) builds a CNN on all pairs of word similarity. MovieQA: All the baselines we consider come from Tapaswi et al. (2016)s work: Cosine Word2Vec: A sliding window is used to select the answer according to the similarities computed through Word2Vec between the sentences in plot and the question/answer. Cosine TFIDF: This model is similar to the previous method but uses bag-of-word with tf-idf scores to compute similarity. SSCB TFIDF: Instead of using the sliding window method, a convolutional neural network is built on the sentence level similarities.",
      "exclude": false
    },
    {
      "heading": "3.3 ANALYSIS OF RESULTS",
      "text": "We use accuracy as the evaluation metric for the datasets MovieQA, InsuranceQA and SNLI, as there is only one correct answer or one label for each instance. For WikiQA, there may be multiple correct answers, so evaluation metrics we use are Mean Average Precision (MAP) and Mean Reciprocal Rank (MRR). We observe the following from the results. (1) Overall, we can find that our general compareaggregate structure achieves the best performance on MovieQA, InsuranceQA, WikiQA datasets and very competitive performance on the SNLI dataset. Especially for the InsuranceQA dataset, with any comparison function we use, our model can outperform all the previous models. (2) The comparison method SUBMULT+NN is the best in general. (3) Some simple comparison functions can achieve better performance than the neural networks or neural tensor network comparison functions. For example, the simplest comparison function EUCCOS achieves nearly the best performance in the MovieQA dataset, and the element-wise comparison functions, which do not need parameters can achieve the best performance on the WikiQA dataset. (4) We find the preprocessing layer and the attention layer for word selection to be important in the compare-aggregate structure through the experiments of removing these two layers separately. We also see that for sequence matching with big difference in length, such as the MovieQA and InsuranceQA tasks, the attention layer plays a more important role. For sequence matching with smaller difference in length, such as the WikiQA and SNLI tasks, the pre-processing layer plays a more important role. (5) For the MovieQA, InsuranceQA and WikiQA tasks, our preprocessing layer is order-insensitive so that it will not take the context information into consideration during the comparison, but our model can still outperform the previous work with order-sensitive preprocessing layer. With this finding, we believe the word-by-word comparison part plays a very important role in these tasks. We will further explore the preprocessing layer in the future.",
      "exclude": false
    },
    {
      "heading": "3.4 FURTHER ANALYSES",
      "text": "To further explain how our model works, we visualize the max values in each dimension of the convolutional layer. We use two examples shown in Table 1 from MovieQA and InsuranceQA datasets respectively. In the top of Figure 2, we can see that the plot words that also appear in either the question or the answer will draw more attention by the CNN. We hypothesize that if the nearby words in the plot can match both the words in question and the words in one answer, then this answer is more likely to be the correct one. Similarly, the bottom one of Figure 2 also shows that the CNN will focus more on the matched word representations. If the words in one answer continuously match the words in the question, this answer is more likely to be the correct one.",
      "exclude": false
    },
    {
      "heading": "4 RELATED WORK",
      "text": "We review related work in three types of general structures for matching sequences. Siamense network: These kinds of models use the same structure, such as RNN or CNN, to build the representations for the sequences separately and then use them for classification. Then cosine similarity (Feng et al., 2015; Yang et al., 2015), element-wise operation (Tai et al., 2015; Mou et al., 2016) or neural network-based combination Bowman et al. (2015) are used for sequence matching. Attentive network: Soft-attention mechanism (Bahdanau et al., 2014; Luong et al., 2015) has been widely used for sequence matching in machine comprehension (Hermann et al., 2015), text entailment (Rocktaschel et al., 2015) and question answering (Tan et al., 2016). Instead of using the final state of RNN to represent a sequence, these studies use weighted sum of all the states for the sequence representation. Compare-Aggregate network: This kind of framework is to perform the word level matching (Wang & Jiang, 2016a; Parikh et al., 2016; He & Lin, 2016; Trischler et al., 2016; Wan et al., 2016). Our work is under this framework. But our structure is different from previous models and our model can be applied on different tasks. Besides, we analyzed different word-level comparison functions separately.",
      "exclude": true
    },
    {
      "heading": "5 CONCLUSIONS",
      "text": "In this paper, we systematically analyzed the effectiveness of a compare-aggregate model on four different datasets representing different tasks. Moreover, we compared and tested different kinds of word-level comparison functions and found that some element-wise comparison functions can outperform the others. According to our experiment results, many different tasks can share the same compare-aggregate structure. In the future work, we would like to test its effectiveness on multi-task learning.",
      "exclude": true
    },
    {
      "heading": "6 ACKNOWLEDGMENTS",
      "text": "This research is supported by the National Research Foundation, Prime Ministers Office, Singapore under its International Research Centres in Singapore Funding Initiative.",
      "exclude": true
    }
  ],
  "fewShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": false,
        "confidence": 0.72,
        "primary_reason": "Solid empirical work with systematic comparison of matching functions across multiple tasks. Novel element-wise comparison functions (SUB, MULT) show practical value. Comprehensive evaluation on 4 datasets with strong results, though limited conceptual novelty and incremental over Parikh et al. (2016)."
      },
      "token": {
        "prompt_tokens": 4828,
        "completion_tokens": 101,
        "total_tokens": 4929
      },
      "time": "2026-02-08T22:07:18.714916+00:00"
    }
  ]
}