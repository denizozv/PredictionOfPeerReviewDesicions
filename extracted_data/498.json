{
  "id": "498",
  "title": "Dropout with Expectation-linear Regularization",
  "abstract": "Dropout, a simple and effective way to train deep neural networks, has led to a number of impressive empirical successes and spawned many recent theoretical investigations. However, the gap between dropout’s training and inference phases, introduced due to tractability considerations, has largely remained under-appreciated. In this work, we first formulate dropout as a tractable approximation of some latent variable model, leading to a clean view of parameter sharing and enabling further theoretical analysis. Then, we introduce (approximate) expectation-linear dropout neural networks, whose inference gap we are able to formally characterize. Algorithmically, we show that our proposed measure of the inference gap can be used to regularize the standard dropout training objective, resulting in an explicit control of the gap. Our method is as simple and efficient as standard dropout. We further prove the upper bounds on the loss in accuracy due to expectation-linearization, describe classes of input distributions that expectation-linearize easily. Experiments on three image classification benchmark datasets demonstrate that reducing the inference gap can indeed improve the performance consistently.",
  "accepted": true,
  "zeroShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": false,
        "confidence": 0.72,
        "primary_reason": "Novel theoretical framework for understanding dropout's inference gap with practical regularization method, though experimental improvements are modest and some theoretical assumptions are restrictive."
      },
      "token": {
        "prompt_tokens": 13439,
        "completion_tokens": 56,
        "total_tokens": 13495
      },
      "time": "2026-02-05T22:53:13.910389+00:00"
    },
    {
      "model": "gpt-5.2",
      "decision": {
        "rejection": true,
        "confidence": 0.78,
        "primary_reason": "Insufficient novelty/impact for a top-tier venue: the core idea is a regularizer to reduce the known dropout train-test (MC vs weight-scaling) mismatch, with modest empirical gains on small/dated benchmarks and limited experimental breadth; theory relies on strong/special assumptions and does not convincingly translate to modern architectures or settings."
      },
      "token": {
        "prompt_tokens": 11850,
        "completion_tokens": 86,
        "total_tokens": 11936
      },
      "time": "2026-02-09T21:23:57.484860+00:00"
    }
  ],
  "article": [
    {
      "heading": "1 INTRODUCTION",
      "text": "Deep neural networks (DNNs, e.g., LeCun et al., 2015; Schmidhuber, 2015), if trained properly, have been demonstrated to significantly improve the benchmark performances in a wide range of application domains. As neural networks go deeper and deeper, naturally, its model complexity also increases quickly, hence the pressing need to reduce overfitting in training DNNs. A number of techniques have emerged over the years to address this challenge, among which dropout (Hinton et al., 2012; Srivastava, 2013) has stood out for its simplicity and effectiveness. In a nutshell, dropout randomly drops neural units during training as a means to prevent feature co-adaptationa sign of overfitting (Hinton et al., 2012). Simple as it appears to be, dropout has led to several record-breaking performances (Hinton et al., 2012; Ma & Hovy, 2016), and thus spawned a lot of recent interests in analyzing and justifying dropout from the theoretical perspective, and also in further improving dropout from the algorithmic and practical perspective. In their pioneering work, Hinton et al. (2012) and Srivastava et al. (2014) interpreted dropout as an extreme form of model combination (aka. model ensemble) with extensive parameter/weight sharing, and they proposed to learn the combination through minimizing an appropriate expected loss. Interestingly, they also pointed out that for a single logistic neural unit, the output of dropout is in fact the geometric mean of the outputs of the model ensemble with shared parameters. Subsequently, many theoretical justifications of dropout have been explored, and we can only mention a few here due to space limits. Building on the weight sharing perspective, Baldi & Sadowski (2013; 2014) analyzed the ensemble averaging property of dropout in deep non-linear logistic networks, and supported the view that dropout is equivalent to applying stochastic gradient descent on some regularized loss function. Wager et al. (2013) treated dropout as an adaptive regularizer for generalized linear models (GLMs). Helmbold & Long (2016) discussed the differences between dropout and traditional weight decay regularization. In terms of statistical learning theory, Gao & Zhou (2014) studied the Rademacher complexity of different types of dropout, showing that dropout is able to reduce the Rademacher complexity polynomially for shallow neural networks (with one or no hidden layers) and exponentially for deep neural networks. This latter work (Gao & Zhou, 2014) formally demonstrated that dropout, due to its regularizing effect, contributes to reducing the inherent model complexity, in particular the variance component in the generalization error. Seen as a model combination technique, it is intuitive that dropout contributes to reducing the variance of the model performance. Surprisingly, dropout has also been shown to play some role in reducing the model bias. For instance, Jain et al. (2015) studied the ability of dropout training to escape local minima, hence leading to reduced model bias. Other studies (Chen et al., 2014; Helmbold & Long, 2014; Wager et al., 2014) focus on the effect of the dropout noise on models with shallow architectures. We noted in passing that there are also some work (Kingma et al., 2015; Gal & Ghahramani, 2015; 2016) trying to understand dropout from the Bayesian perspective. In this work, we first formulate dropout as a tractable approximation of a latent variable model, and give a clean view of weight sharing (3). Then, we focus on an inference gap in dropout that has somehow gotten under-appreciated: In the inference phase, for computational tractability considerations, the model ensemble generated by dropout is approximated by a single model with scaled weights, resulting in a gap between training and inference, and rendering the many previous theoretical findings inapplicable. In general, this inference gap can be very large and no attempt (to our best knowledge) has been made to control it. We make three contributions in bridging this gap: Theoretically, we introduce expectation-linear dropout neural networks, through which we are able to explicitly quantify the inference gap (4). In particular, our theoretical results explain why the max-norm constraint on the network weights, a standard practice in training DNNs, can lead to a small inference gap hence potentially improve performance. Algorithmically, we propose to add a sampled version of the inference gap to regularize the standard dropout training objective (expectationlinearization), hence allowing explicit control of the inference gap, and analyze the interaction between expectation-linearization and the model accuracy (5). Experimentally, through three benchmark datasets we show that our regularized dropout is not only as simple and efficient as standard dropout but also consistently leads to improved performance (6).",
      "exclude": true
    },
    {
      "heading": "2 DROPOUT NEURAL NETWORKS",
      "text": "In this section we set up the notations, review the dropout neural network model, and discuss the inference gap in standard dropout training that we will attempt to study in the rest of the paper.",
      "exclude": false
    },
    {
      "heading": "2.1 DNNS AND NOTATIONS",
      "text": "Throughout we use uppercase letters for random variables (and occasionally for matrices as well), and lowercase letters for realizations of the corresponding random variables. Let X X be the input of the neural network, Y Y be the desired output, and D = (x1, y1), . . . , (xN , yN ) be our training sample, where xi, i = 1, . . . , N, (resp. yi) are usually i.i.d. samples of X (resp. Y ). Let M denote a deep neural network with L hidden layers, indexed by l 1, . . . , L. Let h(l) denote the output vector from layer l. As usual, h(0) = x is the input, and h(L) is the output of the neural network. Denote = l : l = 1, . . . , L as the set of parameters in the network M, where l assembles the parameters in layer l. With dropout, we need to introduce a set of dropout random variables S = (l) : l = 1, . . . , L, where (l) is the dropout random variable for layer l. Then the deep neural network M can be described as: h(l) = fl(h (l1) (l); l), l = 1, . . . , L, (1) where is the element-wise product and fl is the transformation function of layer l. For example, if layer l is a fully connected layer with weight matrix W , bias vector b, and sigmoid activation function (x) = 11+exp(x) , then fl(x) = (Wx+ b)). We will also use h (l)(x, s; ) to denote the output of layer l with input x and dropout value s, under parameter . In the simplest form of dropout, which is also called standard dropout, (l) is a vector of independent Bernoulli random variables, each of which has probability pl of being 1 and 1 pl of being 0. This corresponds to dropping each of the weights independently with probability pl.",
      "exclude": false
    },
    {
      "heading": "2.2 DROPOUT TRAINING",
      "text": "The standard dropout neural networks can be trained using stochastic gradient decent (SGD), with a sub-network sampled by dropping neural units for each training instance in a mini-batch. Forward and backward pass for that training instance are done only on the sampled sub-network. Intuitively, dropout aims at, simultaneously and jointly, training an ensemble of exponentially many neural networks (one for each configuration of dropped units) while sharing the same weights/parameters. The goal of the stochastic training procedure of dropout can be understood as minimizing an expected loss function, after marginalizing out the dropout variables (Srivastava, 2013; Wang & Manning, 2013). In the context of maximal likelihood estimation, dropout training can be formulated as: = argmin ESD [l(D,SD; )] = argmin ESD [ N i=1 log p(yi|xi, Si; ) ] , (2) where recall that D is the training sample, SD = S1, . . . , SN is the dropout variable (one for each training instance), and l(D,SD; ) is the (conditional) log-likelihood function defined by the conditional distribution p(y|x, s; ) of output y given input x, under parameter and dropout variable s. Throughout we use the notation EZ to denote the conditional expectation where all random variables except Z are conditioned on. Dropout has also been shown to work well with regularization, such as L2 weight decay (Tikhonov, 1943), Lasso (Tibshirani, 1996), KL-sparsity(Bradley & Bagnell, 2008; Hinton, 2010), and max-norm regularization (Srebro et al., 2004), among which the max-norm regularization that constrains the norm of the incoming weight matrix to be bounded by some constant was found to be especially useful for dropout (Srivastava, 2013; Srivastava et al., 2014).",
      "exclude": false
    },
    {
      "heading": "2.3 DROPOUT INFERENCE AND GAP",
      "text": "As mentioned before, dropout is effectively training an ensemble of neural networks with weight sharing. Consequently, at test time, the output of each network in the ensemble should be averaged to deliver the final prediction. This averaging over exponentially many sub-networks is, however, intractable, and standard dropout typically implements an approximation by introducing a deterministic scaling factor for each layer to replace the random dropout variable: ES [H (L)(x, S; )] ? h(L)(x,E[S]; ), (3) where the right-hand side is the output of a single deterministic neural network whose weights are scaled to match the expected number of active hidden units on the left-hand side. Importantly, the right-hand side can be easily computed since it only involves a single deterministic network. Bulo et al. (2016) combined dropout with knowledge distillation methods (Hinton et al., 2015) to better approximate the averaging processing of the left-hand side. However, the quality of the approximation in (3) is largely unknown, and to our best knowledge, no attempt has been made to explicitly control this inference gap. The main goal of this work is to explicitly quantify, algorithmically control, and experimentally demonstrate the inference gap in (3), in the hope of improving the generalization performance of DNNs eventually. To this end, in the next section we first present a latent variable model interpretation of dropout, which will greatly facilitate our later theoretical analysis.",
      "exclude": false
    },
    {
      "heading": "3 DROPOUT AS LATENT VARIABLE MODELS",
      "text": "With the end goal of studying the inference gap in (3) in mind, in this section, we first formulate dropout neural networks as a latent variable model (LVM) in 3.1. Then, we point out the relation between the training procedure of LVM and that of standard dropout in 3.2. The advantage of formulating dropout as a LVM is that we need only deal with a single model (with latent structure), instead of an ensemble of exponentially many different models (with weight sharing). This much simplified view of dropout enables us to understand and analyze the model parameter in a much more straightforward and intuitive way.",
      "exclude": false
    },
    {
      "heading": "3.1 AN LVM FORMULATION OF DROPOUT",
      "text": "A latent variable model consists of two types of variables: the observed variables that represent the empirical (observed) data and the latent variables that characterize the hidden (unobserved) structure. To formulate dropout as a latent variable model, the input x and output y are regarded as observed variables, while the dropout variable s, representing the sub-network structure, is hidden. Then, upon fixing the input space X , the output space Y , and the latent space S for dropout variables, the conditional probability of y given x under parameter can be written as p(y|x; ) = S p(y|x, s; )p(s)d(s), (4) where p(y|x, s; ) is the conditional distribution modeled by the neutral network with configuration s (same as in Eq. (2)), p(s) is the distribution of dropout variable S (e.g. Bernoulli), here assumed to be independent of the input x, and (s) is the base measure on the space S.",
      "exclude": false
    },
    {
      "heading": "3.2 LVM DROPOUT TRAINING VS. STANDARD DROPOUT TRAINING",
      "text": "Building on the above latent variable model formulation (4) of dropout, we are now ready to point out a simple relation between the training procedure of LVM and that of standard dropout. Given an i.i.d. training sample D, the maximum likelihood estimate for the LVM formulation of dropout in (4) is equivalent to minimizing the following negative log-likelihood function: = argmin l(D; ) = argmin N i=1 log p(yi|xi; ), (5) where p(y|x; ) is given in Eq. (4). Recall the dropout training objective ESD [l(D,SD; )] in Eq. (2). We have the following theorem as a simple consequence of Jensens inequality (details in Appendix A): Theorem 1. The expected loss function of standard dropout (Eq. (2)) is an upper bound of the negative log-likelihood of LVM dropout (Eq. (5)): l(D; ) ESD [l(D,SD; )]. (6) Theorem 1, in a rigorous sense, justifies dropout training as a convenient and tractable approximation of the LVM formulation in (4). Indeed, since directly minimizing the marginalized negative loglikelihood in (5) may not be easy, a standard practice is to replace the marginalized (conditional) likelihood p(y|x; ) in (4) with its empirical Monte carlo average through drawing samples from the dropout variable S. The dropout training objective in (2) corresponds exactly to this Monte carlo approximation when a single sample Si is drawn for each training instance (xi, yi). Importantly, we note that the above LVM formulation involves only a single network parameter , which largely simplifies the picture and facilitates our subsequent analysis.",
      "exclude": false
    },
    {
      "heading": "4 EXPECTATION-LINEAR DROPOUT NEURAL NETWORKS",
      "text": "Building on the latent variable model formulation in 3, we introduce in this section the notion of expectation-linearity that essentially measures the inference gap in (3). We then characterize a general class of neural networks that exhibit expectation-linearity, either exactly or approximately over a distribution p(x) on the input space. We start with defining expectation-linearity in the simplest single-layer neural network, then we extend the notion into general deep networks in a natural way. Definition 1 (Expectation-linear Layer). A network layer h = f(x ; ) is expectation-linear with respect to a set X X , if for all x X we haveE[f(x ; )] f(x E[]; ) 2 = 0. (7) In this case we say that X is expectation-linearizable, and is expectation-linearizing w.r.t X . Obviously, the condition in (7) will guarantee no gap in the dropout inference approximation (3)an admittedly strong condition that we will relax below. Clearly, if f is an affine function, then we can choose X = X and expectation-linearity is trivial. Note that expectation-linearity depends on the network parameter and the dropout distribution . Expectation-linearity, as defined in (7), is overly strong: under standard regularity conditions, essentially the transformation function f has to be affine over the set X , ruling out for instance the popular sigmoid or tanh activation functions. Moreover, in practice, downstream use of DNNs are usually robust to small errors resulting from approximate expectation-linearity (hence the empirical success of dropout), so it makes sense to define an inexact extension. We note also that the definition in (7) is uniform over the set X , while in a statistical setting it is perhaps more meaningful to have expectation-linearity on average, since inputs from lower density regions are not going to play a significant role anyway. Taking into account the aforementioned motivations, we arrive at the following inexact extension: Definition 2 (Approximately Expectation-linear Layer). A network layer h = f(x ; ) is -approximately expectation-linear with respect to a distribution p(x) over X if EX [E[f(X ; )|X] f(X E[]; )2] 1, the growth of becomes exponential. Thus, it is essential to keep B < 1 to achieve good approximation, particularly for deep neural networks.",
      "exclude": false
    },
    {
      "heading": "5 EXPECTATION-LINEAR REGULARIZED DROPOUT",
      "text": "In the previous section we have managed to bound the approximate expectation-linearity, hence the inference gap in (3), of dropout neural networks. In this section, we first prove a uniform deviation bound of the sampled approximate expectation-linearity measure from its mean, which motivates adding the sampled (hence computable) expectation-linearity measure as a regularization scheme to standard dropout, with the goal of explicitly controlling the inference gap of the learned parameter, hence potentially improving the performance. Then we give the upper bounds on the loss in accuracy due to expectation-linearization, and describe classes of distributions that expectation-linearize easily.",
      "exclude": false
    },
    {
      "heading": "5.1 A UNIFORM DEVIATION BOUND FOR THE SAMPLED EXPECTATION-LINEAR MEASURE",
      "text": "We now show that an expectation-linear network can be found by expectation-linearizing the network on the training sample. To this end, we prove a uniform deviation bound between the empirical expectation-linearization measure using i.i.d. samples (Eq. (12)) and its mean (Eq. (13)). Theorem 4. Let H = h(L)(x, s; ) : denote a space of L-layer dropout neural networks indexed with , where h(L) : X S R and is the space that lives in. Suppose that the neural networks inH satisfy the constraints: 1) x X , x2 ; 2) l 1, . . . , L,E((l)) and flop B; 3) h(L) . Denote empirical expectation-linearization measure and its mean as: = 1 n n i=1 ESi[H(L)(Xi, Si; )] h(L)(Xi,E[Si]; )2, (12) = EX [ES[H(L)(X,S; )] h(L)(X,E[S]; )2]. (13) Then, with probability at least 1 , we have sup | | < 2B L(L/2 + 1) n + log(1/) n . (14) From Theorem 4 (proof in Appendix C.1) we observe that the deviation bound decreases exponentially with the number of layers L when the operator norm of the derivative of each layers transformation function (B) is less than 1 (and the contrary if B 1). Importantly, the square root dependence on the number of samples (n) is standard and cannot be improved without significantly stronger assumptions. It should be noted that Theorem 4 per se does not imply anything between expectation-linearization and the model accuracy (i.e. how well the expectation-linearized neural network actually achieves on modeling the data). Formally studying this relation is provided in 5.3. In addition, we provide some experimental evidences in 6 on how improved approximate expectation-linearity (equivalently smaller inference gap) does lead to better empirical performances.",
      "exclude": false
    },
    {
      "heading": "5.2 EXPECTATION-LINEARIZATION AS REGULARIZATION",
      "text": "The uniform deviation bound in Theorem 4 motivates the possibility of obtaining an approximately expectation-linear dropout neural networks through adding the empirical measure (12) as a regularization scheme to the standard dropout training objective, as follows: loss(D; ) = l(D; ) + V (D; ), (15) where l(D; ) is the negative log-likelihood defined in Eq. (5), > 0 is a regularization constant, and V (D; ) measures the level of approximate expectation-linearity: V (D; ) = 1 N N i=1 ESi[H(L)(xi, Si; )] h(L)(xi,E[Si]; )22. (16) To solve (15), we can minimize loss(D; ) via stochastic gradient descent as in standard dropout, and approximate V (D; ) using Monte carlo: V (D; ) 1 N N i=1 h(L)(xi, si; ) h(L)(xi,E[Si]; )22, (17) where si is the same dropout sample as in l(D; ) for each training instance in a mini-batch. Thus, the only additional computational cost comes from the deterministic term h(L)(xi,E[Si]; ). Overall, our regularized dropout (15), in its Monte carlo approximate form, is as simple and efficient as the standard dropout.",
      "exclude": false
    },
    {
      "heading": "5.3 ON THE ACCURACY OF EXPECTATION-LINEARIZED MODELS",
      "text": "So far our discussion has concentrated on the problem of finding expectation-linear neural network models, without any concerns on how well they actually perform at modeling the data. In this section, we characterize the trade-off between maximizing data likelihood and satisfying an expectationlinearization constraint. To achieve the characterization, we measure the likelihood gap between the classical maximum likelihood estimator (MLE) and the MLE subject to a expectation-linearization constraint. Formally, given training data D = (x1, y1), . . . , (xn, yn), we define = argmin l(D; ) (18) = argmin ,V (D;) l(D; ) (19) where l(D; ) is the negative log-likelihood defined in Eq. (5), and V (D; ) is the level of approximate expectation-linearity in Eq. (16). We would like to control the loss of model accuracy by obtaining a bound on the likelihood gap defined as: l(, ) = 1 n (l(D; ) l(D; )) (20) In the following, we focus on neural networks with softmax output layer for classification tasks. p(y|x, s; ) = h(L)y (x, s; ) = fL(h(L1)(x, s); ) = e T y h (L1)(x,s) yY e T yh (L1)(x,s) (21) where = 1, . . . , L1, , Y = 1, . . . , k and = y : y Y. We claim: Theorem 5. Given an L-layer neural network h(L)(x, s; ) with softmax output layer in (21), where parameter , dropout variable s S, input x X and target y Y . Suppose that for every x and s, p(y|x, s; ) makes a unique best predictionthat is, for each x X , s S, there exists a unique y Y such that y 6= y, Ty h(L1)(x, s) 0. Then l(, ) c12 ( 2 4 )2 ec2/4 (22) where c1 and c2 are distribution-dependent constants. From Theorem 5 (proof in Appendix C.2) we observe that, at one extreme, distributions closed to deterministic can be expectation-linearized with little loss of likelihood. What about the other extreme distributions as close to uniform distribution as possible? With suitable assumptions about the form of p(y|x, s; ) and p(y|x; ), we can achieve an accuracy loss bound for distributions that are close to uniform: Theorem 6. Suppose that x, s, h(L1)(x, s; ) . Additionally, for each (xi, yi) D, s S , log 1k log p(yi|xi, s; ) 1 k yY log p(y|xi, s; ). Then asymptotically as n: l(, ) ( 1 42 ) E [KL (p(|X; )Unif(Y))] (23) Theorem 6 (proof in Appendix C.3) indicates that uniform distributions are also an easy class for expectation-linearization. The next question is whether there exist any classes of conditional distributions p(y|x) for which all distributions are provably hard to expectation-linearize. It remains an open problem and might be an interesting direction for future work.",
      "exclude": false
    },
    {
      "heading": "6 EXPERIMENTS",
      "text": "In this section, we evaluate the empirical performance of the proposed regularized dropout in (15) on a variety of network architectures for the classification task on three benchmark datasetsMNIST, CIFAR-10 and CIFAR-100. We applied the same data preprocessing procedure as in Srivastava et al. (2014). To make a thorough comparison and provide experimental evidence on how the expectationlinearization interacts with the predictive power of the learned model, we perform experiments of Monte Carlo (MC) dropout, which approximately computes the final prediction (left-hand side of (3)) via Monte Carlo sampling, w/o the proposed regularizer. In the case of MC dropout, we average m = 100 predictions using randomly sampled configurations. In addition, the network architectures and hyper-parameters for each experiment setup are the same as those in Srivastava et al. (2014), unless we explicitly claim to use different ones. Following previous works, for each data set We held out 10,000 random training images for validation to tune the hyper-parameters, including in Eq. (15). When the hyper-parameters are fixed, we train the final models with all the training data, including the validation data. A more detailed description of the conducted experiments can be provided in Appendix D. For each experiment, we report the mean test errors with corresponding standard deviations over 5 repetitions.",
      "exclude": false
    },
    {
      "heading": "6.1 MNIST",
      "text": "The MNIST dataset (LeCun et al., 1998) consists of 70,000 handwritten digit images of size 2828, where 60,000 images are used for training and the rest for testing. This task is to classify the images into 10 digit classes. For the purpose of comparison, we train 6 neural networks with different architectures. The experimental results are shown in Table 1.",
      "exclude": false
    },
    {
      "heading": "6.2 CIFAR-10 AND CIFAR-100",
      "text": "The CIFAR-10 and CIFAR-100 datasets (Krizhevsky, 2009) consist of 60,000 color images of size 32 32, drawn from 10 and 100 categories, respectively. 50,000 images are used for training and the rest for testing. The neural network architecture we used for these two datasets has 3 convolutional layers, followed by two fully-connected (dense) hidden layers (again, same as that in Srivastava et al. (2014)). The experimental results are recorded in Table 1, too. From Table 1 we can see that on MNIST data, dropout network training with expectation-linearization outperforms standard dropout on all 6 neural architectures. On CIFAR data, expectation-linearization reduces error rate from 12.82% to 12.20% for CIFAR-10, achieving 0.62% improvement. For CIFAR-100, the improvement in terms of error rate is 0.97% with reduction from 37.22% to 36.25%. From the results we see that with or without expectation-linearization, the MC dropout networks achieve similar results. It illustrates that by achieving expectation-linear neural networks, the predictive power of the learned models has not degraded significantly. Moreover, it is interesting to see that with the regularization, on MNIST dataset, standard dropout networks achieve even better accuracy than MC dropout. It may be because that with expectation-linearization, standard dropout inference achieves better approximation of the final prediction than MC dropout with (only) 100 samples. On CIFAR datasets, MC dropout networks achieve better accuracy than the ones with the regularization. But, obviously, MC dropout requires much more inference time than standard dropout (MC dropout with m samples requires about m times the inference time of standard dropout). 6.3 EFFECT OF REGULARIZATION CONSTANT In this section, we explore the effect of varying the hyper-parameter for the expectation-linearization rate . We train the network architectures in Table 1 with the value ranging from 0.1 to 10.0. Figure 1 shows the test errors obtained as a function of on three datasets. In addition, Figure 1, middle and right panels, also measures the empirical expectation-linearization risk of Eq. (12) with varying on CIFAR-10 and CIFAR-100, where is computed using Monte carlo with 100 independent samples. From Figure 1 we can see that when increases, better expectation-linearity is achieved (i.e. decreases). The model accuracy, however, has not kept growing with increasing , showing that in practice considerations on the trade-off between model expectation-linearity and accuracy are needed.",
      "exclude": false
    },
    {
      "heading": "6.4 COMPARISON WITH DROPOUT DISTILLATION",
      "text": "To make a thorough empirical comparison with the recently proposed Dropout Distillation method (Bulo et al., 2016), we also evaluate our regularization method on CIFAR-10 and CIFAR-100 datasets with the All Convolutional Network (Springenberg et al., 2014) (AllConv). To facilitate comparison, we adopt the originally reported hyper-parameters and the same setup for training. Table 2 gives the results comparison the classification error percentages on test data under AllConv using standard dropout, Monte Carlo dropout, standard dropout with our proposed expectationlinearization, and recently proposed dropout distillation on CIFAR-10 and CIFAR-100 1. According to Table 2, our proposed expectation-linear regularization method achieves comparable performance to dropout distillation.",
      "exclude": false
    },
    {
      "heading": "7 CONCLUSIONS",
      "text": "In this work, we attempted to establish a theoretical basis for the understanding of dropout, motivated by controlling the gap between dropouts training and inference phases. Through formulating dropout as a latent variable model and introducing the notion of (approximate) expectation-linearity, we have formally studied the inference gap of dropout, and introduced an empirical measure as a regularization scheme to explicitly control the gap. Experiments on three benchmark datasets demonstrate that reducing the inference gap can indeed improve the end performance. In the future, we intend to formally relate the inference gap to the generalization error of the underlying network, hence providing further justification of regularized dropout.",
      "exclude": true
    },
    {
      "heading": "ACKNOWLEDGEMENTS",
      "text": "This research was supported in part by DARPA grant FA8750-12-2-0342 funded under the DEFT program. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of DARPA.",
      "exclude": false
    },
    {
      "heading": "APPENDIX: DROPOUT WITH EXPECTATION-LINEAR REGULARIZATION",
      "text": "",
      "exclude": true
    },
    {
      "heading": "A LVM DROPOUT TRAINING VS. STANDARD DROPOUT TRAINING",
      "text": "",
      "exclude": false
    },
    {
      "heading": "Proof of Theorem 1",
      "text": "",
      "exclude": false
    },
    {
      "heading": "Proof.",
      "text": "ESD [l(D,SD; )] = S N i=1 p(si) ( N i=1 log p(yi|xi, si; ) ) d(s1) . . . d(sN ) = N i=1 S p(si) log p(yi|xi, si; )d(si) Because log() is a concave function, from Jensens Inequality, S p(s) log p(y|x, s; )d(s) log S p(s)p(y|x, s; )d(s) Thus ESD [l(D,SD; )] N i=1 log S p(si)p(yi|xi, si; )d(si) = l(D; ).",
      "exclude": false
    },
    {
      "heading": "B EXPECTATION-LINEAR DROPOUT NEURAL NETWORKS",
      "text": "",
      "exclude": false
    },
    {
      "heading": "B.1 PROOF OF THEOREM 2",
      "text": "Proof. Let = E[], and A = x : E[f(x ; )] f(x ; )2 = 0 Let X = argmin xA sup S X x 2, and X = X X. Then, X = X +X In the following, we omit the parameter for convenience. Moreover, we denote E [ f(X ; ) ] = E [ f(X ; )|X ] From Taylor Series, there exit some X , X X satisfy that f(X ) = f(X ) + f (X )(X ) f(X ) = f(X ) + f (X )(X ) where we denote f (x) = (xf(x))T . Then, E[f(X ) f(X )] = E[f(X +X ) f(X +X )] = E[f(X ) f(X ) + f (X )(X ) f (X )(X )] = E[f(X ) f(X )] + E[f (X )(X ) f (X )(X )] Since X A, we have E[f(X ) f(X )] = 0. Then, E[f(X ) f(X )] = E[f (X )(X ) f (X )(X )] = E[(f (X ) f (X ))(X )] + E[f (X )(X X )] = E[(f (X ) f (X ))(X )] Then, E[f(X )] f(X )2 = E[(f (X ) f (X ))(X )]2 Since X 2 sup S X 2 = inf xA sup S X x 2, and from Jensens inequality and property of operator norm, E[(f (X ) f (X ))(X )]2 E [ f (X ) f (X )opX 2 ] 2BE [ X 2 ] 2B inf xA sup S X x 2 Finally we have, EX [ E[(f (X ) f (X ))(X )]2 ] 2BE [ inf xA sup S X x 2 ] 2BC",
      "exclude": false
    },
    {
      "heading": "B.2 PROOF OF THEOREM 3",
      "text": "Proof. Induction on the number of the layers L. As before, we omit the parameter . Initial step: when L = 1, the statement is obviously true. Induction on L: Suppose that the statement is true for neural networks with L layers. Now we prove the case L+ 1. From the inductive assumption, we have, EX [ESL[H(L)(X,SL)] h(L)(X,E[SL])2] L (1) where SL = (1), . . . ,(L) is the dropout random variables for the first L layers, and L = (B) L1 + ( +B) ( 1 (B)L1 1B ) In addition, the L+ 1 layer is -approximately expectation-linear, we have: EH(L) [E(L+1)[fL+1(H(L) (L+1))] fL+1(H(L) (L+1))2] (2) Let E[(l)] = (l),l 1, . . . , L + 1, and let H(l) and h(l) be short for H(l)(X,Sl) and h(l)(X,E(Sl)), respectively, when there is no ambiguity. Moreover, we denote ES [ H(L)(X,S; ) ] = ES [ H(L)(X,S; ) X] for convenience. Then, EX [ESL+1[H(L+1)] h(L+1)2] = EX [ESL[E(L+1)[fL+1(H(L) (L+1))] fL+1(h(L) (L+1))] +ESL [ fL+1(H (L) (L+1)) ] fL+1(h(L) (L+1)) 2 ] EX [ESL[E(L+1)[fL+1(H(L) (L+1))] fL+1(h(L) (L+1))] 2 ] +EX [ESL[fL+1(H(L) (L+1))] fL+1(h(L) (L+1)) 2 ] From Eq. 2 and Jensens inequality, we have EX [ESL[E(L+1)[fL+1(H(L) (L+1))] fL+1(h(L) (L+1))] 2 ] EH(L) [E(L+1)[fL+1(H(L) (L+1))] fL+1(h(L) (L+1)) 2 ] (3) and EX [ESL[fL+1(H(L) (L+1))] fL+1(h(L) (L+1)) 2 ] = EX [ESL[fL+1(H(L) (L+1))] fL+1(ESL[H(L)] (L+1)) +fL+1(ESL [ H(L) ] (L+1)) fL+1(h(L) (L+1)) 2 ] EX [ESL[fL+1(H(L) (L+1))] fL+1(ESL[H(L)] (L+1)) 2 ] +EX [fL+1(ESL[H(L)] (L+1)) fL+1(h(L) (L+1)) 2 ] (4) Using Jensens inequality, property of operator norm and E [ Var[H(l)|X] ] 2, we have EX [ESL[fL+1(H(L) (L+1))] fL+1(ESL[H(L)] (L+1)) 2 ] EH(L) [fL+1(H(L) (L+1)) fL+1(ESL[H(L)] (L+1)) 2 ] BEH(L) [H(L) ESL[H(L)]2] B ( EH(L) [H(L) ESL[H(L)]22]) 12 B (5) From Eq. 1 EX [fL+1(ESL[H(L)] (L+1)) fL+1(h(L) (L+1)) 2 ] = BEX [ESL[H(L)] h(L)2] BL (6) Finally, to sum up with Eq. 3, Eq. 4, , Eq. 5, , Eq. 6, we have EX [ESL+1[H(L+1)] h(L+1)2] +B +BL = (B)L + ( +B) ( 1(B)L 1B ) = L+1",
      "exclude": false
    },
    {
      "heading": "C EXPECTATION-LINEARIZATION",
      "text": "",
      "exclude": false
    },
    {
      "heading": "C.1 PROOF OF THEOREM 4: UNIFORM DEVIATION BOUND",
      "text": "Before proving Theorem 4, we first define the notations. Let Xn = X1, . . . , Xn be a set of n samples of input X . For a function space F : X R, we use Radn(F , Xn) to denote the empirical Rademacher complexity of F , Radn(F , Xn) = E [ sup fF ( 1 n n i=1 if(Xi) )] and the Rademacher complexity is defined as Radn(F) = EXn [ Radn(F , Xn) ] In addition, we import the definition of dropout Rademacher complexity from Gao & Zhou (2014): Rn(H, Xn, Sn) = E [ sup hH ( 1 n n i=1 ih(Xi, Si) )] Rn(H) = EXn,Sn [ Radn(H, Xn, Sn) ] where H : X S R is a function space defined on input space X and dropout variable space S. Rn(H, Xn, Sn) and Rn(H) are the empirical dropout Rademacher complexity and dropout Rademacher complexity, respectively. We further denoteRn(H, Xn) = ESn [ Radn(H, Xn, Sn) ] . Now, we define the following function spaces: F = f(x; ) : f(x; ) = ES [ H(L)(x, S; ) ] , G = g(x; ) : g(x; ) = h(L)(x,E[S]; ), H = h(x, s; ) : h(x, s; ) = h(L)(x, s; ), Then, the function space of v(x) = f(x) g(x) is V = f(x) g(x) : f F , g G. Lemma 7. Radn(F , Xn) Rn(H, Xn) Proof. Rn(H, Xn) = ESn [ Radn(H, Xn, Sn) ] = ESn [ E [ sup hH ( 1 n n i=1 ih(Xi, Si) )]] = E [ ESn [ sup hH ( 1 n n i=1 ih(Xi, Si) )]] E [ sup hH ESn [( 1 n n i=1 ih(Xi, Si) )]] = E [ sup hH ( 1 n n i=1 iESi [ h(Xi, Si) ])] = E [ sup hH ( 1 n n i=1 iESi [ H(L)(Xi, Si; ) ])] = Radn(F , Xn) From Lemma 7, we have Radn(F) Rn(H). Lemma 8. Rn(H) B LL/2 n Radn(G) B L n Proof. See Theorem 4 in Gao & Zhou (2014). Now, we can prove Theorem 4.",
      "exclude": false
    },
    {
      "heading": "Proof of Theorem 4",
      "text": "Proof. From Rademacher-based uniform bounds theorem, with probability 1 , sup vV | | < 2Radn(V) + log(1/) n Since V = F G, we have Radn(V) = Radn(F G) Radn(F) +Radn(G) BL(L/2 + 1) n Then, finally, we have that with probability 1 , sup | | < 2B L(L/2 + 1) n + log(1/) n",
      "exclude": false
    },
    {
      "heading": "C.2 PROOF OF THEOREM 5: NON-UNIFORM BOUND OF MODEL ACCURACY",
      "text": "For convenience, we denote = 1, . . . , L1. Then = , , and MLE = , Lemma 9. fL(; )T op 22 (7) Proof. denote A = fL(; )T = [ py(y )T ] k y=1 where py = p(y|x, s; ), = E [Y ] = k y=1 pyy . For each v such that v2 = 1, Av22 = yY ( py (y )T v )2 yY py (y ) 22v22 = yY py (y ) 22 yY pyy 22 yY 2py ( 22 + yY pyy22 ) = 4 yY pyy22 422 So we have Aop 22. Lemma 10. If parameter = , satisfies that 2 4 , then V (D; ) , where V (D; ) is defined in Eq. (16). Proof. Let SL = (1), . . . ,(L), and let H(l) and h(l) be short for H(l)(X,Sl; ) and h(l)(X,E(Sl); ), respectively. From lemma 9, we have fL(x; ) fL(y; )2 22x y2. Then,ESL [HL] hL2 = ESL1 [fL(H(L1); )] fL(h(L1); )2 ESL1 fL(H(L1); ) fL(h(L1); )2 22 H(L1) h(L1) 2 42 Lemma 10 says that we can get satisfying the expectation-linearization constrain by explicitly scaling down while keeping . In order to prove Theorem 5, we make the following assumptions: The dimension of h(L1) is d, i.e. h(L1) Rd. Since y Y, p(y|x; ) > 0, we assume p(y|x; ) 1/b, where b |Y| = k. As in the body text, let p(y|x, s; ) be nonuniform, and in particular let Tyh (L1)(x, s; ) Ty h(L1)(x, s; ) > c2,y 6= y. For convenience, we denote Th(L1)(x, s;) = Tuy(x, s;), where uTy (x, s;) = (v T 0 , . . . , v T k ) and vi = h(L1)(x, s;) if i = y 0 otherwise To prove Theorem 5, we first prove the following lemmas. Lemma 11. If p(y|x; ) 1/b, then [0, 1], for parameter = , , we have p(y|x; ) 1 b Proof. We define f() = (y|x, s; ) = e Ty h (L1)(x,s;) yY e T yh (L1)(x,s;) = ( e T y h (L1)(x,s;) ) yY ( e T yh (L1)(x,s;) ) Since Y = 1, . . . , k, for fixed x X , s S, log f() is a concave function w.r.t . Since b k, we have log f() (1 ) log f(0) + log f(1) log b So we have x, s, p(y|x, s; ) 1/b. Then p(y|x; ) = ES [ p(y|x, S; ) ] 1 b Lemma 12. if y is not the majority class, i.e. y 6= y, then for parameter = , p(y|x, s, ) ec2 Proof. p(y|x, s, ) = e Tuy yY e Tuy e Tuy e Tuy ec2 Lemma 13. For a fixed x and s, the absolute value of the entry of the vector under the parameter = , : |p(y|x, s; )(uy EY [uY ])|i (k 1)ec2 Proof. Suppose y is the majority class of p(y|x, s; ). Then, uy Ey[uY ] = (vy)ky=1 where vy = (1 p(y|x, s; )h(L1) if y = y p(y|x, s; )h(L1) otherwise From Lemma 12, we have |p(y|x, s; )(uy EY [uY ])|i |(uy EY [uY ])|i (k 1)ec2 Now, we suppose y is not the majority class of p(y|x, s; ). Then, |p(y|x, s; )(uy EY [uY ])|i p(y|x, s; ) ec2 Overall, the lemma follows. Lemma 14. We denote the matrix A = ES [ p(y|x,s;) p(y|x;) (uy EY [uY ])(uy EY [uY ]) T ] ES [ p(y|x,s;) p(y|x;) (uy EY [uY ]) ] ES [ p(y|x,s;) p(y|x;) (uy EY [uY ]) ]T Then the absolute value of the entry of A under the parameter = , : |Aij | 2b(k 1)2ec2 Proof. From Lemma 11, we have p(y|x; ) 1/b. Additionally, the absolute value of the entry of uy EY [uY ] is bounded by . We have for each iES [ p(y|x, s; ) p(y|x; ) (uy EY [uY ]) ] i ES [ p(y|x, s; ) p(y|x; ) ] = Then from Lemma 13 |Aij | 2b(k 1)2ec2 Lemma 15. We denote the matrix B = ES [ p(y|x, s; ) p(y|x; ) ( EY [ uY u T Y ] EY [uY ]EY [uY ]T )] Then the absolute value of the entry of B under the parameter = , : |Bij | 2(k 1)2ec2 Proof. We only need to prove that for fixed x and s, for each i, j:EY [uY uTY ] EY [uY ]EY [uY ]T ij 2(k 1)2ec2 Since EY [uY uTY ] EY [uY ]EY [uY ]T ij = |CovY [(uY )i, (uY )j ]| 2 k y=1 p(y|x, s; ) p(y|x, s; )2 Suppose y is the majority class. Then from Lemma 12, p(y|x, s; ) p(y|x, s; )2 1 p(y|x, s; ) (k 1)ec2 If y is not the majority class. Then, p(y|x, s; ) p(y|x, s; )2 p(y|x, s; ) ec2 So we have k y=1 p(y|x, s; ) p(y|x, s; )2 2(k 1)ec2 The lemma follows. Lemma 16. Under the parameter = , , the largest eigenvalue of the matrix 1 n n i=1 (A(xi, yi)B(xi, yi)) (8) is at most 2dk(k 1)(b+ 1)2ec2 Proof. From Lemma 14 and Lemma 15, each entry of the matrix in (8) is at most 2(k 1)(b + 1)2ec2 . Thus, by Gershgorins theorem, the maximum eigenvalue of the matrix in (8) is at most 2dk(k 1)(b+ 1)2ec2 . Now, we can prove Theorem 5 by constructing a scaled version of that satisfies the expectationlinearization constraint.",
      "exclude": false
    },
    {
      "heading": "Proof of Theorem 5",
      "text": "Proof. Consider the likelihood evaluated at = , , where = 42 . If > 1, then 2 > 4 . We know the MLE already satisfies the expectation-linearization constraint. So we can assume that 0 1, and we know that satisfies V (D; ) . Then, l(, ) l(, ) = 1 n (l(D; ) l(D; )) = g(, ) g(, ) where g(, ) = 1n l(D; (, )). Taking the second-order Taylor expansion about , we have g(, ) = g(, ) +T g(, )( ) + ( )T2g(, )( ) Since is the MLE, the first-order term T g(, )( ) = 0. The Hessian in the second-order term is just Eq.(8). Thus, from Lemma 16 we have g(, ) g(, ) (1 )2222dk(k 1)(b+ 1)2ec2 = g(, ) 2dk(k 1)(b+ 1)2 ( 2 4 )2 ec/4 = g(, ) c12 ( 2 4 )2 ec2/4 with setting c1 = 2dk(k 1)(b+ 1) and c2 = c. Then the theorem follows.",
      "exclude": false
    },
    {
      "heading": "C.3 PROOF OF THEOREM 6: UNIFORM BOUND OF MODEL ACCURACY",
      "text": "In the following, we denote = , . Lemma 17. For each y Y , if p(y|x, s; ) 1/k, then [0, 1] p(y|x, s; ) 1 k Proof. This lemma can be regarded as a corollary of Lemma 11. Lemma 18. For a fixed x and s, we denote e T y h (L1)(x,s;) = wy . Then we have p(y|x, s, ) = e Ty h (L1)(x,s;) yY e T yh (L1)(x,s;) = (wy) yY (wy) Additionally, we denote gs() = yY p(y|x, s; ) logwy logwy . We assume gs(0) 0. Then we have 0 gs() 0 Proof. gs() = yY logwy p(y|x, s; ) = VarY [logwY |X x, S = s] 0 So gs() is non-decreasing. Since gs(0) 0, we have gs() 0 when 0. From above lemma, we have for each training instance (xi, yi) D, and [0, 1], EY [ log p(Y |xi, s; ) ] log p(yi|xi, s; ) (9) For convenience, we define m(s, y) = log p(y|x, s; ) EY [ log p(Y |x, s; ) ] Lemma 19. If y satisfies Lemma 17 and gs() 0, then VarY [m(s, Y )] m(s, y)2 Proof. First we have m(s, y) = log p(y|x, s; ) log 1/k KL ( p(|x, s; )|Unif(Y) ) 0 So we have (VarY [m(s, Y )]) 1/2 = EY [( log p(Y |x, s; ) EY [ log p(Y |x, s; ) ])2] EY [log p(Y |x, s; ) EY [log p(Y |x, s; )]] = EY [KL(p(|x, s; )|Unif(Y))+ log 1/k log p(Y |x, s; )] = EY [ KL ( p(|x, s; )|Unif(Y) ) + log 1/k log p(Y |x, s; )] KL ( p(|x, s; )|Unif(Y) ) + EY [ log p(Y |x, s; ) log 1/k ] = 2KL ( p(|x, s; )|Unif(Y) ) As KL ( p(|x, s; )|Unif(Y) ) 0 and log p(y|x, s; ) log 1/k. So we have 2KL ( p(|x, s; )|Unif(Y) ) KL ( p(|x, s; )|Unif(Y) ) +log 1/klog p(y|x, s; ) = m(s, y) Then the lemma follows. From Lemma 19 and Eq. (9), we have for each training instance (xi, yi) D, and [0, 1], VarY [m(s, Y )] m(s, yi)2 (10) Lemma 20. For each training instance (xi, yi) D, and [0, 1], we have log p(yi|xi; , ) (1 ) log p(yi|xi; , 0) + log p(yi|xi; , ) Proof. We define f() = log p(yi|xi; , ) (1 ) log p(yi|xi; , 0) log p(yi|xi; , ) Because f(0) = f(1) = 0, we only need to prove that f() is concave on [0, 1]. We have 2f() = ES|Y=yi [VarY [m(S, Y )]] + VarS|Y=yi [m(S, yi)] where S|Y = yi is under the probability distribution p(s|Y = yi, xi; ) = p(yi|xi,S;)p(s)p(yi|xi;) From Eq. (10), we have ES|Y=yi [VarY [m(S, Y )]] ES|Y=yi [ m(S, yi) 2 ] VarS|Y=yi [m(S, yi)] So we have 2f() 0. The lemma follows. Now, we can prove Theorem 6 by using the same construction of an expectation-linearizing parameter as in Theorem 5.",
      "exclude": false
    },
    {
      "heading": "Proof of Theorem 6",
      "text": "Proof. Consider the same parameter = , , where = 42 1. we know that satisfies V (D; ) . Then, l(, ) l(, ) = 1 n (l(D; ) l(D; )) From Lemma 20 we have: l(D; ) = l(D; , ) (1 )l(D; , 0) + l(D; , ) So l(, ) (1 ) 1n ( l(D; ) l(D; , 0) ) = (1 ) 1n n i=1 log p(yi|xi; ) log Unif(Y) (1 )E [KL (p(|X; )Unif(Y))] ( 1 42 ) E [KL (p(|X; )Unif(Y))]",
      "exclude": false
    },
    {
      "heading": "D DETAILED DESCRIPTION OF EXPERIMENTS",
      "text": "",
      "exclude": false
    },
    {
      "heading": "D.1 NEURAL NETWORK ARCHITECTURES",
      "text": "MNIST For MNIST, we train 6 different fully-connected (dense) neural networks with 2 or 3 layers (see Table 1). For all architectures, we used dropout rate p = 0.5 for all hidden layers and p = 0.2 for the input layer. CIFAR-10 and CIFAR-100 For the two CIFAR datasets, we used the same architecture in Srivastava et al. (2014) three convolutional layers followed by two fully-connected hidden layers. The convolutional layers have 96, 128, 265 filters respectively, with a 5 5 receptive field applied with a stride of 1. Each convolutional layer is followed by a max pooling layer pools 3 3 regions at strides of 2. The fully-connected layers have 2048 units each. All units use the rectified linear activation function. Dropout was applied to all the layers with dropout rate p = (0.1, 0.25, 0.25, 0.5, 0.5, 0.5) for the layers going from input to convolutional layers to fully-connected layers.",
      "exclude": false
    },
    {
      "heading": "D.2 NEURAL NETWORK TRAINING",
      "text": "Neural network training in all the experiments is performed with mini-batch stochastic gradient descent (SGD) with momentum. We choose an initial learning rate of 0, and the learning rate is updated on each epoch of training as t = 0/(1 + t), where is the decay rate and t is the number of epoch completed. We run each experiment with 2,000 epochs and choose the parameters achieving the best performance on validation sets. Table 3 summarizes the chosen hyper-parameters for all experiments. Most of the hyper-parameters are chosen from Srivastava et al. (2014). But for some experiments, we cannot reproduce the performance reported in Srivastava et al. (2014) (We guess one of the possible reasons is that we used different library for implementation.). For these experiments, we tune the hyper-parameters on the validation sets by random search. Due to time constrains it is infeasible to do a random search across the full hyper-parameter space. Thus, we try to use as many hyper-parameters reported in Srivastava et al. (2014) as possible. D.3 EFFECT OF EXPECTATION-LINEARIZATION RATE Table 4 illustrates the detailed results of the experiments on the effect of . For MNIST, it lists the error rates under different values for six different network architectures. For two datasets of CIFAR, it gives the error rates under different values, among with the empirical expectation-linearization risk .",
      "exclude": false
    }
  ],
  "fewShot": [
    {
      "model": "gpt-5.2",
      "decision": {
        "rejection": false,
        "confidence": 0.72,
        "primary_reason": "Technically solid and well-motivated: it identifies and formalizes the dropout train–test (inference) gap, provides a latent-variable interpretation plus nontrivial bounds, and proposes a simple regularizer that directly targets the gap with consistent (if modest) empirical gains and comparisons to MC dropout/distillation; overall a credible, publishable contribution for a top-tier venue despite limited SOTA impact."
      },
      "token": {
        "prompt_tokens": 14484,
        "completion_tokens": 108,
        "total_tokens": 14592
      },
      "time": "2026-02-09T20:25:07.681843+00:00"
    },
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": false,
        "confidence": 0.72,
        "primary_reason": "Provides a principled theoretical framework for understanding dropout's inference gap via expectation-linearity, introduces a practical regularization method with formal guarantees (uniform deviation bounds, accuracy loss bounds), and demonstrates consistent empirical improvements on standard benchmarks. However, improvements are modest (~0.6-1% on CIFAR), theoretical bounds are loose/distribution-dependent, and the practical impact over simpler alternatives (e.g., MC dropout) remains unclear."
      },
      "token": {
        "prompt_tokens": 16335,
        "completion_tokens": 131,
        "total_tokens": 16466
      },
      "time": "2026-02-11T18:51:14.488033+00:00"
    }
  ],
  "test": true
}