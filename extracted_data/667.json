{
  "id": "667",
  "title": "GRAM: Graph-based Attention Model for Healthcare Representation Learning",
  "abstract": "Deep learning methods exhibit promising performance for predictive modeling in healthcare, but two important challenges remain: - Data insufficiency: Often in healthcare predictive modeling, the sample size is insufficient for deep learning methods to achieve satisfactory results.  - Interpretation: The representations learned by deep learning models should align with medical knowledge. To address these challenges, we propose a GRaph-based Attention Model, GRAM that supplements electronic health records (EHR) with hierarchical information inherent to medical ontologies.  Based on the data volume and the ontology structure, GRAM represents a medical concept as a combination of its ancestors in the ontology via an attention mechanism.  We compared predictive performance (i.e. accuracy, data needs, interpretability) of GRAM to various methods including the recurrent neural network (RNN) in two sequential diagnoses prediction tasks and one heart failure prediction task. Compared to the basic RNN, GRAM achieved 10% higher accuracy for predicting diseases rarely observed in the training data and 3% improved area under the ROC curve for predicting heart failure using an order of magnitude less training data. Additionally, unlike other methods, the medical concept representations learned by GRAM are well aligned with the medical ontology. Finally, GRAM exhibits intuitive attention behaviors by adaptively generalizing to higher level concepts when facing data insufficiency at the lower level concepts.",
  "accepted": false,
  "zeroShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": false,
        "confidence": 0.78,
        "primary_reason": "Novel attention-based approach for healthcare representation learning that effectively addresses data insufficiency and interpretability through medical ontologies. Strong empirical results on multiple datasets with good methodological rigor, though limited theoretical novelty and some experimental design concerns prevent higher confidence."
      },
      "token": {
        "prompt_tokens": 7232,
        "completion_tokens": 79,
        "total_tokens": 7311
      },
      "time": "2026-02-05T23:09:19.845096+00:00"
    }
  ],
  "article": [
    {
      "heading": "",
      "text": "insufficient for deep learning methods to achieve satisfactory results. Interpretation: The representations learned by deep learning models should align with medical knowledge. To address these challenges, we propose a GRaph-based Attention Model, GRAM that supplements electronic health records (EHR) with hierarchical information inherent to medical ontologies. Based on the data volume and the ontology structure, GRAM represents a medical concept as a combination of its ancestors in the ontology via an attention mechanism. We compared predictive performance (i.e. accuracy, data needs, interpretability) of GRAM to various methods including the recurrent neural network (RNN) in two sequential diagnoses prediction tasks and one heart failure prediction task. Compared to the basic RNN, GRAM achieved 10% higher accuracy for predicting diseases rarely observed in the training data and 3% improved area under the ROC curve for predicting heart failure using an order of magnitude less training data. Additionally, unlike other methods, the medical concept representations learned by GRAM are well aligned with the medical ontology. Finally, GRAM exhibits intuitive attention behaviors by adaptively generalizing to higher level concepts when facing data insufficiency at the lower level concepts.",
      "exclude": true
    },
    {
      "heading": "1 INTRODUCTION",
      "text": "The rapid growth in volume and diversity of health care data from electronic health records (EHR) and other sources is motivating the use of predictive modeling to improve care for individual patients. In particular, novel applications are emerging that use deep learning methods such as word embedding (Choi et al., 2016c;e), recurrent neural networks (RNN) (Che et al., 2016; Choi et al., 2016a;b; Lipton et al., 2016), convolutional neural networks (CNN) (Nguyen et al., 2016) or stacked denoising autoencoders (SDA) (Che et al., 2015; Miotto et al., 2016), demonstrating significant performance enhancement for diverse prediction tasks. Deep learning models appear to perform significantly better than logistic regression or multilayer perceptron (MLP) models that depend, to some degree, on expert feature construction (Lipton et al., 2015; Razavian et al., 2016). Training deep learning models typically requires large amounts of data that often cannot be met by a single health system or provider organization. Sub-optimal model performance can be particularly challenging when the focus of interest is predicting onset of a specific disease (e.g. heart failure) or related events such as accelerated disease progression. For example, using Doctor AI (Choi et al., 2016a), we discovered that RNN alone was ineffective to predict the onset of diseases such as cerebral degenerations (e.g. Leukodystrophy, Cerebral lipidoses) or developmental disorders (e.g. autistic disorder, Hellers syndrome), partly because their rare occurrence in the training data provided little learning opportunity to the flexible models like RNN. The data requirement of deep learning models comes from having to assess exponential number of combinations of input features. This can be alleviated by exploiting medical ontologies that encodes hierarchical clinical constructs and relationships among medical concepts. Fortunately, there are many well-organized ontologies in healthcare such as the International Classification of Diseases (ICD), Clinical Classifications Software (CCS) (Stearns et al., 2001) or Systematized Nomenclature of Medicine-Clinical Terms (SNOMED-CT) (Project et al., 2010). Nodes (i.e. medical concepts) close to one another in medical ontologies are likely to be associated with similar patients, allowing us to transfer knowledge among them. Therefore, proper use of medical ontologies will be helpful when we lack enough data for the nodes in the ontology to train deep learning models. In this work, we propose GRAM, a method that infuses information from medical ontologies into deep learning models via neural attention. Considering the frequency of a medical concept in the EHR data and its ancestors in the ontology, GRAM decides the representation of the medical concept by adaptively combining its ancestors via attention mechanism. This will not only support deep learning models to learn robust representations without large amount of data, but also learn interpretable representations that align well with the knowledge from the ontology. The attention mechanism is trained in an end-to-end fashion with the neural network model that predicts the onset of disease(s). We also propose an effective initialization technique in addition to the ontological knowledge to better guide the representation learning process. We compared predictive performance (i.e. accuracy, data needs, interpretability) of GRAM to various models including the recurrent neural network (RNN) in two sequential diagnoses prediction tasks and one heart failure (HF) prediction task. We demonstrate that GRAM is up to 10% more accurate than the basic RNN for predicting diseases less observed in the training data. After discussing GRAMs scalability, we visualize the representations learned from various models where GRAM provides more intuitive representations by grouping similar medical concepts close to one another. Finally, we show GRAMs attention mechanism can be interpreted to understand how it assigns the right amount of attention to the ancestors of each medical concept by considering the data availability and the ontology structure.",
      "exclude": true
    },
    {
      "heading": "2 METHODOLOGY",
      "text": "We first define the notations describing EHR data and medical ontologies, followed by a description of GRAM (Section 2.2), the end-to-end training of the attention generation and predictive modeling (Section 2.3), and the efficient initialization scheme (Section 2.4).",
      "exclude": false
    },
    {
      "heading": "2.1 BASIC NOTATION",
      "text": "We denote the set of entire medical codes from the EHR as c1, c2, . . . , c|C| C with the vocabulary size |C|. The clinical record of each patient can be viewed as a sequence of visits V1, . . . , VT where each visit contains a subset of medical codes Vt C. Vt can be represented as a binary vector xt 0, 1|C| where the i-th element is 1 only if Vt contains the code ci. To avoid clutter, all algorithms will be presented for a single patient. We assume that a given medical ontology G typically expresses the hierarchy of various medical concepts in the form of a parent-child relationship, where the medical codes C form the leaf nodes. Ontology G is represented as a directed acyclic graph (DAG) whose nodes form a set D = C + C. C = c|C|+1, c|C|+2, . . . , c|C|+|C| defines the set of all non-leaf nodes (i.e. ancestors of the leaf nodes), where |C| represents the number of all non-leaf nodes. We use knowledge DAG to refer to G. A parent in the knowledge DAG G represents a related but more general concept over its children. Therefore, G provides a multi-resolution view of medical concepts with different degrees of specificity. While some ontologies are exclusively expressed as parent-child hierarchies (e.g. ICD-9, CCS), others are not. For example, in some instances SNOMED-CT also links medical concepts to causal or treatment relationships, but the majority relationships in SNOMED-CT are still parent-child. Therefore, we focus on the parent-child relationships in this work.",
      "exclude": false
    },
    {
      "heading": "2.2 KNOWLEDGE DAG AND THE ATTENTION MECHANISM",
      "text": "GRAM leverages the parent-child relationship of G to learn robust representations when data volume is constrained. GRAM balances the use of ontology information in relation to data volume in determining the level of specificity for a medical concept. When a medical concept is less observed in the data, more weight is given to its ancestors as they can be learned more accurately and offer general (coarse-grained) information about their children. The process of resorting to the parent concepts can be automated via the attention mechanism and the end-to-end training as described in Figure 1. In the knowledge DAG, each node ci is assigned a basic embedding vector ei Rm, where m represents the dimensionality. Then e1, . . . , e|C| are the basic embeddings of the codes c1, . . . , c|C| while e|C|+1, . . . , e|C|+|C| represent the basic embeddings of the internal nodes c|C|+1, . . . , c|C|+|C|. The initialization of these basic embeddings is described in Section 2.4. We formulate a leaf nodes final representation as a convex combination of the basic embeddings of itself and its ancestors: gi = jA(i) ijej , jA(i) ij = 1, ij 0 for j A(i), (1) where gi Rm denotes the final representation of the code ci,A(i) the indices of the code ci and cis ancestors, ej the basic embedding of the code cj and ij R the attention weight on the embedding ej when calculating gi. The attention weight ij in Eq. (1) is calculated by the following Softmax function, ij = exp(f(ei, ej)) kA(i) exp(f(ei, ek)) (2) f(ei, ej) is a scalar value representing the compatibility between the basic embeddings of ei and ek. We compute f(ei, ej) via the following feed-forward network with a single hidden layer (MLP), f(ei, ej) = u > a tanh(Wa [ ei ej ] + ba) (3) where Wa Rl2m is the weight matrix for the concatenation of ei and ej , b Rl the bias vector, and ua Rl the weight vector for generating the scalar value. The constant l represents the dimension size of the hidden layer of f(, ). Note that we always concatenate ei and ej in the child-ancestor order. Remarks: The example in Figure 1 is derived based on a single path from ci to ca. However, the same mechanism can be applicable to multiple paths as well. For example, code ck has two paths to the root ca, containing five ancestors in total. Another scenario is where the EHR data contain both leaf codes and some ancestor codes. We can move those ancestors present in EHR data from the set C to C and apply the same process as Eq. (1) to obtain the final representations for them.",
      "exclude": false
    },
    {
      "heading": "2.3 END-TO-END TRAINING WITH A PREDICTIVE MODEL",
      "text": "We train the attention mechanism together with a predictive model such that the attention mechanism improves the predictive performance. Once the final representations g1,g2, . . . ,g|C| of all medical codes are obtained, we can convert visit Vt to a visit representation vt by using the embedding matrix G Rm|C| where gi is its i-th column as in Figure 1. We continue the mathematical formulation under the assumption that we are using the RNN to perform sequential diagnoses prediction (Choi et al., 2016a;b) with the objective of predicting the disease codes of the next visit Vt+1 given the visit records up to the current timestep V1, V2, . . . , Vt, which can be expressed as follows, yt = xt+1 = Softmax(Wht + b), where h1,h2, . . . ,ht = RNN(v1,v2, . . . ,vt), where (4) v1,v2, . . . ,vt = tanh(G[x1,x2, . . . ,xt]) where xt R|C| denotes the t-th visit; vt Rm the t-th visit representation; ht Rr the RNNs hidden layer at t-th time step (i.e. t-th visit); W R|C|r and b R|C| the weight matrices and the bias vector of the Softmax function; r denotes the dimension size of the hidden layer. We use RNN to denote any recurrent neural network variants that can cope with the vanishing gradient problem (Bengio et al., 1994), such as LSTM (Hochreiter & Schmidhuber, 1997), GRU (Cho et al., 2014), and IRNN (Le et al., 2015), with any varying numbers of hidden layers. The prediction loss for all time steps is calculated using the cross entropy as follows, L(x1,x2 . . . ,xT ) = 1T1 T1 t=1 ( yt > log(yt) + (1 yt)> log(1 yt) ) where we sum the cross entropy errors from all dimensions of yt, T denotes the length of the visit sequence. Note that the above loss is defined for a single patient. But we can take the average of the individual loss for multiple patients.",
      "exclude": false
    },
    {
      "heading": "2.4 INITIALIZING BASIC EMBEDDINGS",
      "text": "The attention generation mechanism in Section 2.2 requires basic embeddings ei of each node in the knowledge DAG. The basic embeddings of ancestors, however, pose a difficulty because they are often not observed in the data.To better initialize them, we use co-occurrence information to learn the basic embeddings of medical codes and their ancestors. Co-occurrence has proven to be an important source of information when learning representations of words or medical concepts (Mikolov et al., 2013; Choi et al., 2016c;e). To train the basic embeddings, we employ GloVe (Pennington et al., 2014), which uses the global co-occurrence matrix of words to learn their representations. In our case, the co-occurrence matrix of the codes and the ancestors was generated by counting the co-occurrences within each visit Vt, where we augment each visit with the ancestors of the codes in the visit. Details of training the basic embeddings are described in the Appendix A. Note that, with or without the initialization, the basic embeddings eis of both leaf nodes (i.e. medical codes) and non-leaf nodes (i.e. ancestors) are fine-tuned when training our model, since the error signal flows from the output yt to the final representations gis which are convex combinations of eis.",
      "exclude": false
    },
    {
      "heading": "3 EXPERIMENTS",
      "text": "We conduct three experiments to determine if GRAM offered superior prediction performance when facing data insufficiency. We first describe the experimental setup followed by results comparing predictive performance of GRAM with various baseline models. After discussing GRAMs scalability, we qualitatively evaluate the interpretability of the resulting representation. The source code of GRAM is publicly available at https://github.com/mp2893/gram.",
      "exclude": false
    },
    {
      "heading": "3.1 EXPERIMENT SETUP",
      "text": "Prediction tasks and source of data: We conduct two sequential diagnoses prediction tasks, which aim at predicting all diagnosis categories in the next visit, and one heart failure (HF) prediction task, which is a binary prediction task for predicting a future HF onset where the prediction is made only once at the last visit xT . Two sequential diagnoses predictions are respectively conducted using 1) Sutter Palo Alto Medical Foundation (PAMF) dataset, which consists of 18-years longitudinal medical records of 258K patients between age 50 and 90. This will determine GRAMs performance for general adult population with long visit records. 2) MIMIC-III dataset (Johnson et al., 2016; Goldberger et al., 2000), which is a publicly available dataset consisting of medical records of 7.5K intensive care unit (ICU) patients over 11 years. This will determine GRAMs performance for high-risk patients with very short visit records. We utilize all the patients with at least 2 visits. We prepared the true labels yt by grouping the ICD9 codes into 283 groups using CCS single-level diagnosis grouper1. This is to improve the 1https://www.hcup-us.ahrq.gov/toolssoftware/ccs/AppendixASingleDX.txt training speed and predictive performance for easier analysis, while preserving sufficient granularity for each diagnosis. Each diagnosis codes varying frequency in the training data can be viewed as different degrees of data insufficiency. We calculate Accuracy@k for each of CCS single-level diagnosis codes such that, given a visit Vt, we get 1 if the target diagnosis is in the top k guesses and 0 otherwise. We conduct HF prediction on Sutter heart failure (HF) cohort, which is a subset of Sutter PAMF data for a heart failure onset prediction study with 3.4K HF cases and 27K controls chosen by a set of criteria (see Appendix B). This will determine GRAMs performance for a different prediction task where we predict the onset of one specific condition. We randomly downsample the training data to create different degrees of data insufficiency. We use area under the ROC curve (AUC) to measure the performance. A summary of the datasets are provided in Table 1.We used CCS multi-level diagnoses hierarchy2 as our knowledge DAG G. We also tested the ICD9 code hierarchy3, but the performance was similar to using CCS multi-level hierarchy. For all three tasks, we randomly divide the dataset into the training, validation and test set by .75:.10:.15 ratio, and use the validation set to tune the hyper-parameters. Further details regarding the hyper-parameter tuning are provided in Appendix C. The test set performance is reported in the paper. Implementation details: We implemented GRAM with Theano 0.8.2 (Team, 2016). For training models, we used Adadelta (Zeiler, 2012) with a mini-batch of 100 patients, on a machine equipped with Intel Xeon E5-2640, 256GB RAM, four Nvidia Titan Xs and CUDA 7.5. Models for comparison are the following. The first two GRAM+ and GRAM are the proposed methods and the rest are baselines. Hyper-parameter tuning is configured so that the number of parameters for the baselines would be comparable to GRAMs. Further details are provided in Appendix C. GRAM: Input sequence x1, . . . ,xT is first transformed by the embedding matrix G, then fed to the GRU with a single hidden layer, which in turn makes the prediction, as described by Eq. (4). The basic embeddings eis are randomly initialized. GRAM+: We use the same setup as GRAM, but the basic embeddings eis are initialized according to Section 2.4. RandomDAG: We use the same setup as GRAM, but each leaf concept has five randomly assigned ancestors from the CCS multi-level hierarchy to test the effect of correct domain knowledge. RNN: Input xt is transformed by an embedding matrix Wemb Rk|C|, then fed to the GRU with a single hidden layer. The embedding size k is a hyper-parameter. Wemb is randomly initialized and trained together with the GRU. RNN+: We use the same setup as RNN, but we initialize the embedding matrix Wemb with GloVe vectors trained only with the co-occurrence of leaf concepts. This is to compare GRAM with a similar weight initialization technique. SimpleRollUp: We use the same setup as RNN. But for input xt, we replace all diagnosis codes with their direct parent codes in the CCS multi-level hierarchy, giving us 578, 526 and 517 input codes respectively for Sutter data, MIMIC-III and Sutter HF cohort. This is to compare the performance of GRAM with a common grouping technique. RollUpRare: We use the same setup as RNN, but we replace any diagnosis code whose frequency is less than a certain threshold in the dataset with its direct parent. We set the threshold to 100 for Sutter data and Sutter HF cohort, and 10 for MIMIC-III, giving us 4,408, 935 and 1,538 input codes respectively for Sutter data, MIMIC-III and Sutter HF cohort. This is an intuitive way of dealing with infrequent medical codes.",
      "exclude": false
    },
    {
      "heading": "3.2 PREDICTION PERFORMANCE AND SCALABILITY",
      "text": "Tables 2a and 2b show the sequential diagnoses prediction performance on Sutter data and MIMIC-III. Both figures show that GRAM+ outperforms other models when predicting labels with significant data insufficiency (i.e. less observed in the training data).The performance gain is greater for MIMIC-III, where GRAM+ outperforms the basic RNN by 10% in the 20th-40th percentile range. This seems to come from the fact that MIMIC patients on average have significantly shorter visit history than Sutter patients, with much more codes received per visit. Such short sequences make it difficult for the RNN to learn and predict diagnoses sequence. The performance difference between GRAM+ and 2https://www.hcup-us.ahrq.gov/toolssoftware/ccs/AppendixCMultiDX.txt 3http://www.icd9data.com/2015/Volume1/default.htm GRAM suggests that our proposed initialization scheme of the basic embeddings ei is important for sequential diagnosis prediction. Table 2c shows the HF prediction performance on Sutter HF cohort. GRAM and GRAM+ consistently outperforms other baselines (except RNN+) by 34% AUC, and RNN+ by maximum 1.8% AUC. These differences are quite significant given that the AUC is already in the mid-80s, a high value for HF prediction, cf. (Choi et al., 2016d). Note that, for GRAM+ and RNN+, we used the downsampled training data to initialize the basic embeddings eis and the embedding matrix Wemb with GloVe, respectively. The result shows that the initialization scheme of the basic embeddings in GRAM+ gives limited improvement over GRAM. This stems from the different natures of the two prediction tasks. While the goal of HF prediction is to predict a binary label for the entire visit sequence, the goal of sequential diagnosis prediction is to predict the co-occurring diagnosis codes at every visit. Therefore the co-occurrence information infused by the initialized embedding scheme is more beneficial to sequential diagnosis prediction. Additionally, this benefit is associated with the natures of the two prediction tasks than the datasets used for the prediction tasks. Because the initialized embedding shows different degrees of improvement as shown by Tables 2a and 2c, when Sutter HF cohort is a subset of Sutter PAMF, thus having similar characteristics. Additional prediction results when varying the k of Accuracy@k are discussed in the Appendix D. Overall, GRAM showed superior predictive performance under data insufficiency in three different experiments, demonstrating its general applicability in predictive healthcare modeling. Now we briefly discuss the scalability of GRAM by comparing its training time to RNNs. Table 3 shows the number of seconds taken for the two models to train for a single epoch for each predictive modeling task. GRAM+ and RNN+ showed the same behavior as GRAM and RNN. GRAM takes approximately 50% more time to train for a single epoch for all prediction tasks. This stems from calculating attention weights and the final representations gi for all medical codes. GRAM also generally takes about 50% more epochs to reach to the model with the lowest validation loss. This is due to optimizing an extra MLP model that generates the attention weights. Overall, use of GRAM adds a manageable amount of overhead in training time to the plain RNN.",
      "exclude": false
    },
    {
      "heading": "3.3 QUALITATIVE EVALUATION OF INTERPRETABLE REPRESENTATIONS",
      "text": "To qualitatively assess the interpretability of the learned representations of the medical codes, we plot on a 2-D space using t-SNE (Maaten & Hinton, 2008) the final representations gi of 2,000 randomly chosen diseases learned by GRAM+ for sequential diagnoses prediction on Sutter data4 (Figure 2a). The colors represent the highest disease categories and the text annotations represent the detailed disease categories in CCS multi-level hierarchy. For comparison, we also show the t-SNE plots on the strongest results from RNN+ (Figure 2b), and GloVe (Figure 2c), the same embedding technique in initializing the basic embeddings ei. Figures 2b and 2c confirm that interpretable representations cannot simply be learned only by co-occurrence or supervised prediction without medical knowledge. GRAM+ learns disease representations that are significantly more consistent with the given knowledge DAG G. Therefore the neural network predictive model that accepts gi is using accurate representations that lead to higher predictive performance. Additional scatterplots of other models are provided in Appendix E for comparison. An interactive visualization tool can be accessed at http://www.sunlab.org/research/gram-graph-based-attention-model/.",
      "exclude": false
    },
    {
      "heading": "3.4 ANALYSIS OF THE ATTENTION BEHAVIOR",
      "text": "Next we show that GRAMs attention can be interpreted to understand how it considers data availability and knowledge DAGs structure when performing a prediction task. Using Eq. (1), we can calculate the attention weights of individual disease. Figure 3 shows the attention behaviors of four representative diseases when performing HF prediction on Sutter HF cohort. Other pneumothorax (ICD9 512.89) in Figure 3a is rarely observed in the data and has only five siblings. In this case, most information is derived from the highest ancestor. Temporomandibular joint disorders & articular disc disorder (ICD9 524.63) in Figure 3b is rarely observed but has 139 siblings. In this case, its parent receives a stronger attention because it aggregates sufficient samples from all of its children to learn a more accurate representation. Note that the disease itself also receives a stronger attention to facilitate easier distinction from its large number of siblings. 4The scatterplots of models trained for sequential diagnoses prediction on MIMIC-III and HF prediction for Sutter HF cohort were similar but less structured due to smaller data size. Unspecified essential hypertension (ICD9 401.9) in Figure 3c is very frequently observed but has only two siblings. In this case, GRAM assigns a very strong attention to the leaf, which is logical because the more you observe a disease, the stronger your confidence becomes. Need for prophylactic vaccination and inoculation against influenza (ICD9 V04.81) in Figure 3d is quite frequently observed and also has 103 siblings. The attention behavior in this case is quite similar to the case with fewer siblings (Figure 3b) with a slight attention shift towards the leaf concept as more observations lead to higher confidence.",
      "exclude": false
    },
    {
      "heading": "4 RELATED WORK",
      "text": "We introduce recent studies related to GRAM that learn the representations of graphs and discuss their relationship with GRAM. Several studies focused on learning the representations of graph vertices by using the neighbor information. DeepWalk (Perozzi et al., 2014) and node2vec (Grover & Leskovec, 2016) use random walk while LINE (Tang et al., 2015) uses breadth-first search to find the neighbors of a vertex and learn its representation based on the neighbor information. Graph convolutional approaches (Yang et al., 2016; Kipf & Welling, 2016) also focus on learning the vertex representations to mainly perform vertex classification. These works focus on solving the graph data problems whereas GRAM focuses on solving EHR data problems using the knowledge DAG as supplementary information. Several researchers tried to model the knowledge DAG such as WordNet (Miller, 1995) or Freebase (Bollacker et al., 2008) where two entities are connected with various types of relation, forming a set of triples. They aim to project entities and relations (Bordes et al., 2013; Socher et al., 2013; Wang et al., 2014; Lin et al., 2015) to the latent space based on the triples or additional information such as hierarchy of entities (Xie et al., 2016). These works demonstrated tasks such as link prediction, triple classification or entity classification using the learned representations. More recently, Li et al. (2016) learned the representations of words and Wikipedia categories by utilizing the hierarchy of Wikipedia categories. GRAM is fundamentally different from the above studies in that it aims to design intuitive attention mechanism on the knowledge DAG as a knowledge prior to cope with data insufficiency and learn medically interpretable representations to make accurate predictions. A classical approach for incorporating side information in the predictive models is to use graph Laplacian regularization (Weinberger et al., 2006; Che et al., 2015). However, using this approach is not straightforward as it relies on the appropriate definition of distance on graphs which is often unavailable.",
      "exclude": true
    },
    {
      "heading": "5 CONCLUSION",
      "text": "Data insufficiency, either due to less common diseases or small datasets, is one of the key hurdles in healthcare analytics, especially when we apply deep neural networks models. To overcome this hurdle, we leverage the knowledge DAG, which provides a multi-resolution view of medical concepts. We propose GRAM, a graph-based attention model using both a knowledge DAG and EHR to learn an accurate and interpretable representations for medical concepts. GRAM chooses a weighted average of ancestors of a medical concept and train the entire process with a predictive model in an end-to-end fashion. We conducted three predictive modeling experiments on real EHR datasets and showed significant improvement in the prediction performance, especially on low-frequency diseases and small datasets. Analysis of the attention behavior provided intuitive insight of GRAM.",
      "exclude": true
    },
    {
      "heading": "A GENERATING GLOVE EMBEDDINGS",
      "text": "We learn the basic embeddings eis of medical codes and their ancestors using GloVe (Pennington et al., 2014), which uses global co-occurrence matrix of words to learn their representations. We generate the co-occurrence matrix of the codes and the ancestors by counting the co-occurrence within each visit Vt. However, since visits only contain the leaf codes c C, we augment each visit with the ancestors of the codes in each visit, then count the co-occurrence of codes and ancestors altogether. We describe the details of the algorithm with an example. We borrow the parent-child relationships from the knowledge DAG of Figure 1. Given a visit Vt, Vt = cd, ci, ck (5) we augment it with the ancestors of all the codes to obtain the augmented visit V t , V t = cd, cb, ca, ci, cg, cc, ca, ck, cj , cf , cc, cb, ca (6) where the added ancestors are underlined. Note that a single ancestor can appear multiple times in V t . In fact, the higher the ancestor is in the knowledge DAG, the more times it is likely to appear in V t . We count the co-occurrence of two codes in V t as follows, co-occurrence(ci, cj , V t ) = count(ci, V t ) count(cj , V t ) (7) where count(ci, V t ) is the number of times the code ci appears in the augmented visit V t . For example, the co-occurrence between the leaf code ci and the root ca is 3. However, the co-occurrence between the ancestor cc and the root ca is 6. Therefore our algorithm will naturally make the ancestor codes have higher co-occurrence with other codes compared to leaf medical codes. We repeat this calculation for all pairs of codes in all augmented visits of all patients to obtain the co-occurrence matrix depicted by Figure 4. For training the embedding vectors using the co-occurrence matrix, we use the same procedure and hyper-parameter as described in Pennington et al. (2014).",
      "exclude": false
    },
    {
      "heading": "B HEART FAILURE COHORT CONSTRUCTION",
      "text": "For the heart failure (HF) case patients, we select patients between 40 to 85 years of age at the time of HF diagnosis. HF diagnosis (HFDx) criteria are defined as: 1) Qualifying ICD-9 codes for HF appeared in the encounter records or medication orders. Qualifying ICD-9 codes are listed in Table 4. 2) at least three clinical encounters with qualifying ICD-9 codes had to occur within 12 months of each other, where the date of HFDx was assigned to the earliest of the three dates. If the time span between the first and second appearances of the HF diagnosis code was greater than 12 months, the date of the second encounter was used as the first qualifying encounter. Up to ten eligible controls (in terms of sex, age, location) were selected for each case, yielding average 9 controls per case. Each control was also assigned an index date, which is the HFDx date of the matched case. Controls are selected such that they did not meet the HF diagnosis criteria prior to the HFDx date plus 182 days of their corresponding case. Control subjects were required to have their first office encounter within one year of the matching HF case patients first office visit, and have at least one office encounter 30 days before or any time after the cases HFDx date to ensure similar duration of observations among cases and controls.",
      "exclude": false
    },
    {
      "heading": "C HYPER-PARAMETER TUNING",
      "text": "We define five hyper-parameters for GRAM: dimensionality m of the basic embedding ei: [100, 200, 300, 400, 500] dimensionality r of the RNN hidden layer ht from Eq. (4): [100, 200, 300, 400, 500] dimensionality l of Wa and ba from Eq. (3): [100, 200, 300, 400, 500] L2 regularization coefficient for all weights except RNN weights: [0.1, 0.01, 0.001, 0.0001] dropout rate for the dropout on the RNN hidden layer: [0.0, 0.2, 0.4, 0.6, 0.8] We performed 100 iterations of the random search by using the above ranges for each of the three prediction experiments. For sequential diagnoses prediction on Sutter data, we used 10% of the training data to tune the hyper-parameters to balance the time and search space. To match the baselines number of parameters to GRAMs, we add 550 to the list of ms possible values. This will make the baselines largest possible number of parameters comparable to the GRAMs largest possible number of parameters. For SimpleRollUp and RollUpRare, the number of input codes is smaller than other models due to the grouping. Therefore, to match their largest possible number of parameters to GRAMs, we need to add much larger values to m. However, after preliminary experiments, as expected, setting m to too large a value degraded the performance due to overfitting. Since the number of input codes decreased due to the grouping, increasing the dimensionality of ei is not a logical thing to do. Therefore, for SimpleRollUp and RollUpRare, we use the same list of values for m as other baselines. Table 5 describes the final hyper-parameter settings we used for all models for each prediction experiments. D PREDICTION RESULTS USING DIFFERENT kS IN ACCURACY@K We show Accuracy@k using k = 5, 10, 20, 30 for sequential diagnoses prediction on Sutter data (Tables 6a, 6b, 6c and 6d) and MIMIC-III (Tables 7a, 7b, 7c and 7d). We can see from the tables that GRAM+ consistently outperforms other models under 40th percentile range, except when k = 20, 30 for sequential diagnoses prediction on Sutter data where SimpleRollUp shows similar performance. We can also see that GRAM+ performs significantly better than other models for all k = 5, 10, 20, 30 when predicting infrequently observed diseases on MIMIC-III. As discussed in Section 3.2, this seems to come from the short visit sequences of MIMIC patients.",
      "exclude": false
    },
    {
      "heading": "E T-SNE 2-D PLOTS OF VARIOUS MODELS",
      "text": "For further comparison, we display t-SNE scatterplots of GRAM (Figure 5a) RandomDAG (Figure 5b, RNN (Figure 5c), and Skip-gram (Figure 5d). GRAM, RandomDAG and RNN were trained for sequential diagnoses prediction on Sutter data, and Skip-gram (Mikolov et al., 2013) was trained on Sutter data as it is an unsupervised method. For Skip-gram, we used each visit Vt as the context window. As we do not distinguish between the target concept and the neighbor concepts, we calculated the Skip-gram objective function using all possible pairs of codes within a single visit. We can see from Figure 5a that the quality of the final representations gi of GRAM is quite similar to GRAM+ (Figure 2a). Compared to other baselines, GRAM demonstrates significantly more structured representations that align well with the given knowledge DAG. It is interesting that Skip-gram shows the most structured representation among all baselines. We used GloVe to initialize the basic embeddings ei in this work because it uses global co-occurrence information and its training time is dependent only on the total number of unique concepts |C|. Skip-grams training time, on the other hand, depends on both the number of patients and the number of visits each patient made, which makes the algorithm generally slower than GloVe. However, considering both Figures 2c and 5d, initializing eis with Skip-gram vectors might give us additional performance boost.",
      "exclude": false
    }
  ],
  "fewShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": false,
        "confidence": 0.78,
        "primary_reason": "Novel attention-based mechanism for leveraging medical ontologies to address data insufficiency and interpretability in healthcare prediction. Strong empirical validation across three tasks with comprehensive baselines and interpretability analysis."
      },
      "token": {
        "prompt_tokens": 7394,
        "completion_tokens": 75,
        "total_tokens": 7469
      },
      "time": "2026-02-08T22:40:04.886672+00:00"
    }
  ],
  "test": false
}