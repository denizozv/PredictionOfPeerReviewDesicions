{
  "id": "424",
  "title": "Mollifying Networks",
  "abstract": "The optimization of deep neural networks can be more challenging than the traditional convex optimization problems due to highly non-convex nature of the loss function, e.g. it can involve pathological landscapes such as saddle-surfaces that can be difficult to escape from for algorithms based on simple gradient descent. In this paper, we attack the problem of optimization of highly non-convex neural networks objectives by starting with a smoothed -- or mollified -- objective function which becomes more complex as the training proceeds.  Our proposition is inspired by the recent studies in continuation methods: similarly to curriculum methods, we begin by learning an easier (possibly convex) objective function and let it evolve during training until it eventually becomes the original, difficult to optimize objective function. The complexity of the mollified networks is controlled by a single hyperparameter that is annealed during training. We show improvements on various difficult optimization tasks and establish a relationship between recent works on continuation methods for neural networks and mollifiers.",
  "accepted": true,
  "zeroShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": true,
        "confidence": 0.72,
        "primary_reason": "Methodological concerns: (1) Theoretical justification for the mollification approach is unclear - the connection between convolving loss functions and adding noise to activations lacks rigorous derivation; (2) The proposed method introduces many hyperparameters (annealing schedules, noise scaling, layer-specific decay) making it difficult to assess true contribution; (3) Experimental validation is weak - limited baselines, small-scale experiments (MNIST with 72 layers is not convincing for 2016), and inconsistent results (e.g., unstable training with certain annealing schedules); (4) The relationship to existing work (curriculum learning, simulated annealing, weight noise) is acknowledged but the novelty over these approaches is not clearly demonstrated; (5) Writing quality issues and incomplete algorithmic descriptions (Algorithm 1 is convoluted and hard to follow); (6) Missing important experimental details and ablation studies to isolate the contribution of different components."
      },
      "token": {
        "prompt_tokens": 7338,
        "completion_tokens": 237,
        "total_tokens": 7575
      },
      "time": "2026-02-05T22:45:08.996805+00:00"
    }
  ],
  "article": [
    {
      "heading": "1 INTRODUCTION",
      "text": "In the last few years, deep neural networks i.e. convolutional networks (LeCun et al., 1989), LSTMs (Hochreiter & Schmidhuber, 1997a) or GRUs (Cho et al., 2014) set the state of the art on a range of challenging tasks (Szegedy et al., 2014; Visin et al., 2015; Hinton et al., 2012; Sutskever et al., 2014; Bahdanau et al., 2014; Mnih et al., 2013; Silver et al., 2016). However when trained with variants of SGD (Bottou, 1998) deep networks can be difficult to optimize due to their highly non-linear and non-convex nature (Choromanska et al., 2014; Dauphin et al., 2014). A number of approaches were proposed to alleviate the difficulty of optimization: addressing the problem of the internal covariate shift with Batch Normalization (Ioffe & Szegedy, 2015), learning with a curriculum (Bengio et al., 2009), recently an approach to train RNNs with diffusion process (Mobahi, 2016), and graduated optimization (Hazan et al., 2015). The impact of noise injection on the behavior of modern deep learning methods has been explored by Neelakantan et al. (2015a). Hazan et al. (2015) have shown that injecting a particular noise and scheduling it carefully, can guarantee the convergence in O(1/2 2) steps for -optimal and -nice functions. Similar to our work graduated optimization optimizes a smoothed objective function without performing expensive convolutions. Injecting noise to the activation functions and scheduling it have been recently shown to improve the performance on a wide variety of tasks (Gulcehre et al., 2016). We connect the ideas of curriculum learning and continuation methods with those arising from models with skip connections and using layers that compute near-identity transformations. Skip connections allow to train very deep residual and highway architectures (He et al., 2015; Srivastava et al., 2015) by skipping layers or block of layers. Similarly, it has been shown that stochastically changing the depth of a network during training (Huang et al., 2016b) does not prevent convergence and enables better generalization performance. We discuss the idea of mollification for neural networks a form of differentiable smoothing of the loss function connected to noisy activations which in our case can be interpreted as a form of adaptive noise injection which is controlled by a single hyperparameter. Inspired by Huang et al. (2016b), we use a hyperparameter to stochastically control the depth of our network. This allows us to start the optimization from a convex objective function (as long as the optimized criterion is convex, e.g. linear or logistic regression) and to slowly introduce more complexity into the model by annealing the hyperparameter, thus making the network deeper and increasingly non-linear. This work was done while these students were interning at the MILA lab in University of Montreal. An important difference of our work compared to injecting noise to the gradients as it is explored in (Hazan et al., 2015; Neelakantan et al., 2015b) is that we inject the noise in the forward computation of the graph and we shape the cost function directly. As a result the cost function for the mollified network both at the test time and during the training are consistent and this makes the early-stopping much easier.",
      "exclude": true
    },
    {
      "heading": "2 MOLLIFYING OBJECTIVE FUNCTIONS",
      "text": "",
      "exclude": false
    },
    {
      "heading": "2.1 CONTINUATION AND ANNEALING METHODS",
      "text": "Continuation methods and simulated annealing provide a general strategy to reduce the impact of local minima and deal with non-convex, continuous, but not necessarily everywhere differentiable objective functions by smoothing the original objective function and gradually reducing the amount of smoothing during training (Allgower & Georg, 1980) (see Fig. 1). In machine learning, approaches based on curriculum learning (Bengio et al., 2009) are inspired by this principle and define a sequence of gradually more difficult training tasks (or training distributions) that eventually converge to the task of interest. In the context of stochastic gradient descent, we use a stochastic estimation of the gradient for the smoothed objective function. This is convenient because it may not be analytically feasible to compute the smoothed function, but a Monte-Carlo estimate can often be obtained easily. In this paper we construct a sequence of smoothed objective functions obtained with a form of mollification and we progressively optimize them. The training procedure iterates over the sequence of objective functions starting from the simpler ones i.e. with a smoother loss surface and moving towards more complex ones until the last, original, objective function is reached.1",
      "exclude": false
    },
    {
      "heading": "2.2 MOLLIFIERS AND WEAK GRADIENTS",
      "text": "We smooth the loss function L, which is parametrized by Rn, by convolving it with another function K() with stride Rn: LK() = (L K)() = + L( )K( )d (1) Although there are many choices for the function K(), we focus on those that satisfy the definition of a mollifier. A mollifier is an infinitely differentiable function that behaves like an approximate identity in the group of convolutions of integrable functions. If K() is an infinitely differentiable function, that converges to the Dirac delta function when appropriately rescaled and for any integrable function L, then it is a mollifier: L() = lim 0 nK(/ )L( )d . (2) 1We plan to release the source code of the models and experiments under, http://github.com/ caglar/molly_nets/. If we choose K() to be a mollifier and obtain the smoothed loss function LK as in Eqn. 1, we can take its gradient with respect to using directly the result from Evans (1998): LK() = (L K)() = (L K)(). (3) To relate the resulting gradient LK to the gradient of the original function L, we introduce the notion of weak gradient, i.e. an extension to the idea of weak/distributional derivatives to functions with multidimensional arguments, such as loss functions of neural networks. For an integrable function L in space L L([a, b]), g L([a, b]n) is a n-dimensional weak gradient of L if it satisfies: C g( )K( )d = C L( )K( )d , (4) where K( ) is an infinitely differentiable function vanishing at infinity, C [a, b]n and Rn. As long as the chosen K() fulfills the definition of a mollifier we can use Eqn. 3 and Eqn. 4 2 to rewrite the gradient as: LK() = (L K)() by Eqn. 3 (5) = C L( )K( )d (6) = C g( )K( )d by Eqn. 4 (7) For a differentiable almost everywhere function L, the weak gradient g() is equal to L almost everywhere. With a slight abuse of notation we can therefore write: LK() = C L( )K( )d (8)",
      "exclude": false
    },
    {
      "heading": "2.3 GAUSSIAN MOLLIFIERS",
      "text": "It is possible to use the standard Gaussian distribution N (0, I) as a mollifier K(), as it satisfies the desired properties: it is infinitely differentiable, a sequence of properly rescaled Gaussian distributions converges to the Dirac delta function and it vanishes in infinity. With such a K() the gradient becomes: LK=N () = C L( )p( )d (9) = E [L( ) ], with N (0, I) (10) Exploiting the fact that a Gaussian distribution is a mollifier, we can focus on a sequence of mollifications indexed by scaling parameter introduced in Eqn. 2. A single element of this sequence takes the following form: LN , () = C L( ) 1p(/ )d (11) = E [L( ) ], with N (0, 2I) (12) Replacing with yields a sequence of mollifications indexed by : LN ,() = E [L( ) ], with N (0, 2I) (13) with the following property (by Eqn. 2): lim 0 LN ,() = L() (14) An intuitive interpretation of the result is that determines the standard deviation of a mollifying Gaussian and is annealed in order to construct a sequence of gradually less \"blurred\" and closer 2We omit for brevity the algebraic details involved with a translation of the argument. approximations to L. This is consistent with the property that when is annealed to zero we are optimizing the original function L. So far we obtained the mollified version LK() of the cost function L() by convolving it with a mollifier K(). The kernel K() corresponds to the average effect of injecting noise sampled from standard Normal distribution. The amount of noise controls the amount of smoothing. Gradually reducing the noise during training is related to a form of simulated annealing (Kirkpatrick et al., 1983). Similarly to the analysis in Mobahi (2016), we can write a Monte-Carlo estimate of LK() = (L K)() 1N N i=1 L( (i)). We provide the derivation and the gradient of this equation in Appendix A. The Monte-Carlo estimators of the mollifiers can be easily implemented with neural networks, where the layers typically have the form: hl = f(Wlhl1) (15) with hl1 a vector of activations from the previous layer in the hierarchy, Wl a matrix representing a linear transformation and f an element-wise non-linearity of choice. A mollification of such a layer can be formulated as: hl = f((Wl l)hl1), where l N (, 2) (16) From Eqn. 16, it is easy to see that both weight noise methods proposed by Hinton & van Camp (1993) and Graves (2011) can be seen as a variation of Monte-Carlo estimate of mollifiers.",
      "exclude": false
    },
    {
      "heading": "2.4 GENERALIZED AND NOISY MOLLIFIERS",
      "text": "We introduce a generalization of the concept of mollifiers that encompasses the approach we explored here and that is targeted during optimization via a continuation method using stochastic gradient descent. Definition 2.1. (Generalized Mollifier). A generalized mollifier is an operator, where T(f) defines a mapping between two functions, such that T : f f. lim 0 Tf = f, (17) f0 = lim Tf is an identity function (18) (Tf)(x) x exists x, > 0 (19) In addition, we consider noisy mollifiers which can be defined as an expected value of a stochastic function (x, ) under some noise source with variance : (Tf)(x) = E[(x, )] (20) Definition 2.2. (Noisy Mollifier). We call a stochastic function (x, ) with input x and noise a noisy mollifier if its expected value corresponds to the application of a generalized mollifier T, as per Eqn. 20. The composition of two noisy mollifiers sharing the same is also a noisy mollifier, since the three properties in the definition (Eqns. 17,18,19) are still satisfied. When = 0 no noise is injected and therefore the original function will be optimized. If instead, the function will become an identity function. Thus, for instance, if we mollify each layer of a feed-forward network except the output layer, when all the mollified layers will become identity function and the objective function of the network with respect to its inputs will be convex. Consequently, corrupting separately the activation function of each level of a deep neural network (but with a shared noise level ) and annealing yields a noisy mollifier for the objective function. This is related to the work of Mobahi (2016), who recently introduced a way of analytically smoothing of the non-linearities to help the training of recurrent networks. The differences of that approach from our algorithm is two-fold: we use a noisy mollifier (rather than an analytic smoothing of the networks non-linearities) and we introduce (in the next section) a particular form of the noisy mollifier that empirically proved to work well. Shaping the cost function to define a sequence of costs that are progressing from easier to more difficult ones can be related to the reward shaping (Ng et al., 1999; Ng, 2003) algorithms. In our algorithm, we shape the cost and the model architecture itself, rather than rewards or the targets in order to make the optimization easier. In that sense, reward shaping can be considered to be more closer to curriculum learning.",
      "exclude": false
    },
    {
      "heading": "3 METHOD",
      "text": "We propose an algorithm to mollify the cost of a neural network which also addresses an important drawback of the previously proposed noisy training procedures: as the noise gets larger, it can dominate the learning process and lead the algorithm to perform a random walk on the energy landscape of the objective function. Conversely in our algorithm, as the noise gets larger gradient descent minimizes a simpler (e.g. convex) but still meaningful objective function. We define the desired behavior of the network in the limit cases where the noise is very large or very small, and modify the model architecture accordingly. Specifically, during training we minimize a sequence of increasingly complex noisy objectives L = (L1(; 1),L2(; 2), ,Lk(; k)) that we obtain by annealing the scale (variance) of the noise i. Let us note that our algorithm satisfies the fundamental properties of the generalized and noisy mollifiers that we introduced earlier. We use a noisy mollifier based on our definition in Section 2.4. Instead of convolving the objective function with a kernel: 1. We start the training by optimizing a convex objective function that is obtained by configuring all the layers between the input and the last cost layer to compute an identity function, i.e., by skipping both the affine transformations and the blocks followed by nonlinearities. 2. During training, the magnitude of noise which is proportional to p is annealed, allowing to gradually evolve from identity transformations to linear transformations between the layers. 3. Simultaneously, as we decrease the p, the noisy mollification procedure allows the element-wise activation functions to gradually change from linear to be nonlinear.",
      "exclude": false
    },
    {
      "heading": "4 SIMPLIFYING THE OBJECTIVE FUNCTION FOR FEEDFORWARD NETWORKS",
      "text": "For every unit of each layer, we either copy the activation (output) of the corresponding unit of the previous layer (the identity path in Figure 2) or output a noisy activation hl of a non-linear transformation of it (hl1, ;Wl), where is noise, Wl is a weight matrix applied on hl1 and is a vector of binary decisions for each unit (the convolutional path in Figure 2): hl = (hl1, ;Wl) (21) (hl1, ,l;Wl) = l hl1 + (1 l) hl (22) hl = (hl1, ,l;Wl). (23) To decide which path to take, for each unit in the network, a binary stochastic decision is taken by drawing from a Bernoulli distribution with probability dependent on the decaying value of pl: l Bernoulli(pl) (24) If the number of hidden units of layer l1 and layer l+1 is not the same, we can either zero-pad layer l1 before feeding it into the next layer or apply a linear projection to obtain the right dimensionality. For pl = 1, the layer computes the identity function leading to a convex objective. If pl = 0 the layer computes the original non-linear transformation unfolding the full capacity of the model. We call the connections that are introduced this way as unitwise stochastic skip connections(USSC). In DropIn layers (Smith et al., 2016) a binary random vector is sampled from a Bernoulli distribution to decide whether to introduce skip a connection from the layer below l 1 for each layer l and they use this as a regularization. As opposed to the USSC, DropIn layers do not necessarily do not necessarily achieve a convex objective function as the DropIn ratio (pl) increases. The pseudo-code for the mollified activations is reported in Algorithm 1. Algorithm 1 Activation of a unit i at layer l. 1: xi w>i hl1 + bi . an affine transformation of hl1 2: i u(xi) f(xi) . i is a measure of a saturation of a unit 3: (xi) (sigmoid(aii) 0.5)2 . std of the injected noise depends on i 4: i N (0, 1) . sampling the noise from a basic Normal distribution 5: si pl c (xi)|i| . Half-Normal noise controlled by (xi), const. c and prob-ty pl 6: (xi, i) sgn(u(xi))min(|u(xi)|, |f(xi) + sgn(u(xi))|si||) + u(0) . noisy activation 7: li Bernoulli(pl) . pl controls the variance of the noise AND the prob of skipping a unit 8: hli = (xi, i) . h l i is a noisy activation candidate 9: (hl1, i, li;wi) = l ih l1 i + (1 li)hli . make a HARD decision between h l1 i and h l i",
      "exclude": false
    },
    {
      "heading": "5 LINEARIZING THE NETWORK",
      "text": "In Section 2, we show that convolving the objective function with a particular kernel can be approximated by adding noise to the activation function. This method may suffer from excessive random exploration when the noise is very large. We address this issue by bounding the element-wise activation function f() with its linear approximation when the variance of the noise is very large, after centering it at the origin. The resulting function f() is bounded and centered around the origin. Note that centering the sigmoid or hard-sigmoid will make them symmetric with respect to the origin. With a proper choice of the standard deviation (h), the noisy activation function becomes a linear function of the input when p is large, as illustrated by Figure 10. Let u(x) = u(x)u(0), where u(0) is the offset of the function from the origin, and xi the i-th dimension of an affine transformation of the output of the previous layer hl1: xi = w>i h l1 + bi. Then: (xi, i;wi) = sgn(u(xi))min(|u(xi)|, |f(xi) + sgn(u(xi))|si||) + u(0) (25) The noise is sampled from a Normal distribution with mean 0 and whose standard deviation depends on c: si N (0, p c (xi))",
      "exclude": false
    },
    {
      "heading": "5.1 LINEARIZING RELU ACTIVATION FUNCTION",
      "text": "We have a simpler form of the equations to linearize ReLU (Nair & Hinton, 2010) activation function when pl . Instead of the complicated Eqn. 23. We can use a simpler equation as in Eqn. 26 to achieve the linearization of the activation function when we have a very large noise in the activation function: si = minimum(|xi|, p(xi)||) (26) (xi, i,wi) = f(xi) si (27)",
      "exclude": false
    },
    {
      "heading": "6 MOLLIFYING LSTMS AND GRUS",
      "text": "In a similar vein it is possible to smooth the objective functions of LSTM and GRU networks by starting the optimization procedure with a simpler objective function such as optimizing a word2vec, BoW-LM or CRF objective function at the beginning of training and gradually increasing the difficulty of the optimization by increasing the capacity of the network. For GRUs we set the update gate to 1t where t is the time-step index and reset the gate to 1 if the noise is very large, using Algorithm 1. Similarly for LSTMs, we can set the output gate to 1 and input gate to 1t and forget gate to 1 1 t when the noise is very large. The output gate is 1 or close to 1 when the noise is very large. This way the LSTM will behave like a BOW model. In order to achieve this behavior, the activations (xt, i) of the gates can be formulated as: (xlt, ) = f(x l t + p l(x)||) By using a particular formulation of (x) that constraints it to be in expectation over when pl = 1, we can obtain a function for R within the range of f() that is discrete in expectation, but still per sample differentiable: (xlt) = f1() xlt E[||] (28) We provide the derivation of Eqn. 28 in Appendix B. The gradient of the Eqn. 28 will be a Monte-Carlo approximation to the gradient of f(xlt). 7 ANNEALING SCHEDULES FOR p We used a different schedule for each layer of the network, such that the noise in the lower layers will anneal faster. This is similar to the linearly decaying probability of layers in Huang et al. (2016b). Exponential Decay In our experiments, we focused on using an annealing schedule similar to the inverse sigmoid rule in Bengio et al. (2015) with plt, plt = 1 e kvtl tL (29) with hyper-parameter k 0 at tth update for the lth layer, where L is the number of layers of the model. We stop annealing when the expected depth pt = L i=1 p l t reaches some threshold . In our experiment we set vt to be a moving average of the loss3 of the network, but for some of our experimnets that resulted unstable behaviors in the training and thus we have to fix vt to 1. An advantage of using running average of loss for the vt is because the behavior of the loss/optimization can directly influence the annealing behavior of the network. Because we will have: lim vt plt = 1 and, lim vt0 plt = 0. (30) This has a desirable property: when the training-loss is high, the noise injected into the system will be large as well. As a result, the model is encouraged to do more exploration, while if the model converges the noise injected into the system by the mollification procedure will be zero. Square-root Decay The square root decaying of the learning rate is very popular. In our experiments we have tried to decay the plt according to min(pmin, 1 t Nepochs ) where t is the index of the iteration/epoch over the data and Nepochs corresponds to the total number of iterations that the model will do on the dataset. pmin is hyperparameter to define the lower bound on the plt. Linear Decay We have also experimented with linearly decaying the plt via min(pmin, 1 tNepochs ). We have compared the plot of different annealing methods described in this paper as in Figure 4. Furthermore, in our experiments we observe that training with noisy mollifiers can potentially be helpful for the generalization. This can be due to the noise induced to the backpropagation through the noisy mollification, that makes SGD more likely to converge to a flatter-minima (Hochreiter & Schmidhuber, 1997b) because the noise will help it escape from sharper local minima.",
      "exclude": false
    },
    {
      "heading": "8 EXPERIMENTS",
      "text": "In this section we mainly focus on training of difficult to optimize models, in particular deep MLPs with sigmoid or tanh activation functions. The details of the experimental procedure is provided in Appendix C.",
      "exclude": false
    },
    {
      "heading": "8.1 EXPLORATORY STUDY ON MNIST",
      "text": "We train a thin deep neural network on MNIST (LeCun & Cortes, 1998) dataset with 72 hidden layers and 100 hidden units. We train our model with Adam(Kingma & Ba, 2014) optimizer and fix the 3Depending on whether the model overfits or not, this can be a moving average of training or validation loss. learning rate of all the models to 3e4. We have used the same learning-rate for all the models in order to factor out the possibility that a model converges faster, due to the fact of using a larger learning rate. Firstly, in Figure 5, we investigate the effect of using different annealing schedules. Exponential decay converges faster compared to linear decay and square root decay of p. We find it to be very unstable to train our model with linear and square root decay in particular for large c values. Thus we have to use smaller c value (20 instead of 100) to be able to train the model with causing it to diverge. In Figure 6, we show the effect of using the noisy training procedure that we have introduced by sampling a mask from Bernoulli and Gaussian distributions versu using the deterministic approximation of this noisy procedure which we also use for the test time but during the training as well. In Figure 7, we compare the results obtained for the model using mollification obtained with or without batch normalization and feed-forward residual networks. The mollified model performs very closely to the MLP trained with residual connections and the batchnorm. However, using residual connections and batch-norm does not seem to improve the results. We have tried to run experiment with the Monte-Carlo approximation of the mollification which is derived in Appendix A, however when we start with large noise and anneal the noise during the training, the model was very unstable and training was diverging. If we start with small noise and anneal the magnitude of the noise during the training, we could not observe any effect of it on the training.",
      "exclude": false
    },
    {
      "heading": "8.2 DEEP MLP EXPERIMENTS",
      "text": "Deep Parity Experiments Training neural networks on a high-dimensional parity problem can be challenging (Graves, 2016; Kalchbrenner et al., 2015). We experiment on forty dimensional (bits) parity problem with 6-layer MLP using sigmoid activation function. All the models are initialized with Glorot initialization Glorot et al. (2011) and trained with SGD with momentum. We compare an MLP with residual connections using batch normalization and a mollified network with sigmoid activation function. As can be seen in Figure 8, the mollified network converges faster. Deep Pentomino Pentomino is a toy-image dataset where each image has 3 Pentomino blocks. The task is to predict whether if there is a different shape in the image or not (Gulcehre & Bengio, 2013). The best reported result on this task with MLPs is 68.15% accuracy (Gulcehre et al., 2014). The same model as ours trained without noisy activation function and vanilla residual connections scored 69.5% accuracy, while our mollified version scored 75.15% accuracy after 100 epochs of training on the 80k dataset. CIFAR10 We experimented with deep convolutional neural networks of 110-layers with residual blocks and residual connections comparing our model against ResNet and Stochastic depth. We adapted the hyperparameters of the Stochastic depth network from Huang et al. (2016a) and we used the same hyperparameters for our algorithm. We report the training and validation curves of the three models in Figure 10 and the best test accuracy obtained early stopping on validation accuracy over 500 epochs in Table 1. Our model achieves better generalization than ResNet. Stochastic depth achieves better generalization, but it might be possible to combine both and obtain better results. Test PPL LSTM 119.4 Mollified LSTM 115.7 Table 2: 3-layered LSTM network on word-level language modeling for PTB.",
      "exclude": false
    },
    {
      "heading": "9 LSTM EXPERIMENTS",
      "text": "Predicting the Character Embeddings from Characters Learning the mapping from sequences of characters to the word-embeddings is a difficult problem. Thus one needs to use a highly non-linear function. We trained a word2vec model on Wikipedia with embeddings of size 500 (Mikolov et al., 2014) with a vocabulary of size 374557. LSTM Language Modeling We evaluate our model on LSTM language modeling. Our baseline model is a 3-layer stacked LSTM without any regularization. We observed that mollified model converges faster and achieves better results. We provide the results for PTB language modeling in Table 2.",
      "exclude": false
    },
    {
      "heading": "10 CONCLUSION",
      "text": "We propose a novel method for training neural networks inspired by an idea of continuation, smoothing techniques and recent advances in non-convex optimization algorithms. The method makes learning easier by starting from a simpler model, solving a well-behaved problem, and gradually transitioning to a more complicated setting. We show improvements on very deep models, difficult to optimize tasks and compare with powerful techniques such as batch-normalization and residual connections. We also show that the mollification procedure improves the generalization performance of the model on two tasks. Our future work includes testing this method on large-scale language tasks that require long training time, e.g., machine translation and language modeling. Moreover, (Kaiser & Sutskever, 2015) observed that the training of Neural-GPU model can be improved significantly by using gradient noise which can be related to the smoothing of the loss surface, it would be interesting to try mollification on this model to see if the training of Neural GPU can be made easier by using mollification procedure.",
      "exclude": true
    },
    {
      "heading": "ACKNOWLEDGEMENTS",
      "text": "We thank Nicholas Ballas and Misha Denil for the valuable discussions and their feedback. We would like to also thank the developers of Theano 4, for developing such a powerful tool for scientific computing Theano Development Team (2016). We acknowledge the support of the following organizations for research funding and computing support: NSERC, Samsung, Calcul Quebec, Compute Canada, the Canada Research Chairs and CIFAR.",
      "exclude": false
    },
    {
      "heading": "A MONTE-CARLO ESTIMATE OF MOLLIFICATION",
      "text": "LK() = (L K)() = C L( )K()d which can be estimated by a Monte Carlo: 1 N N i=1 L( (i)), where (i) is a realization of the noise random variable yielding LK() 1 N N i=1 L( (i)) . (31) Therefore introducing additive noise to the input of L() is equivalent to mollification.",
      "exclude": false
    },
    {
      "heading": "B DERIVATION OF THE NOISY ACTIVATIONS FOR THE GATING",
      "text": "Assume that zlt = x l t + p l t(x)|lt| and E[(xlt, )] = t. Thus for all zlt, E[(x l t, l t)] = E[f(z l t)], (32) t = E[f(zlt)], assuming f() behaves similar to a linear function: (33) E[f(zlt)] f(E[zlt]) since we use hard-sigmoid for f() this will hold. (34) f1(t) E[zlt] (35) (36) As in Eqn. 32, we can write the expectation of this equation as: f1(t) xlt + plt(x)E[lt] Corollary, the value that (xlt) should take in expectation for p l t = 1 would be: (xlt) f1(t) xlt E[lt] In our experiments for f() we used the hard-sigmoid activation function. We used the following piecewise activation function in order to use it as f1(x) = 4(x 0.5). During inference we use the expected value of random variables and .",
      "exclude": false
    },
    {
      "heading": "C EXPERIMENTAL DETAILS",
      "text": "C.1 MNIST The weights of the models are initialized with Glorot & Bengio initialization Glorot et al. (2011). We use the learning rate of 4e 4 along with RMSProp. We initialize ai parameters of mollified activation function by sampling it from a uniform distribution, U[2, 2]. We used 100 hidden units at each layer with a minibatches of size 500. C.2 PENTOMINO We train a 6layer MLP with sigmoid activation function using SGD and momentum. We used 200 units per layer with sigmoid activation functions. We use a learning rate of 1e 3. C.3 CIFAR10 We use the same model with the same hyperparameters for both ResNet, mollified network and the stochastic depth. We borrowed the hyperparameters of the model from Huang et al. (2016a). Our mollified convnet model has residual connections coming from its layer below. C.4 PARITY The n-dimensional parity task is the task to figure out whether the sum of n-bits in a binary vector is even or odd. We use SGD with Nesterov momentum and initialize the weight matrices by using Glorot&Bengio initializationGlorot et al. (2011). For all models, we use the learning rate of 1e 3 and momentum of 0.92. ai is the parameters of mollified activation function are initialized by sampling from uniform distribution, U [2, 2]. C.5 LSTM LANGUAGE MODELING We trained 2-layered LSTM language models on PTB word-level. We used the models with the same hyperparameters as in Zaremba & Sutskever (2014). We used the same hyperparameters for both the mollified LSTM language model and the LSTM. We use hard-sigmoid activation function for both the LSTM and mollified LSTM language model. We use hard-sigmoid activation function for the gates of the LSTM. C.6 PREDICTING THE CHARACTER EMBEDDINGS FROM CHARACTERS We use 10k of these words as a validation and another 10k word embeddings as test set. We train a bidirectional-LSTM on top of each sequence of characters for each word and on top of the representation of bidirectional LSTM, we use a 5-layered tanh-MLP to predict the word-embedding. We train our models using RMSProp and momentum with learning rate of 6e 4 and momentum 0.92. The size of the minibatches, we used is 64. As seen in Figure 9, mollified LSTM network converges faster.",
      "exclude": false
    }
  ],
  "fewShot": [
    {
      "model": "claude-haiku-4-5",
      "decision": {
        "rejection": false,
        "confidence": 0.72,
        "primary_reason": "Novel theoretical framework connecting mollification, continuation methods, and neural network optimization with solid mathematical foundation and diverse experimental validation across multiple architectures."
      },
      "token": {
        "prompt_tokens": 7500,
        "completion_tokens": 63,
        "total_tokens": 7563
      },
      "time": "2026-02-08T22:14:21.539188+00:00"
    },
    {
      "model": "gpt-5.2",
      "decision": {
        "rejection": true,
        "confidence": 0.78,
        "primary_reason": "Interesting continuation/noise-smoothing framing, but the core technique largely repackages known ideas (noise injection, stochastic depth/skip connections, linearizing activations, curriculum/annealing) with unclear novelty and weak empirical positioning: results are on several toy/dated benchmarks with limited modern baselines/ablations, some instability/ad-hoc choices (e.g., annealing tied to loss then fixed), and the claimed “convex at p=1” simplification is not convincingly justified for the full network/objective, leaving impact below ICML/ICLR/NeurIPS bar."
      },
      "token": {
        "prompt_tokens": 9272,
        "completion_tokens": 147,
        "total_tokens": 9419
      },
      "time": "2026-02-09T20:17:54.135731+00:00"
    }
  ],
  "test": false
}